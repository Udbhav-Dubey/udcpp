
Writing First C++ Program – Hello World Example
Last Updated : 11 Jan, 2025

The “Hello World” program is the first step towards learning any programming language and is also one of the most straightforward programs you will learn. It is the basic program that is used to demonstrate how the coding process works. All you have to do is display the message “Hello World” on the output screen.
C++ Hello World Program

Below is the C++ program to print “Hello World” on the console screen.
1

// Header file for input output functions

2

#include <iostream>

3

using namespace std;

4

​

5

// main() function: where the execution of

6

// C++ program begins

7

int main() {

8

  

9

    // This statement prints "Hello World"

10

    cout << "Hello World";

11

​

12

    return 0;

13

}

Try it on GfG Practice
redirect icon

Output

Hello World

To write and run C++ programs, you need to set up the local environment on your computer. Refer to the complete article Setting up C++ Development Environment. If you do not want to set up the local environment on your computer, you can also use online IDE to write and run your C++ programs.
Working of Hello World Program in C++

Let us now understand every line and the terminologies of the above program.

    // C++ program to display “Hello World”

This line is a comment line. A comment is used to display additional information about the program. A comment does not contain any programming logic. When a comment is encountered by a compiler, the compiler simply skips that line of code.

    #include <iostream>

The #include is a preprocessor directive tells the compiler to include the content of a file in the source code. For example, #include<iostream> tells the compiler to include the input-output library which contains all C++’s input/output library functions.

    using namespace std

This is used to import the entity of the stdnamespace into the current namespace of the program. It is basically the space where all the inbuilt features of C++ are declared. For example, std::cout.

    int main() { }

The main() function is the entry point of every C++ program, no matter where the function is located in the program. The opening braces ‘{‘ indicates the beginning of the main function and the closing braces ‘}’ indicates the ending of the main function.

    cout<<“Hello World”;

The coutis a tool (object) that is used to display output on the console screen. Everything followed by the character << in double quotes ” ” is displayed on the output screen. The semi-colon character at the end of the statement is used to indicate that the statement is ending there.

    return 0

This statement is used to return a value from a function and indicates the finishing of a function. Here, it is used to sent the signal of successful execution of the main function.

Also, as you can see, the cout and the return statement have been indented or moved to the right side. This is done to make the code more readable. We must always use indentations and comments to make the code more readable. Must read the FAQ on the style of writing programs.


C++ Basic Syntax
Last Updated : 03 Feb, 2025

Syntax refers to the rules and regulations for writing statements in a programming language. They can also be viewed as the grammatical rules defining the structure of a programming language.

The C++ language also has its syntax for the functionalities it provides. Different statements have different syntax specifying their usage, but C++ programs also have basic syntax rules that are followed throughout all the programs.
Basic Syntax of a C++ Program

We can learn about basic C++ Syntax using the following program

// C++ program to demonstrate the basic syntax
// Header File Library
#include <iostream>

// Standard Namespace
using namespace std;

// Main Function
int main()
{

    // Body of the Function

    // Declaration of Variable
    int num1 = 24;
    int num2 = 34;

    int result = num1 + num2;

    // Output
    cout << result << endl;

    // Return Statement
    return 0;
}
58

The program above shows the basic C++ program that contains header files, main function, namespace declaration, etc. Let’s try to understand them one by one.
1. Header File

The header files contain the definition of the functions and macros we are using in our program. In line #1, we used the #include  <iostream> statement to tell the compiler to include an iostream header file library which stores the definition of the cin and cout standard input/output streams that we have used for input and output. #include is a preprocessor directive using which we import header files.
2. Namespace

A namespace in C++ is used to provide a scope or a region where we define identifiers. In line #2, we have used the using namespace std statement for specifying that we will be the standard namespace where all the standard library functions are defined.
3. Main Function

In line #3, we defined the main function as int main(). The main function is the most important part of any C++ program. The program execution always starts from the main function. All the other functions are called from the main function. In C++, the main function is required to return some value indicating the execution status.
4. Blocks

Blocks are the group of statements that are enclosed within { } braces. The body of the main function is from line #4 to line #9 enclosed within  { }.
5. Semicolons

As you may have noticed by now, each statement in the above code is followed by a ( ; ) semicolon symbol. It is used to terminate each line of the statement of the program.
6. Identifiers

We use identifiers for the naming of variables, functions, and other user-defined data types. An identifier may consist of uppercase and lowercase alphabetical characters, underscore, and digits. The first letter must be an underscore or an alphabet.
7. Keywords

In the C++ programming language, there are some reserved words that are used for some special meaning in the C++ program. It can’t be used for identifiers. For example, the words int, return, and using are some keywords used in our program.
8. Basic Output cout

In line #7, we have used the cout stream object (declared in the <iostream> header file) to print the sum of two numbers to the standard output stream (stdout).
Object-Oriented Programming in C++

C++ programming language supports both procedural-oriented and object-oriented programming. The above example is based on the procedural-oriented programming paradigm. So let’s take another example to discuss Object Oriented Programming in C++.
1

#include <iostream>

2

using namespace std;

3

​

4

class Calculate {

5

​

6

    // Access Modifiers

7

public:

8

​

9

    // data member

10

    int num1 = 50;

11

    int num2 = 30;

12

​

13

    // member function

14

    void addition() {

15

        int result = num1 + num2;

16

        cout << result << endl;

17

    }

18

};

19

​

20

int main() {

21

​

22

    // object declaration

23

    Calculate add;

24

    

25

    // member function calling

26

    add.addition();

27

​

28

    return 0;

29

}


Output

80

1. Class

A class is a user-defined data type. A class has its own attributes (data members) and behavior (member functions). In line #3, we have declared a class named Calculate and its body expands from line #3 to line #7.
2. Data Members & Member Functions

The attributes or data in the class are defined by the data members & the functions that work on these data members are called the member functions.

In the above example, num1 and num2 are the data member & addition() is a member function that is working on these two data members. There is a keyword here public that is access modifiers. The access modifier decides who has access to these data members & member functions.
3. Object

The object is an instance of a class. The class itself is just a template that is not allocated any memory. To use the data and methods defined in the class, we have to create an object of that class.

C++ Comments

Single Line Comment

In C++, single line comments are represented as // double forward slash. It applies comments to a single line only. The compiler ignores any text after // and it will not be executed.

Syntax:

    // Single line comment


Multi-Line Comment

A multi-line comment can occupy many lines of code, it starts with /* and ends with */, but it cannot be nested. Any text between /* and */ will be ignored by the compiler.

Syntax:

     /*
         Multiline Comment
         .
         .
         .
     */


Why Comments are used in C++?

Comments in C++ are used to summarize an algorithm, identify a variable’s purpose, or clarify a code segment that appears unclear. Comments are also used for:

    Comments are used for easier debugging.
    It makes a program more readable and gives an overall description of the code.
    Comments are helpful in skipping the execution of some parts of the code.
    Every time a program or code is reused after long periods of time, the comment recaps all the information of the code quickly.
    
    How does the compiler process C++ Comments?

As a part of the compiler, the Lexical Analyzer scans the characters and transforms them into tokens with no passing of the commented text to the parser. Since Comments do not contribute to the functionality of the program they are simply omitted at the time of compilation. Accordingly, we can understand that comments are just text in programs that are ignored by the compiler.

Tokens in C
Last Updated : 21 Jan, 2025

In C programming, tokens are the smallest units in a program that have meaningful representations. Tokens are the building blocks of a C program, and they are recognized by the C compiler to form valid expressions and statements. Tokens can be classified into various categories, each with specific roles in the program.
Types of Tokens in C
Tokens-in-C

The tokens of C language can be classified into six types based on the functions they are used to perform. The types of C tokens are as follows:

Table of Content

    Punctuators
    Keywords
    Strings
    Operators
    Identifiers
    Constants

1. Punctuators

The following special symbols are used in C having some special meaning and thus, cannot be used for some other purpose. Some of these are listed below:

    Brackets[]: Opening and closing brackets are used as array element references. These indicate single and multidimensional subscripts.
    Parentheses(): These special symbols are used to indicate function calls and function parameters.
    Braces{}: These opening and ending curly braces mark the start and end of a block of code containing more than one executable statement.
    Comma (, ): It is used to separate more than one statement like for separating parameters in function calls.
    Colon(:): It is an operator that essentially invokes something called an initialization list.
    Semicolon(;): It is known as a statement terminator.  It indicates the end of one logical entity. That’s why each individual statement must be ended with a semicolon.
    Asterisk (*): It is used to create a pointer variable and for the multiplication of variables.
    Assignment operator(=): It is used to assign values and for logical operation validation.
    Pre-processor (#): The preprocessor is a macro processor that is used automatically by the compiler to transform your program before actual compilation.
    Period (.): Used to access members of a structure or union.
    Tilde(~): Bitwise One’s Complement Operator.

Example:
1

#include <stdio.h>  

2

int main() {

3

  

4

    // '\n' is a special symbol that

5

    // represents a newline

6

    printf("Hello, World!\n");  

7

    return 0;

8

}


Output

Hello, World!

2. Keywords

Keywords are reserved words that have predefined meanings in C. These cannot be used as identifiers (variable names, function names, etc.). Keywords define the structure and behavior of the program C language supports 32 keywords some of them are:

    int, for, if, else, while, return, etc.

Example:
1

#include <stdio.h>  

2

int main() {

3

   

4

    // 'int' is a keyword used to define

5

    // variable type

6

    int x = 5;  

7

    printf("%d", x);

8

  

9

    // 'return' is a keyword used to exit

10

    // main function

11

    return 0;  

12

}


Output

5

    Note: The number of keywords may change depending on the version of C you are using. For example, keywords present in ANSI C are 32 while in C11, it was increased to 44. Moreover, in the latest c23, it is increased to around 54.

3. Strings

Strings are nothing but an array of characters ended with a null character (‘\0’). This null character indicates the end of the string. Strings are always enclosed in double quotes. Whereas a character is enclosed in single quotes in C and C++.

Examples:
1

#include <stdio.h>  

2

int main() {

3

  

4

    // "Hello, World!" is a string literal

5

    char str[] = "Hello, World!";  

6

    printf("%s", str);

7

    return 0;

8

}


Output

Hello, World!

4. Operators

Operators are symbols that trigger an action when applied to C variables and other objects. The data items on which operators act are called operands. 
Depending on the number of operands that an operator can act upon, operators can be classified as follows: 

    Unary Operators: Those operators that require only a single operand to act upon are known as unary operators.For Example increment and decrement operators
    Binary Operators: Those operators that require two operands to act upon are called binary operators. Binary operators can further are classified into: 
        Arithmetic operators
        Relational Operators
        Logical Operators
        Assignment Operators
        Bitwise Operator
    Ternary Operator: The operator that requires three operands to act upon is called the ternary operator. Conditional Operator(?) is also called the ternary operator.

Example:
1

#include <stdio.h>  

2

int main() {

3

    int a = 10, b = 5;  

4

  

5

    // '+' is an arithmetic operator used

6

    // for addition

7

    int sum = a + b;  

8

    printf("%d", sum); 

9

    return 0;

10

}


Output

15

5. Identifiers

Identifiers are names given to variables, functions, arrays, and other user-defined items. They must begin with a letter (a-z, A-Z) or an underscore (_) and can be followed by letters, digits (0-9), and underscores.

Example:
1

#include <stdio.h>  

2

int main() {

3

  

4

    // 'num' is an identifier used to name

5

    // a variable

6

    int num = 10;  

7

    printf("%d", num); 

8

    return 0;

9

}


Output

10

6. Constants

Constants are fixed values used in a C program. These values do not change during the execution of the program. Constants can be integers, floating-point numbers, characters, or strings.

Examples:
1

#include <stdio.h>  

2

int main() {

3

  

4

    // 'MAX_VALUE' is a constant that holds

5

    // a fixed value

6

    const int MAX_VALUE = 100;  

7

    printf("%d", MAX_VALUE);

8

    return 0;

9

}


Output

100


C++ Keywords
Last Updated : 23 Dec, 2024

Keywords are the reserved words that have special meanings in the C++ language. They are the words that the language uses for a specifying the components of the language, such as void, int, public, etc. They can’t be used for a variable name or function name or any other identifiers.

Let’s take a look at the hello world code:
#include <iostream>
using namespace std;

int main() {
  
    cout << "Hello World";
  
    return 0;
}
ello World

Explanation: In the above code, using, namespace, and return are the keywords that are used to implement some functionality of the language. Their meaning is predefined in C++ and will always remain same.

The total number of keywords in C++ are 95 upto C++ 23 specification. Below is the table for all C++ keywords:
alignas	alignof	and	and_eq	asm
auto	bitand	bitor	bool	break
case	catch	char	char8_t	char16_t
char32_t	class	compl	concept	const
consteval	constexpr	constinit	const_cast	continue
co_await	co_return	co_yield	decltype	default
delete	do	double	dynamic_cast	else
enum	explicit	export	extern	false
final	float	for	friend	goto
if	inline	int	long	mutable
namespace	new	noexcept	not	not_eq
nullptr	operator	or	or_eq	private
protected	public	register	reinterpret_cast	requires
return	short	signed	sizeof	static
static_assert	static_cast	struct	switch	template
this	thread_local	throw	true	try
typedef	typeid	typename	union	unsigned
using	virtual	void	volatile	wchar_t
while	xor	xor_eq		
Keywords vs Identifiers

So, there are some properties of keywords that distinguish keywords from identifiers. They listed in the below table
Keywords	 Identifiers
Keywords are predefined/reserved words	 identifiers are the values used to define different programming items like a variable, integers, structures, and unions.
It defines the type of entity.	It classifies the name of the entity.
A keyword contains only alphabetical characters, 	an identifier can consist of alphabetical characters, digits, and underscores.
It should be lowercase.	It can be both upper and lowercase.
No special symbols or punctuations are used in keywords and identifiers. 	No special symbols or punctuations are used in keywords and identifiers.  The only underscore can be used in an identifier.
Example: int, char, while, do.	Example: Geeks_for_Geeks, GFG, Gfg1
ifference between Keyword and Identifier in C
Last Updated : 23 Dec, 2024

In C, keywords and identifiers are basically the fundamental parts of the language used. Identifiers are the names that can be given to a variable, function or other entity while keywords are the reserved words that have predefined meaning in the language.

The below table illustrates the primary differences between the keywords and identifiers:
Parameters	Keywords	Identifiers
Definition	Keywords are predefined word that gets reserved for working program that have special meaning and cannot get used anywhere else.	Identifiers are the values used to define different programming items such as variables, integers, structures, unions and others and mostly have an alphabetic character.
Use	Specify the type/kind of entity.	Identify the name of a particular entity.
	It always starts with a lowercase letter.	First character can be a uppercase, lowercase letter or underscore.
Rules of Definition	A keyword should be in lower case and can only contains alphabetical characters.	An identifier can be in upper case or lower case and can consist of alphabetical characters, digits and underscores.
Purpose	They help to identify a specific property that exists within a computer language.	They help to locate the name of the entity that gets defined along with a keyword.
Examples	int, char, if, while, do, class etc.	Test, count1, high_speed, etc.
Keywords

Keywords are specific reserved words in C each of which has a specific feature associated with it. Almost all of the words which help us use the functionality of the C language are included in the list of keywords. So, you can imagine that the list of keywords is not going to be a small one! There are a total of 32 keywords in C:

auto
	

break
	

case
	

char
	

const
	

continue
	

default
	

do

double
	

else
	

enum
	

extern
	

float
	

for
	

goto
	

if

int
	

long
	

register
	

return
	

short
	

signed
	

sizeof
	

static

struct
	

switch
	

typedef
	

union
	

unsigned
	

void
	

volatile
	

while
Identifiers

Identifiers are used as the general terminology for naming of variables, functions and arrays. These are user defined names consisting of arbitrarily long sequence of letters and digits with either a letter or the underscore(_) as a first character. Identifier names must differ in spelling and case from any keywords. You cannot use keywords as identifiers; they are reserved for special use. Once declared, you can use the identifier in later program statements to refer to the associated value. A special kind of identifier, called a statement label, can be used in goto statements.
Code Illustration

The below example illustrate the different purpose of the keywords and identifers in C:
1

#include <stdio.h>

2

​

3

// 'main' is also an identifier

4

// although it is predefined

5

int main() {

6

  

7

    // Example of a keyword: int

8

      // Here, age is identifier

9

    int age = 25;

10

​

11

    printf("Age: %d\n", age);

12

​

13

    // return is a keyword that exits function

14

    return 0; 

15

}


Output

Age: 25

Explanation: In the above code, age is an identifier used to name a variable. The type of variable is integer that is specified using int keyword as it already is defined in C to indicate that the variable will store integer data.

C++ Variables
Last Updated : 19 Dec, 2024

In C++, variable is a name given to a memory location. It is the basic unit of storage in a program. The value stored in a variable can be accessed or changed during program execution. In this article, we will learn about the variables in C++ and how to use them in our programs.

Let’s take a look at an example:
1

#include <iostream>

2

using namespace std;

3

​

4

int main() {

5

    

6

      // A variable that may store the data of

7

      // int type (whole numbers)

8

    int var;

9

  

10

      // Assigning a whole number

11

      var = 100;

12

  

13

      // Printing the variable

14

      cout << var;

15

  

16

    return 0;

17

}


Output

100

Explanation: A variable with name var is created. It is of the type int (keyword for integer) and can store the whole numbers. In the next step, we assigned a value 100 to it and finally, we access the stored value using the variable’s name.

The C++ Course covers the types of variables in C++ and how to use them effectively in your programs.
Syntax of Variables

Creating a variable and giving it a name is called variable definition. The syntax of variable definition is:

    type name;

Here,

    type: type of data that a variable can store.
    name: name assigned to the variable.

Multiple variables of the same type can be defined as:

    type name1, name2, name3 ….;

Types of Variables

In C++, following are the data types a variable can store:

    int: For storing integers or whole numbers.
    float: For storing real numbers with decimal points.
    char: For storing single characters.
    bool: For storing boolean value i.e. true and false.
    string: For storing the textual data.

Rules For Naming Variable

The names given to a variable is called identifiers. There are some rules for giving a name to the variable:

    The name of the variable contains letters, digits, and underscores.
    The name of the variable is case sensitive (e.g. Arr and arr both are different variables).
    The name of the variable does not contain any whitespace and special characters (ex #, $, %, *, etc).
    All the variable names must begin with a letter of the alphabet or an underscore (_).
    We cannot used C++ keyword (e.g. float, double, class) as a variable name.

Some valid variable names: x, var, _here, arr40
Some invalid variable names: 89, a b, double
Variable Initialization

The next step is initialization. It means assigning an initial value to the variable. It is done by using an assignment operator = with the variable name as left operand and the value as the right operand.

    type name = value;      // At the time of declaration
    name = value;      // After declaration
    type name1 = value1, name2 = value2;      // For multiple variables

The value should be of the same type as variable. For example, a variable declared as int var; should only store the integer variable.
Examples of Variables

The below examples demonstrate how to use the variables in our C++ programs:
Store Data in a Variable and Print It
1

#include <iostream>

2

using namespace std;

3

​

4

int main() {

5

​

6

    // Defining and initializing a variable

7

      int age1 = 15;

8

  

9

      // Defining a variable

10

      int age2;

11

  

12

      // Initialize the variable

13

      age2 = 99;

14

  

15

      // Displaying variable

16

      cout << age1 << endl;

17

      cout << age2;

18

    return 0;

19

}


Output

15
99

Create Multiple Variables at Once
1

#include <iostream>

2

using namespace std;

3

​

4

int main() {

5

  

6

      // Creating three variables that store characters

7

      char a = 'A', b = 'B', c = 'C';

8

  

9

      // Update the value

10

      c = 'c';

11

​

12

    cout << a << " " << b << " " << c;

13

    return 0;

14

}


Output

A B c

Memory Management of Variables

When a variable is declared, the compiler is told about the variable name and the type of data it will store. It is not allocated the any memory at this point. It is when the variable is defined it is allocated the memory. The amount of memory allocated depends upon the type of data that a variable intends to store.

Initially, the variable only stores some garbage value (value that does not mean anything). At the time of initialization, it is assigned some meaningful value that using the assignment operator that is then stored in the memory allocated to the function. So basically, we are manipulating a specific part of memory using the variable name.

At last, the data stored in the allocated memory can be accessed using the variable name.


Scope of Variables in C++
Last Updated : 10 Dec, 2024

In C++, the scope of a variable is the extent in the code upto which the variable can be accessed or worked with. It is the region of the program where the variable is accessible using the name it was declared with.

Let’s take a look at an example

#include <iostream>
using namespace std;

// Declaring first variable
int a = 10;

int main() {

      // Declaring second variable
      int b = 9;

      // Accessing a and b variable in their scope
    cout << a << " " << b;

    return 0;
}
Global Scope

Global scope refers to the region outside any function or a block. The variables declared here are accessible throughout the entire program and are called Global Variables.

Local Scope

The local scope is the region inside the curly braces { }. Variables defined within a function or block are said to be local to those functions or a block and are called local variables. Local variables do not exist outside the block in which they are declared, i.e. they cannot be accessed or used outside that block.
Variable Shadowing

Consider that there is a local variable inside a function with the same name as that of a global variable. If the function tries to access the variable with that name, then which variable will be given precedence? Look at the below program to understand the question:  
1

#include<iostream>

2

using namespace std;

3

​

4

// Global variable

5

int a = 5;

6

​

7

int main() {

8

  

9

    // Local variable with same name as that of

10

      // global variable

11

    int a = 100;

12

  

13

      // Accessing a

14

    cout << a;

15

  

16

      return 0;

17

}


Output

100

Explanation: The variable a declared at the top is global variable and stores the value 5 whereas a declared within main function is local and stores a value 100. When accessed inside the main function, the local a’s value is printed. Also, there is no compilation error. It implies that

        If two variables with same name are defined in different scopes, the compiler allows it and does not show error.
        Whenever there is a local variable defined with same name as that of a global variable, the precedence is given to the local variable. This is called variable shadowing.
        Access Global Variable in Variable Shadowing

The global a is still available in the main function but is shadowed by the local a as it is available everywhere. One may ask if there is any way we can access the global a in the main function.

Yes, C++ allows the users to access global variable with the same name as local variable using scope resolution operator. The below examples show how it is done:
1

#include<iostream>

2

using namespace std;

3

​

4

// Global variable

5

int a = 5;

6

​

7

int main() {

8

  

9

    // Local variable with same name as that of

10

      // global variable

11

    int a = 100;

12

  

13

      // Accessing global a

14

    cout << ::a;

15

  

16

      return 0;

17

}


Output

5
why do we use << in cpp, i was used to = in c during printf
ChatGPT said:
ChatGPT

In C, you use printf for output, which relies on format specifiers:

printf("Hello, %s!\n", "world");

In C++, << is the insertion operator, used with cout for output:

std::cout << "Hello, world!" << std::endl;

Why use << instead of =?

    Operator Overloading: << is overloaded in C++ to work as a stream insertion operator for std::cout. It sends data to the output stream.

    Type Safety: Unlike printf, cout automatically handles different data types without format specifiers.

    Chaining: You can chain multiple insertions easily:

    std::cout << "Number: " << 42 << ", Pi: " << 3.14 << std::endl;

    This avoids dealing with format specifiers like %d or %f.

    Extensibility: You can overload << for custom classes, allowing seamless output formatting.

Would you like a deeper comparison of printf vs. cout in terms of performance or use cases?



Variations of Scopes in C++

Apart from the primary classification of the scopes as global and local, there are few other specialized variations of these scopes that divides the declared variable based on its accessibility and visibility. Following are some common variations of variable scopes in C++.

    Instance Scope
    Static Member Scope
    Namespace Scope

Instance Scope

In C++, instance scope refers to the region inside a class but outside any member function of the class. The variable declared here are called instance variables and are accessible to whole class. They can be accessed by the objects of the class.


#include <iostream>
using namespace std;

class A {
public:
  
      // Instance variable with instance scope i.e. accessible
      // in whole class
    int instanceVar;

    A(int val) {
        instanceVar = val;
    }

    void display() {
        cout << instanceVar << endl;
    }
};

int main() {
  
      // Creates a1 with instanceVar = 10
    A a1(1);
    a1.display();

      // Creates a2 with instanceVar = 20
    A a2(33);
    a2.display();

    return 0;
}
Static Member Scope

The static scope applies to variables and functions declared with the static keyword within the class. These variables are shared across all instances of a class and can be accessed using the class name without creating the instance.

Let’s take a look at an example:
#include <iostream>
using namespace std;

class A {
public:
  
      // Static variable with static scope i.e. accessible
      // in whole class
    static int staticVar;
};

int A::staticVar = 1;

int main() {
  
      // Access static variable
      cout << A::staticVar;

    return 0;
}
1

Namespace Scope

A namespace in C++ is a container that allows users to create a separate scope where the given variables are defined. It is used to avoid name conflicts and group related code together. These variables can be then accessed using their namespace name and scope resolution operator.

For example, the below program creates a variable inside a namespace and access it later using namespace name and scope resolution operator.
#include <iostream>
using namespace std;

namespace N {
      
      // Variable with namespace scope
    int namespaceVar = 10;
}

int main() {
  
      // Access variable using namespace
    cout << N::namespaceVar;  

    return 0;
}
10

Storage Classes in C++ with Examples
Last Updated : 24 Dec, 2024

C++ Storage Classes are used to describe the characteristics of a variable/function. It determines the lifetime, visibility, default value, and storage location which helps us to trace the existence of a particular variable during the runtime of a program. Storage class specifiers are used to specify the storage class for a variable.

C++ provides 6 different storage classes, which are as follows:

Table of Content

    auto Storage Class
    extern Storage Class
    static Storage Class
    register Storage Class
    mutable Storage Class
    thread_local Storage Class

Below is a detailed explanation of each storage class:
1. auto Storage Class

The auto storage class is the default class of all the variables declared inside a block. The auto stands for automatic and all the local variables that are declared in a block automatically belong to this class.

Properties of auto Storage Class Objects

    Scope: Local
    Default Value: Garbage Value
    Memory Location: RAM
    Lifetime: Till the end of its scope

Let’s take a look at an example:

Storage Classes in C++ with Examples
Last Updated : 24 Dec, 2024

C++ Storage Classes are used to describe the characteristics of a variable/function. It determines the lifetime, visibility, default value, and storage location which helps us to trace the existence of a particular variable during the runtime of a program. Storage class specifiers are used to specify the storage class for a variable.

C++ provides 6 different storage classes, which are as follows:

Table of Content

    auto Storage Class
    extern Storage Class
    static Storage Class
    register Storage Class
    mutable Storage Class
    thread_local Storage Class

Below is a detailed explanation of each storage class:
1. auto Storage Class

The auto storage class is the default class of all the variables declared inside a block. The auto stands for automatic and all the local variables that are declared in a block automatically belong to this class.

Properties of auto Storage Class Objects

    Scope: Local
    Default Value: Garbage Value
    Memory Location: RAM
    Lifetime: Till the end of its scope

Let’s take a look at an example:
#include <iostream>
using namespace std;

int main() {

    // Declaring an auto variable
    int a = 32;
    float b = 3.2;
    string c = "GeeksforGeeks";

    // Printing the auto variables
    cout << a << " \n";
    cout << b << " \n";
      cout << c << " \n";

    return 0;
}
32 
3.2 
GeeksforGeeks 

    Note: Earlier in C++, we could use the auto keyword to declare the auto variables explicitly but after C++11, the meaning of auto keyword is changed, and we could no longer use it to define the auto variables.

2. extern Storage Class

The extern storage class simply tells us that the variable is defined elsewhere and not within the same scope (or even source file) where it is used (i.e. external linkage). Basically, the variable is created in a different scope or file and can be used in a different file as well.

A normal global variable can be made extern as well by placing the extern keyword before its declaration/definition in any function/block. The main purpose of using extern variables is that they can be accessed between two different files which are part of a large program.

Properties of extern Storage Class Objects

    Scope: Global
    Default Value: Zero
    Memory Location: RAM
    Lifetime: Till the end of the program.

Let’s take a look at an example:

def.cpp
1

// Defining a global variable with external linkage

2

int var = 10;


#include <iostream>
using namespace std;

// Telling compiler that variable x is extern variable
// and has been defined elsewhere
extern int x;

int main() {
  
      // Printing the value of x
    cout << x;

    return 0;
}
10

3. static Storage Class

The static storage class is used to declare static variables that have the property of preserving their value even after they are out of their scope. They are initialized only once and exist until the termination of the program. Thus, no new memory is allocated because they are not re-declared. Global static variables can be accessed anywhere in the program but unlike extern variable, they have internal linkage so they cannot be accessed outside the program.

They are declared using static keyword.

Properties of static Storage Class

    Scope: Local
    Default Value: Zero
    Memory Location: RAM
    Lifetime: Till the end of the program
    
    #include <iostream>
using namespace std;

// Function containing static variables
// memory is retained during execution
int func() {
  
      // Static variable
    static int count = 0;
    count++;
    return count;
}

int main() {
    cout << func() << "\n";
    cout << func();
    
    return 0;
}
4. register Storage Class

The register storage class declares register variables using the register keyword which has the same functionality as that of the auto variables. The only difference is that the compiler tries to store these variables in the register of the microprocessor if a free register is available. This makes the use of register variables to be much faster than that of the variables stored in the memory during the runtime of the program. If a free register is not available, these are then stored in the RAM.

An important and interesting point to be noted here is that we cannot obtain the address of a register variable using pointers.

Properties of register Storage Class Objects

    Scope: Local
    Default Value: Garbage Value
    Memory Location: Register in CPU or RAM
    Lifetime: Till the end of its scope
    
    #include <iostream>
using namespace std;

int main() {

    // Declaring a register variable
    register char b = 'G';

    // Printing the register variable 'b'
    cout << b;
  
    return 0;
}
G

    Note: The register keyword is deprecated in C++17 onwards.

5. mutable Storage Class

Sometimes there is a requirement to modify one or more data members of class/struct through the const function even though you don’t want the function to update other members of class/struct. This task can be easily performed by using the mutable keyword. The keyword mutable is mainly used to allow a particular data member of a const object to be modified. 

When we declare a function as const, this pointer passed to the function becomes const. Adding a mutable to a variable allows a const pointer to change members.
Properties of mutable Storage Class

The mutable specifier does not affect the linkage or lifetime of the object. It will be the same as the normal object declared in that place.

Let’s take a look at an example:
#include <iostream>
using namespace std;

class A {
public:
    int x;

    // Defining mutable variable y
    // now this can be modified
    mutable int y;

    A(): x(4), y(10) {}
};

int main() {
  
    // a is created as constant
    const A a;

    // Trying to change the value
    a.y = 200;
    cout << a.y;

    // Uncommenting below lines
    // will throw error
    /* a.x = 8;
    cout << a.x; */
  
    return 0;
}
200

6. thread_local Storage Class

The thread_local Storage Class is the new storage class that was added in C++11. We can use the thread_local storage class specifier to define the object as thread_local. The thread_local variable can be combined with other storage specifiers like static or extern and the properties of the thread_local object changes accordingly.

Properties of thread_local Storage Class

    Memory Location: RAM
    Lifetime: Till the end of its thread
    #include <iostream>
#include <mutex>
#include <thread>

using namespace std;

// Defining thread-local variable
thread_local int val = 10;

// Mutex for synchronization
mutex mtx;

int main() {
  
    // Created 3 threads
    // Modify value in thread 1
    thread th1([]() {
        val += 18;
        lock_guard<mutex> lock(mtx);
        cout << "Thread 1 value: " << val << '\n';
    });

    thread th2([]() {
      
        // Modify value in thread 2
        val += 7;
        lock_guard<mutex> lock(mtx);
        cout << "Thread 2 value: " << val << '\n';
    });

    thread th3([]() {
      
        // Modify value in thread 3
        val += 13;
        lock_guard<mutex> lock(mtx);
        cout << "Thread 3 value: " << val << '\n';
    });

    // Wait for all threads to finish
    th1.join();
    th2.join();
    th3.join();

    // Print the value of value in the main thread
    cout << "Main thread value: " << val << '\n';

    return 0;
}
Thread 1 value Value: 28
Thread 2 value Value: 17
Thread 3 value Value: 23
Main thread value Value: 10

As we can see, each thread got its own copy of the thread_local variable and was only assigned the value that was specified in its callable.
Summary

The below table summarize the above storage classes:
2. extern Storage Class

The extern storage class simply tells us that the variable is defined elsewhere and not within the same scope (or even source file) where it is used (i.e. external linkage). Basically, the variable is created in a different scope or file and can be used in a different file as well.

A normal global variable can be made extern as well by placing the extern keyword before its declaration/definition in any function/block. The main purpose of using extern variables is that they can be accessed between two different files which are part of a large program.

Properties of extern Storage Class Objects

    Scope: Global
    Default Value: Zero
    Memory Location: RAM
    Lifetime: Till the end of the program.

Let’s take a look at an example:
// Defining a global variable with external linkage
int var = 10;
#include <iostream>
#include >
using namespace std;

// Telling compiler that variable x is extern variable
// and has been defined elsewhere
extern int x;

int main() {
  
      // Printing the value of x
    cout << x;

    return 0;
}


Static Keyword in C++
Last Updated : 11 Jan, 2025

The static keyword in C++ has different meanings when used with different types. In this article, we will learn about the static keyword in C++ along with its various uses.

In C++, a static keyword can be used in the following context:

Table of Content

    Static Variables in a Function
    Static Member Variable in a Class
    Static Member Functions in a Class
    Global Static Variable

Static Variables in a Function

In a function, when a variable is declared as static, space for it gets allocated for the lifetime of the program. Even if the function is called multiple times, space for the static variable is allocated only once and the value of the variable in the previous call gets carried through the next function call.

Let’s take a look at an example:
	
	You can see in the above program that the variable count is declared static. So, its value is carried through the function calls. The variable count is not getting initialized every time the function is called. As a side note, Java doesn’t allow static local variables in functions.

Applications

The static variables in a function have the following applications:

    Return local variable address from the function.
    Useful for implementing coroutines in C++ or any other application where the previous state of function needs to be stored.
    Memoization in recursive calls.
    
    Static Data Member in a Class

As the variables declared as static are initialized only once as they are allocated space in separate static storage so, the static member variables in a class are shared by the objects. There cannot be multiple copies of the same static variables for different objects. Also because of this reason static variables cannot be initialized using constructors.
undefined reference to `GfG::i'
collect2: error: ld returned 1 exit status

Explanation: You can see in the above program that we have tried to create multiple copies of the static variable i for multiple objects. But this didn’t happen.

So, a static variable inside a class should be initialized explicitly by the user using the class name and scope resolution operator outside the class as shown below: 

Let’s take a look at an example:

#include <iostream>
using namespace std;

class GfG {
public:
  
      // Static data member
    static int i;

    GfG(){
        // Do nothing
    };
};

int main() {
    GfG obj1;
    GfG obj2;
    obj1.i = 2;
    obj2.i = 3;

    // Prints value of i
    cout << obj1.i << " " << obj2.i;
}
		
		
		#include <iostream>
using namespace std;

class GfG {
public:
  
      // Static data member
    static int i;

    GfG(){
        // Do nothing
    };
};

// Static member inintialization
int GfG::i = 1;

int main() {
  
    // Prints value of i
    cout << GfG::i;
}
1

Explanation: We were able to access the static variable when is was initialized globally outside the class. Moreover, we can access the static data member without creating the object of the class.

Applications

The static data members can be used to implement the following:

    Counting Objects of a Class
    Store and share configuration or settings globally.
    Tracking Shared Resources
    Regulate or limit operations performed by multiple objects.
    Ensure a class has only one instance by using static members.


Static Member Functions in a Class

Just like the static data members or static variables inside the class, static member functions also do not depend on the object of the class. We are allowed to invoke a static member function using the object and the ‘.’ operator but it is recommended to invoke the static members using the class name and the scope resolution operator. Static member functions are allowed to access only the static data members or other static member functions, they cannot access the non-static data members or member functions of the class. 

Let’s take a look at an example:
1

#include <iostream>

2

using namespace std;

3

​

4

class GfG {

5

public:

6

  

7

    // Static member function

8

    static void printMsg() { cout << "Welcome to GfG!"; }

9

};

10

​

11

int main() {

12

  

13

    // Invoking a static member function

14

    GfG::printMsg();

15

}


Output

Welcome to GfG!
Applications

The static member functions have the following uses in C++:

    Accessing Static Member Variables
    Implement helper functions that do not depend on specific instances.
    Singleton Pattern Implementation
    Factory Methods to create and return objects without requiring an instance of the class.
    Logging and Debugging

Global Static Variable

A global static variable in C++ is a static variable declared outside of any class or function. Unlike regular global variables, a global static variable has internal linkage, meaning it is accessible only within the file where it is defined. This ensures that its scope is limited to the current translation unit, preventing conflicts with variables in other files that may have the same name.

Let’s take a look at an example:
1

#include <iostream>

2

using namespace std;

3

​

4

// Global static variable

5

static int count = 0;

6

​

7

void increment() {

8

    count++;

9

    cout << count << " ";

10

}

11

​

12

int main() {

13

    increment();

14

    increment();

15

    return 0;

16

}


Output

1 2 

Applications

The global static variables have the following uses in C++:

    Limiting variable scope to a file to prevent conflicts by ensuring the variable is accessible only within the file.
    Global counters or flags.
    Store settings or values that are specific to the functionality implemented in a single file.
    Use for shared resources in scenarios where frequent initialization and destruction can be avoided.
    Shared state across functions in a file.
    	
    DAta types
    	
    	
    	n C++, data types are classified into the following types:

S. No.
	Type	Description	Data Types

1
	Basic Data Types	Built-in or primitive data types that are used to store simple values.	int, float, double, char, bool, void

2
	Derived Data Types	Data types derived from basic types.	array, pointer, reference, function

3

	User Defined Data Types	Custom data types created by the programmer according to their need.	class, struct, union, typedef, using
	
	
1. Character Data Type (char)

The character data type is used to store a single character. The keyword used to define a character is char. Its size is 1 byte and it stores characters enclosed in single quotes (‘ ‘). It can generally store upto 256 characters according to their ASCII codes.

Syntax

    char name;



	#include <iostream>
using namespace std;

int main() {
  
      // Character variable
      char c = 'A';  
    cout << c;
  
    return 0;
}

2. Integer Data Type (int)

Integer data type denotes that the given variable can store the integer numbers. The keyword used to define integers is int. Its size is 4-bytes (for 64-bit) systems and can store numbers for binary, octal, decimal and hexadecimal base systems in the range from -2,147,483,648 to 2,147,483,647.

2. Integer Data Type (int)

Integer data type denotes that the given variable can store the integer numbers. The keyword used to define integers is int. Its size is 4-bytes (for 64-bit) systems and can store numbers for binary, octal, decimal and hexadecimal base systems in the range from -2,147,483,648 to 2,147,483,647
    int name;

where, name is the identifier assigned to the variable.
#include <iostream>
using namespace std;

int main() {

      // Creating an integer variable
    int x = 25;
    cout << x << endl;
  
      // Using hexadecimal base value
      x = 0x15;
      cout << x;

    return 0;
}
3. Boolean Data Type (bool)

The boolean data type is used to store logical values: true(1) or false(0). The keyword used to define a boolean variable is bool. Its size is 1 byte.

Syntax

    bool name;

where name is the identifier assigned to the variable.

Example
#include <iostream>
using namespace std;

int main() {
  
      // Creating a boolean variable
    bool isTrue = true;  
    cout << isTrue;
    return 0;
}
1

4. Floating Point Data Type (float)

Floating-point data type is used to store numbers with decimal points. The keyword used to define floating-point numbers is float. Its size is 4 bytes (on 64-bit systems) and can store values in the range from 1.2E-38 to 3.4e+38.

Syntax

    float name;


#include <iostream>
using namespace std;

int main() {
  
      // Floating point variable with a decimal value
      float f = 36.5;
      cout << f;
  
    return 0;
}
5. Double Data Type (double)

The double data type is used to store decimal numbers with higher precision. The keyword used to define double-precision floating-point numbers is double. Its size is 8 bytes (on 64-bit systems) and can store the values in the range from 1.7e-308 to 1.7e+308

Syntax
double name;

#include <iostream>
using namespace std;

int main() {
  
      // double precision floating point variable
      double pi = 3.1415926535;
      cout << pi;
  
    return 0;
}
3.14159

6. Void Data Type (void)

The void data type represents the absence of value. We cannot create a variable of void type. It is used for pointer and functions that do not return any value using the keyword void.
    void functionName();


#include <iostream>
using namespace std;

// Function with void return type
void hello() {
    cout << "Hello, World!" << endl;
}

int main() {
      hello();
    return 0;
}
Hello, World!

Size of Data Types in C++

Earlier, we mentioned that the size of the data types is according to the 64-bit systems. Does it mean that the size of C++ data types is different for different computers?

Actually, it is partially true. The size of C++ data types can vary across different systems, depending on the architecture of the computer (e.g., 32-bit vs. 64-bit systems) and the compiler being used. But if the architecture of the computer is same, then the size across different computers remains same.

We can find the size of the data type using sizeof operator.
#include <iostream>
using namespace std;

int main() {

    // Printing the size of each data type
    cout << "Size of int: " << sizeof(int) << " bytes" << endl;
    cout << "Size of char: " << sizeof(char) << " byte" << endl;
    cout << "Size of float: " << sizeof(float) << " bytes" << endl;
    cout << "Size of double: " << sizeof(double) << " bytes";

    return 0;
}
Size of int: 4 bytes
Size of char: 1 byte
Size of float: 4 bytes
Size of double: 8 bytes

Data Type Modifiers

Data type modifiers are the keywords used to change or give extra meaning to already existing data types. It is added to primitive data types as a prefix to modify their size or range of data they can store. There are 4 type modifiers in C++: short, long, signed and unsigned.

For Example,

Defining an int with long type modifier will change its size to 8 bytes:

    int => 4 bytes
    long int => 8 bytes

Similarly, other type modifiers also affect the size or range of the data type.

    long double, long long int, unsigned int, etc.

Data Types in C++ – FAQs
Is size of data types in C++ is different for different machines?

    Partially yes as the size of data types in C++ can vary across different machines depending on the system architecture (32-bit or 64-bit). But if the architecture is same, then size remains same.

Can I convert one data type value or variable to another?

    Yes, in C++, you can convert one data type to another using type casting. 

How many data types are there in C++?

    There are following number of data types in C++:

        Primitive Data Types: 6
        Derived Data Types: 4
        User Defined Data Types: 5

Why we need int if we can already represent integer values with float?

    int is more efficient for representing whole numbers as it avoids the rounding errors inherent in float allows for fast integer-specific operations like bitwise manipulation
    
Literals in C
Last Updated : 21 Jun, 2024

In C, Literals are the constant values that are assigned to the variables. Literals represent fixed values that cannot be modified. Literals contain memory but they do not have references as variables. Generally, both terms, constants, and literals are used interchangeably. 
For example, “const int = 5;“, is a constant expression and the value 5 is referred to as a constant integer literal.
Types of C Literals

There are 4 types of literal in C:

    Integer Literal
    Float Literal
    Character Literal
    String Literal


C-literals
1. Integer Literals

Integer literals are used to represent and store the integer values only. Integer literals are expressed in two types i.e.

A) Prefixes: The Prefix of the integer literal indicates the base in which it is to be read.
For Example:

    0x10 = 16

    Because 0x prefix represents a HexaDecimal base. So 10 in HexaDecimal is 16 in Decimal. Hence the value 16.

There are basically represented into 4 types:

a. Decimal-literal(base 10): A non-zero decimal digit followed by zero or more decimal digits(0, 1, 2, 3, 4, 5, 6, 7, 8, 9).

Example:

56, 78

b. Octal-literal(base 8): a 0 followed by zero or more octal digits(0, 1, 2, 3, 4, 5, 6, 7).

Example:

045, 076, 06210

c. Hex-literal(base 16): 0x or 0X followed by one or more hexadecimal digits(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, a, A, b, B, c, C, d, D, e, E, f, F).

Example:

0x23A, 0Xb4C, 0xFEA

d. Binary-literal(base 2): 0b or 0B followed by one or more binary digits(0, 1).

Example:

0b101, 0B111

B) Suffixes: The Suffixes of the integer literal indicates the type in which it is to be read.

For example:

    12345678901234LL 

    indicates a long long integer value 12345678901234 because of the suffix LL

These are represented in many ways according to their data types.

    int: No suffix is required because integer constant is by default assigned as an int data type.
    unsigned int: character u or U at the end of an integer constant.
    long int: character l or L at the end of an integer constant.
    unsigned long int: character ul or UL at the end of an integer constant.
    long long int: character ll or LL at the end of an integer constant.
    unsigned long long int: character ull or ULL at the end of an integer constant.

Example:
1

#include <stdio.h>

2

​

3

int main()

4

{

5

​

6

    // constant integer literal

7

    const int intVal = 10;

8

​

9

    printf("Integer Literal:%d \n", intVal);

10

    return 0;

11

}


Output

Integer Literal:10 

2. Floating-Point Literals

These are used to represent and store real numbers. The real number has an integer part, real part, fractional part, and exponential part. The floating-point literals can be stored either in decimal form or exponential form. While representing the floating-point decimals one must keep two things in mind to produce valid literal:

    In the decimal form, one must include the integer part, or fractional part, or both, otherwise, it will lead to an error.
    In the exponential form, one must include both the significand and exponent part, otherwise, it will lead to an error.

A few floating-point literal representations are shown below:

Valid Floating Literals:

10.125
1.215e-10L
10.5E-3

Invalid Floating Literals:

123E
1250f
0.e879

Example:
1

#include <stdio.h>

2

​

3

int main()

4

{

5

    // constant float literal

6

    const float floatVal = 4.14;

7

​

8

    printf("Floating point literal: %.2f\n",

9

        floatVal);

10

    return 0;

11

}


Output

Floating point literal: 4.14

3. Character Literals

This refers to the literal that is used to store a single character within a single quote. To store multiple characters, one needs to use a character array. Storing more than one character within a single quote will throw a warning and display just the last character of the literal. It gives rise to the following two representations:

    char type: This is used to store normal character literal or narrow-character literals. 

Example:

char chr = 'G';

Example:
1

#include <stdio.h>

2

​

3

int main()

4

{

5

    // constant char literal

6

    const char charVal = 'A';

7

​

8

    printf("Character Literal: %c\n",

9

        charVal);

10

    return 0;

11

}


Output

Character Literal: A


Escape Sequences: There are various special characters that one can use to perform various operations.
4. String Literals

String literals are similar to that character literals, except that they can store multiple characters and uses a double quote to store the same. It can also accommodate the special characters and escape sequences mentioned in the table above. We can break a long line into multiple lines using string literal and can separate them with the help of white spaces.
Example:

char stringVal[] = "GeeksforGeeks";

Example:
1

#include <stdio.h>

2

​

3

int main()

4

{

5

    const char str[]

6

        = "Welcome\nTo\nGeeks\tFor\tGeeks";

7

    printf("%s", str);

8

    return 0;

9

}


Output

Welcome
To
Geeks    For    Geeks
Derived Data Types in C++
Last Updated : 18 Dec, 2024

The data types that are derived from the primitive or built-in datatypes are referred to as Derived Data Types. They are generally the data types that are created from the primitive data types and provide some additional functionality.

In C++, there are four different derived data types:

Table of Content

    Functions
    Arrays
    Pointers
    References
    
    
User Defined Data Types in C++
Last Updated : 16 Jan, 2025

User defined data types are those data types that are defined by the user himself. In C++, these data types allow programmers to extend the basic data types provided and create new types that are more suited to their specific needs. C++ supports 5 user-defined data types:

Table of Content

    Class
    Structure
    Union
    Enumeration
    Typedef

Let’s take a look at each of them one by one.
1. Class

A Class is the building block of C++’s Object-Oriented programming paradigm. It is a user-defined data type, which holds its own data members and member functions, which can be accessed and used by creating an instance of that class. A class is like a blueprint for an object.
#include <bits/stdc++.h>
using namespace std;

class GfG {
  
    // Access specifier
public:
  
    // Data Member
    string name;

    // Member Function
    void printname() {
        cout << name;
    }
};

int main() {

    // Declare an object of class geeks
    GfG g;

    // Accessing data member
    g.name = "GeeksForGeeks";

    // Accessing member function
    g.printname();

    return 0;
}
Explanation: The above program defines a class named GfG with a name attribute and a function printname() to print the name. In the main function, it creates an object named g, sets the geekname as “GeeksforGeeks“, and calls the printname() function to display it.
2. Structure

A Structure is a user-defined data type like class. A structure creates a data type that can be used to group items of possibly different types into a single type.

3. Union

Like structures , union is also user-defined data type used to group data of different type into a single type. But in union, all members share the same memory location.
Explanation: The above program demonstrates the use of unions. Union named A with members i and c is defined that shares the same memory space. It is shown that when we only assign c some value, the i also stores the same value.
4. Enumeration

Enumeration (or enum) is a user-defined data type in C++ mainly used to assign names to integral constants, the names make a program easy to read and maintain.
5. Typedef and Using

C++ allows you to define explicitly new data type names by using the keywords typedef or using. They do not create a new data class, rather, defines a name for an existing type. This can increase the portability (the ability of a program to be used across different types of machines; i.e., mini, mainframe, micro, etc; without many changes to the code) of a program as only the typedef statements would have to be changed.

Data Type Ranges and Their Macros in C++
Last Updated : 18 Dec, 2024

Most of the times, in competitive programming, there is a need to assign the variable, the maximum or minimum value that data type can hold but remembering such a large and precise number comes out to be a difficult job. Therefore, C++ has certain macros to represent these numbers, so that these can be directly assigned to the variable without actually typing the whole number.

The <climits> header file in C++ defines macros that represent the upper and lower bounds of integer data types and <cfloat> defines the macros for float and double limits. These macros allow you to easily assign these extreme values to variables without manually typing them out.

Let’s take a look at an example:
#include <iostream>

// for int, char macros
#include <climits>

// for float, double macros
#include <cfloat>

using namespace std;

int main() {
  
    // Displaying ranges with the help of macros
    cout << "char ranges from: " << CHAR_MIN << " to "
         << CHAR_MAX << endl;

    cout << "\nnshort int ranges from: " << SHRT_MIN
         << " to " << SHRT_MAX << endl;
    cout << "\nint ranges from: " << INT_MIN << " to "
         << INT_MAX << endl;
    cout << "\nlong int ranges from: " << LONG_MIN << " to "
         << LONG_MAX << endl;
    cout << "\nfloat ranges from: " << FLT_MIN << " to "
         << FLT_MAX << endl;

    return 0;
}
Output

char ranges from: -128 to 127

nshort int ranges from: -32768 to 32767

int ranges from: -2147483648 to 2147483647

long int ranges from: -9223372036854775808 to 9223372036854775807

float ranges from: 1.17549e-38 to 3.40282e+38
Data Types and Their Range Macros

A list of some of the data type macros is mentioned below:

Data Type
	

Range
	

Macro for min value
	

Macro for max value

char
	

-128 to +127
	

CHAR_MIN
	

CHAR_MAX

short char
	

-128 to +127
	

SCHAR_MIN
	

SCHAR_MAX

unsigned char
	

0 to 255
	

—
	

UCHAR_MAX

short int
	

-32768 to +32767
	

SHRT_MIN
	

SHRT_MAX

unsigned short int
	

0 to 65535
	

—
	

USHRT_MAX

int
	

-2147483648 to +2147483647
	

INT_MIN
	

INT_MAX

unsigned int
	

0 to 4294967295
	

—
	

UINT_MAX

long int
	

-9223372036854775808 to +9223372036854775807
	

LONG_MIN
	

LONG_MAX

unsigned long int
	

0 to 18446744073709551615
	

—
	

ULONG_MAX

long long int
	

-9223372036854775808 to +9223372036854775807
	

LLONG_MIN
	

LLONG_MAX

unsigned long long int
	

0 to 18446744073709551615
	

—
	

ULLONG_MAX

float
	

1.17549e-38 to 3.40282e+38
	

FLT_MIN
	

FLT_MAX

float (negative)
	

-1.17549e-38 to -3.40282e+38
	

-FLT_MIN
	

-FLT_MAX

double
	

2.22507e-308 to 1.79769e+308
	

DBL_MIN
	

DBL_MAX

double (negative)
	

-2.22507e-308 to -1.79769e+308
	

-DBL_MIN
	

-DBL_MAX
Data Type Limits in Modern C++

The above macro approach for the upper and lower limits of the data type is the old C language approach inherited by C++. But C++ also have its own method to provide programmers with the same information.

C++ offers the numeric_limits<> class template as a modern alternative to these macros. This template provides a more object-oriented approach for accessing data type limits. It is defined inside the <limits> header file.

Let’s take a look at an example:
#include <iostream>
#include <limits>
using namespace std;

int main() {
  
    // Displaying ranges with the help of macros
    cout << "short int ranges from: " << numeric_limits<short int>::min()
         << " to " << numeric_limits<short int>::max() << endl;
    cout << "\nint ranges from: " << numeric_limits<int>::min() << " to "
         << numeric_limits<int>::max() << endl;
    cout << "\nlong int ranges from: " << numeric_limits<long>::min() << " to "
         << numeric_limits<long>::max() << endl;
    cout << "\nfloat ranges from: " << numeric_limits<float>::min() << " to "
         << numeric_limits<float>::max() << endl;

    return 0;
}
short int ranges from: -32768 to 32767

int ranges from: -2147483648 to 2147483647

long int ranges from: -9223372036854775808 to 9223372036854775807

float ranges from: 1.17549e-38 to 3.40282e+38
.
Data Types and Their Range Macros

A list of some of the data type macros is mentioned below:

Data Type
	

Range
	

Macro for min value
	

Macro for max value

char
	

-128 to +127
	

CHAR_MIN
	

CHAR_MAX

short char
	

-128 to +127
	

SCHAR_MIN
	

SCHAR_MAX

unsigned char
	

0 to 255
	

—
	

UCHAR_MAX

short int
	

-32768 to +32767
	

SHRT_MIN
	

SHRT_MAX

unsigned short int
	

0 to 65535
	

—
	

USHRT_MAX

int
	

-2147483648 to +2147483647
	

INT_MIN
	

INT_MAX

unsigned int
	

0 to 4294967295
	

—
	

UINT_MAX

long int
	

-9223372036854775808 to +9223372036854775807
	

LONG_MIN
	

LONG_MAX

unsigned long int
	

0 to 18446744073709551615
	

—
	

ULONG_MAX

long long int
	

-9223372036854775808 to +9223372036854775807
	

LLONG_MIN
	

LLONG_MAX

unsigned long long int
	

0 to 18446744073709551615
	

—
	

ULLONG_MAX

float
	

1.17549e-38 to 3.40282e+38
	

FLT_MIN
	

FLT_MAX

float (negative)
	

-1.17549e-38 to -3.40282e+38
	

-FLT_MIN
	

-FLT_MAX

double
	

2.22507e-308 to 1.79769e+308
	

DBL_MIN
	

DBL_MAX

double (negative)
	

-2.22507e-308 to -1.79769e+308
	

-DBL_MIN
	

-DBL_MAX 


Data Type Limits in Modern C++

The above macro approach for the upper and lower limits of the data type is the old C language approach inherited by C++. But C++ also have its own method to provide programmers with the same information.

C++ offers the numeric_limits<> class template as a modern alternative to these macros. This template provides a more object-oriented approach for accessing data type limits. It is defined inside the <limits> header file.

Let’s take a look at an example:
#include <iostream>
#include <limits>
using namespace std;

int main() {
  
    // Displaying ranges with the help of macros
    cout << "short int ranges from: " << numeric_limits<short int>::min()
         << " to " << numeric_limits<short int>::max() << endl;
    cout << "\nint ranges from: " << numeric_limits<int>::min() << " to "
         << numeric_limits<int>::max() << endl;
    cout << "\nlong int ranges from: " << numeric_limits<long>::min() << " to "
         << numeric_limits<long>::max() << endl;
    cout << "\nfloat ranges from: " << numeric_limits<float>::min() << " to "
         << numeric_limits<float>::max() << endl;

    return 0;
}
short int ranges from: -32768 to 32767

int ranges from: -2147483648 to 2147483647

long int ranges from: -9223372036854775808 to 9223372036854775807

float ranges from: 1.17549e-38 to 3.40282e+38

It is recommended to use this approach to find the upper and lower limits of the data type instead of macros as it is more type safe, and readable compared to the macro-based approach.




C++ Type Modifiers
Last Updated : 30 Dec, 2024

In C++, type modifiers are the keywords used to change or give extra meaning to already existing data types. It is added to primitive data types as a prefix to modify their size or range of data they can store.

C++ have 4 type modifiers which are as follows:

Let’s understand at each of them one by one.
1. signed Modifier

The signed modifier indicates that the given variable variables can store both positive and negative values. To specify any variable as signed, just add the keyword signed at the start of the variable declaration.

Syntax

    signed type name;


#include <iostream>
using namespace std;

int main() {
  
      // Printing the size of normal and signed int
      cout << "signed int size: " << sizeof(signed int)
          << " bytes" << endl;
    cout << "int size: " << sizeof(int) << " bytes";

    return 0;
}
signed int's size: 4 bytes
int's size: 4 bytes

    Note: The int datatype is signed by default. So, int can directly be used instead of signed int.


2. unsigned Modifier

The unsigned modifier indicates that the given variables can store only non-negative integer values. Like signed modifier, it is also added at the start of the variable declaration to define the given variable as unsigned.

Syntax

    unsigned type name;

Unsigned modifier can only be used with integer and character data types.

2. unsigned Modifier

The unsigned modifier indicates that the given variables can store only non-negative integer values. Like signed modifier, it is also added at the start of the variable declaration to define the given variable as unsigned.

Syntax

    unsigned type name;

Unsigned modifier can only be used with integer and character data types.
As we can see, when we assigned some negative value to unsigned integer, the value gets converted to its 2’s complement because unsigned types cannot store the negative values.
3. short Modifier

The short keyword decreases the size of the data type in the memory. It leads to the decrease in the range of value that the given data type can store. A variable can be declared as short by adding the short keyword before the variable declaration.

Syntax

    short type name;

#include <iostream>
using namespace std;

int main() {
  
      // Printing the size of short and normal ints
    cout << "short int size: " << sizeof(short int)
          << " bytes" << endl;
      cout << "int size: " << sizeof(int)
          << " bytes";
    return 0;
}
4. long Modifier

The long keyword increases the size of the data type in memory. It leads to increase in the range of value that the given data type can store. A variable can be declared as long by adding the long keyword before the variable declaration.

Syntax

    long type name;

The long modifier can be used with integer and double data type. It can also be used twice on integers.

Example:
1

#include <iostream>

2

using namespace std;

3

​

4

int main() {

5

  

6

      // Printing the size of long and normal ints

7

      // double and long double

8

    cout << "int size: " << sizeof(int)

9

          << " bytes" << endl;

10

      cout << "long int size: " << sizeof(long int)

11

          << " bytes" << endl;

12

      cout << "double size: " << sizeof(double)

13

          << " bytes" << endl;

14

      cout << "long double size: " << sizeof(long double)

15

          << " bytes";

16

    return 0;

17

}
int size: 4 bytes
long int size: 8 bytes
double size: 8 bytes
long double size: 16 bytes

    Note: The long int can be written as long also. They are equivalent.


Size and Range of Data Types with Modifiers

The below table lists the size and the range of data type (in 64-bit compiler) that is changed with the help of modifiers:
Data Type	Modifiers	Size (bytes)	Range
char	signed	1	-128 to 127
unsigned (default)	1	0 to 255
short int	signed (default)	2	-32,768 to 32,767
unsigned	2	0 to 65,535
int	signed (default)	4	-2,147,483,648 to 2,147,483,647
unsigned	4	0 to 4,294,967,295
long int	signed (default)	8	-9,223,372,036,854,775,808 to 9,223,372,036,854,775,807
unsigned	8	0 to 18,446,744,073,709,551,615
long long int	signed (default)	8	-9,223,372,036,854,775,808 to 9,223,372,036,854,775,807
unsigned	8	0 to 18,446,744,073,709,551,615
double	None	8	~1.7E-308 to 1.7E+308
long double	None	16	Higher precision, range varies depending on implementatio

The short keyword can only be used with integer data type.
    Note: The short int can be written as short also. They are equivalent.


Type Conversion in C++
Last Updated : 30 Dec, 2024

Type conversion means converting one type of data to another compatible type such that it doesn’t lose its meaning. It is essential for managing different data types in C++.

Let’s take a look at an example:
#include <iostream>
using namespace std;

int main() {
  
      // Two variables of different type
    int i = 10;
    char c = 'A';
  
      // printing c after manually converting it
      cout << (int)c << endl;
      
      // Adding i and c,
      int sum = i + c;
  
      // Printing sum
      cout << sum;
      
    return 0;
}
65
75

Explanation: The character c = (‘A’) is manually converted to its ASCII integer value using (int)c. The addition of i = 10 and c involves automatic type conversion, where the character c is automatically converted to its ASCII value (65) before the addition. The C++ Course covers the various methods of type conversion, helping you understand how to handle data types correctly.

In C++, there are two types of type conversion:
Implicit Type Conversion

Implicit type conversion (also known as coercion) is the conversion of one type of data to another type automatically by the compiler when needed. It happens automatically when:

    Operations are performed on values of different data types.
    If you pass an argument to a function that expects a different data type.
    Assigning a value of one data type to a variable of another data type.
    
    #include <iostream>
using namespace std;

int main() {
  
    int i = 10;
    char c = 'a';

    // c implicitly converted to int. ASCII
    // value of 'a' is 97
    i = i + c;

    // x is implicitly converted to float
    float f = i + 1.0;

    cout << "i = " << i << endl
         << "c = " << c << endl
         << "f = " << f;

    return 0;
}
i = 107
c = a
f = 108

It is possible for implicit conversions to lose information, signs can be lost (when signed is implicitly converted to unsigned), and overflow can occur (when long long is implicitly converted to float).
Cases of Implicit Type Conversion

1. For Numeric Type

All the data types of the variables are upgraded to the data type of the variable with largest data type. For numeric type,

    bool -> char -> short int -> int ->  unsigned int -> long -> unsigned -> long long -> float -> double -> long double

2. Pointer Conversions

Pointers to derived classes can be converted to pointers to base classes automatically.

3. Boolean Conversion

Any scalar type (integer, floating-point, pointer) is implicitly converted to bool in a context that requires a Boolean value (e.g., if, while, for conditions).
Explicit Type Conversion

Explicit type conversion, also called type casting is the conversion of one type of data to another type manually by a programmer. Here the user can typecast the result to make it of a particular data type. In C++, it can be done by two ways: 
1. C Style Typecasting

This method is inherited by C++ from C. The conversion is done by explicitly defining the required type in front of the expression in parenthesis. This can be also known as forceful casting.

    (type) expression;

where type indicates the data type to which the final result is converted. 
#include <iostream>
using namespace std;

int main() {
    double x = 1.2;

    // Explicit conversion from double to int
    int sum = (int)x + 1;

    cout << sum;

    return 0;
}
2

This typecasting is considered old and unsafe because it performs no checks whatsoever to determine whether the casting is valid or not.
C++ Style Typecasting

C++ introduced its own typecasting method using cast operators. Cast operator is an unary operator which forces one data type to be converted into another data type. C++ supports four types of casting:

    Static Cast: Used for standard compile time type conversions.
    Dynamic Cast: Used for runtime type conversion in polymorphism and inheritance.
    Const Cast: Removes or adds const or volatile qualifiers.
    Reinterpret Cast: Used for low-level reinterpretation of bits (e.g., converting pointers).
    #include <iostream>
using namespace std;

int main() {
    double x = 1.2;

    // Explicit conversion from double to int
    int sum = static_cast<int>(x + 1);

    cout << sum;
    return 0;
}
2

Risks of Type Conversion

Type conversion provides useful functionality to the language but also introduces certain risks:

    Data loss that occurs when converting from a larger type to a smaller type (e.g., int to char).
    Undefined behavior that happens when casting pointers between unrelated types and dereferencing them.
    Violation of const correctness when removing const with const_cast and modifying the variable leads to undefined behavior.
    Memory misalignment casting pointers to types with stricter alignment can cause crashes.
    
    ### **`#include <bits/stdc++.h>` vs. `#include <iostream>` in C++**
Both headers serve different purposes in C++ programming. Let's break it down:

---

## **1️⃣ `#include <bits/stdc++.h>` (All-in-One Header)**
This is a **non-standard header** that includes **almost all** C++ standard libraries at once.  
It is mainly used in **competitive programming** to save time.

### ✅ **Advantages:**
✔ **Includes Everything** – You don’t need to manually `#include` multiple headers like `<vector>`, `<map>`, `<cmath>`, etc.  
✔ **Faster to Write** – Saves time in contests.  
✔ **Reduces Debugging Effort** – No missing header errors.  

### ❌ **Disadvantages:**
❌ **Non-Standard** – It **only works with GCC/Clang**, not in MSVC (Microsoft Visual C++).  
❌ **Increases Compilation Time** – Since it includes **everything**, compiling is slower.  
❌ **Not Recommended for Production Code** – Makes code **less readable** and includes unnecessary libraries.  

### **Example Usage (`bits/stdc++.h`)**
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    vector<int> v = {1, 2, 3};
    cout << "Size: " << v.size() << endl;
    return 0;
}
```
- This works because `<bits/stdc++.h>` automatically includes `<vector>` and `<iostream>`.

---

## **2️⃣ `#include <iostream>` (Standard Library)**
This is a **standard** header file that only includes **input-output functionality**.

### ✅ **Advantages:**
✔ **Standard and Portable** – Works on all compilers.  
✔ **Faster Compilation** – Only includes necessary code.  
✔ **Better for Large Projects** – Keeps dependencies minimal.  

### ❌ **Disadvantages:**
❌ **Requires Manual Inclusion of Other Headers** – If you need vectors, maps, etc., you must include `<vector>`, `<map>`, etc.  

### **Example Usage (`iostream` Only)**
```cpp
#include <iostream>
using namespace std;

int main() {
    cout << "Hello, World!" << endl;
    return 0;
}
```
- This only provides **input/output** (`cin`, `cout`).
- If you need `vector`, `map`, etc., you must manually `#include` them.

---

## **🚀 Which One Should You Use?**
| Feature              | `#include <bits/stdc++.h>` | `#include <iostream>` |
|----------------------|-------------------------|------------------|
| **Compilation Speed** | ❌ Slower | ✅ Faster |
| **Portability**       | ❌ GCC/Clang Only | ✅ Works Everywhere |
| **Readability**      | ❌ Messy | ✅ Clearer |
| **Memory Usage**     | ❌ Higher | ✅ Lower |
| **Use Case**         | ✅ Competitive Programming | ✅ Production & Large Projects |

👉 **Use `#include <bits/stdc++.h>`** in **competitive programming** for speed.  
👉 **Use `#include <iostream>` and proper headers** in **real-world applications** for better performance and maintainability.  

Let me know if you have more questions! 🚀

1. static_cast

The static_cast operator is the most commonly used casting operator in C++. It performs compile-time type conversion and is mainly used for explicit conversions that are considered safe by the compiler. 

Syntax


    static_cast <new_type> (exp);

where,

    exp: Data to be converted.
    new_type: Desired type of expression

The static_cast can be used to convert between related types, such as numeric types or pointers in the same inheritance hierarchy.

Example
#include <bits/stdc++.h>
using namespace std;

int main() {

    int n = 10;

    // converting int to double
    double nd = static_cast<double>(n);

    // printing data type
    cout << typeid(n).name() << endl;

    // typecasting
    cout << typeid(static_cast<double>(n)).name() << endl;

    // Printing double type
    cout << typeid(nd).name();

    return 0;
}

typeid operator in C++ with Examples
Last Updated : 03 Sep, 2021

typeid is an operator in C++. 

    It is used where the dynamic type or runtime type information of an object is needed.
    It is included in the <typeinfo> library. Hence inorder to use typeid, this library should be included in the program.
    The typeid expression is an lvalue expression.

Syntax:  

typeid(type);
OR
typeid(expression);

Parameters: typeid operator accepts a parameter, based on the syntax used in the program:  

    type: This parameter is passed when the runtime type information of a variable or an object is needed. In this, there is no evaluation that needs to be done inside type and simply the type information is to be known.
    expression: This parameter is passed when the runtime type information of an expression is needed. In this, the expression is first evaluated. Then the type information of the final result is then provided.

Return value: This operator provides the runtime type information of the specified parameter and hence that type information is returned, as a reference to an object of class type_info.
Usage: typeid() operator is used in different way according to the operand type. 

    When operand is a variable or an object.
    // C++ program to show the use of typeid operator 

#include <iostream> 
#include <typeinfo> 
using namespace std; 

int main() 
{ 
	int i, j; 
	char c; 

	// Get the type info using typeid operator 
	const type_info& ti1 = typeid(i); 
	const type_info& ti2 = typeid(j); 
	const type_info& ti3 = typeid(c); 

	// Check if both types are same 
	if (ti1 == ti2) 
		cout << "i and j are of"
			<< " similar type" << endl; 
	else
		cout << "i and j are of"
			<< " different type" << endl; 

	// Check if both types are same 
	if (ti2 == ti3) 
		cout << "j and c are of"
			<< " similar type" << endl; 
	else
		cout << "j and c are of"
			<< " different type" << endl; 

	return 0; 
} 

i and j are of similar type
j and c are of different type
// C++ program to show the use of typeid operator 

#include <iostream> 
#include <typeinfo> 
using namespace std; 

int main() 
{ 
	int i = 5; 
	float j = 1.0; 
	char c = 'a'; 

	// Get the type info using typeid operator 
	const type_info& ti1 = typeid(i * j); 
	const type_info& ti2 = typeid(i * c); 
	const type_info& ti3 = typeid(c); 

	// Print the types 
	cout << "ti1 is of type "
		<< ti1.name() << endl; 

	cout << "ti2 is of type "
		<< ti2.name() << endl; 

	cout << "ti3 is of type "
		<< ti3.name() << endl; 

	return 0; 
} 

ti1 is of type f
ti2 is of type i
ti3 is of type c

Explanation: In this example, we have used typeid() operator to check the data type. We have defined an integer variable n and converted it into a double using static_cast. After that, we print the data types of variables and pass static_cast<double>(n) in typeid() to check its data type. we can see the output “i, d, d” is printed where i denotes integer and d denotes double.
1. static_cast

The static_cast operator is the most commonly used casting operator in C++. It performs compile-time type conversion and is mainly used for explicit conversions that are considered safe by the compiler. 

Syntax


    static_cast <new_type> (exp);

where,

    exp: Data to be converted.
    new_type: Desired type of expression

The static_cast can be used to convert between related types, such as numeric types or pointers in the same inheritance hierarchy.
#include <bits/stdc++.h>
using namespace std;

int main() {

    int n = 10;

    // converting int to double
    double nd = static_cast<double>(n);

    // printing data type
    cout << typeid(n).name() << endl;

    // typecasting
    cout << typeid(static_cast<double>(n)).name() << endl;

    // Printing double type
    cout << typeid(nd).name();

    return 0;
}

i
d
d

Explanation: In this example, we have used typeid() operator to check the data type. We have defined an integer variable n and converted it into a double using static_cast. After that, we print the data types of variables and pass static_cast<double>(n) in typeid() to check its data type. we can see the output “i, d, d” is printed where i denotes integer and d denotes double.

2. dynamic_cast - after oops

3. const_cast

The const_cast operator is used to modify the const or volatile qualifier of a variable. It allows programmers to temporarily remove the constancy of an object and make modifications. Caution must be exercised when using const_cast, as modifying a const object can lead to undefined behavior.

Syntax

    const_cast <new_type> (exp);


#include <iostream>
using namespace std;

int main() {

    const int n = 5;
  
    // Pointer to a const int
    const int* ptr = &n;

    // int* nonConstPtr = ptr; if we use this
    // instead of without using const_cast
    // we will get error of invalid conversion
    int* nonConstPtr = const_cast<int*>(ptr);
    *nonConstPtr = 10;

    cout << *nonConstPtr;

    return 0;
}

10

Explanation: In the above example, we have modified the value of the const type pointer by changing its qualifier from const to non-const and then printing the modified value.
4. reinterpret_cast

The reinterpret_cast operator is used to convert the pointer to any other type of pointer. It does not perform any check whether the pointer converted is of the same type or not.

Syntax

    reinterpret_cast <new_type> (exp);


#include <iostream>
using namespace std;

int main() {
    int n = 10;
  
    // Store the address of number in nptr
    int* nptr = &n;

    // Reinterpreting the pointer as a char pointer
    char* charptr = reinterpret_cast<char*>(nptr);

    // Printing the memory addresses and values
    cout << "Integer Address: " << nptr << endl;
    cout << "Char Address: " << charptr;

    return 0;
}
Integer Address: 0x7ffcd595d6fc
Char Address: 0x7ffcd595d6fc

Explanation: In the above example, we have defined an int variable n and then store the address of n in nptr of the int type after that we have converted the nptr of the int type into char pointer and then store it into charptr variable. To verify that we have printed the address of both nptr and charptr. To print the address stored in charptr reinterpret_cast<void*> is used to bypass the type-checking mechanism of C++ and allow the pointer to be printed as a generic memory address without any type-specific interpretation.
    Note: const_cast and reinterpret_cast are generally not recommended as they vulnerable to different kinds of errors.




Operators in C++
Last Updated : 20 Jan, 2025

In C++, an operator is a symbol that operates on a value to perform specific mathematical or logical computations on given values. They are the foundation of any programming language.
#include <iostream>
using namespace std;
int main() {
  
    int a = 10 + 20;
  
    cout << a;
    return 0;
}

. Arithmetic Operators

Arithmetic operators are used to perform arithmetic or mathematical operations on the operands. For example, ‘+’ is used for addition.
Name	Symbol	Description
Addition	+	Adds two operands.
Subtraction	–	Subtracts second operand from the first.
Multiplication	*	Multiplies two operands.
Division	/	Divides first operand by the second operand.
Modulo Operation	%	Returns the remainder an integer division.

Increment
	

++
	

Increase the value of operand by 1.

Decrement
	

—
	

Decrease the value of operand by 1.

2. Relational Operators

Relational operators are used for the comparison of the values of two operands. For example, ‘>’ check right operand is greater.
Name	Symbol	Description
Is Equal To	==	Checks both operands are equal
Greater Than	>	Checks first operand is greater than the second operand
Greater Than or Equal To	>=	Checks first operand is greater than equal to the second operand
Less Than	<	Checks first operand is lesser than the second operand
Less Than or Equal To	<=	Checks first operand is lesser than equal to the second operand
Not Equal To	!=	Checks both operands are not equal

3. Logical Operators

Logical operators are used to combine two or more conditions or constraints or to complement the evaluation of the original condition in consideration. The result returns a Boolean value, i.e., true or false.
Name	Symbol	Description
Logical AND	&&	Returns true only if all the operands are true or non-zero.
Logical OR	||	Returns true if either of the operands is true or non-zero.
Logical NOT	!	Returns true if the operand is false or zero.
4. Bitwise Operators

Bitwise operators are works on bit-level. So, compiler first converted to bit-level and then the calculation is performed on the operands.
Name	Symbol	Description
Binary AND	&	Copies a bit to the evaluated result if it exists in both operands
Binary OR	|	Copies a bit to the evaluated result if it exists in any of the operand
Binary XOR	^	Copies the bit to the evaluated result if it is present in either of the operands but not both
Left Shift	<<	Shifts the value to left by the number of bits specified by the right operand.
Right Shift	>>	Shifts the value to right by the number of bits specified by the right operand.
One’s Complement	~	Changes binary digits 1 to 0 and 0 to 1


Unary Operators in C
Last Updated : 04 Feb, 2025

In C programming, unary operators are operators that operate on a single operand. These operators are used to perform operations such as negation, incrementing or decrementing a variable, or checking the size of a variable. They provide a way to modify or manipulate the value of a single variable in an efficient manner.

C provides 9 unary operators that can be used to perform various operations on a single variable. These include:
1. Increment Operator (++)

The increment operator ( ++ ) is used to increment the value of the variable by 1. The increment can be done in two ways:

A. Prefix Increment

In this method, the operator precedes the operand (e.g., ++a). The value of the operand will be altered before it is used. For example:
B. Postfix Increment

In this method, the operator follows the operand (e.g., a++). The value operand will be altered after it is used. For example:


2. Decrement Operator (–)

The decrement operator ( — ) is used to decrement the value of the variable by 1. The decrement can be done in two ways:

A. Prefix Decrement

In this method, the operator precedes the operand (e.g., – -a). The value of the operand will be altered before it is used. For example:

    int a = 1;
    int b = –a;  // b = 0

B. Postfix Decrement

In this method, the operator follows the operand (e.g., a- -). The value of the operand will be altered after it is used. For example:

    int a = 1;
    int b = a–;   // b = 1
    int c = a;     // c = 0

Below example shows the implementation of decrement (–):
Unary Plus

The unary plus (+) operator does not change the sign of its argument; it simply returns the value as is. It is often used for code clarity rather than functionality.

    int a = -10;  
    int b = +a;  // b = -10 

The unary plus is different from the addition operator, as addition requires two operands.

Below is the implementation of the unary plus (+) operator:
Unary Minus

The minus operator ( – ) changes the sign of its argument. A positive number becomes negative, and a negative number becomes positive.

     int a = 10;
    int b = -a;  // b = -10

Unary minus is different from the subtraction operator, as subtraction requires two operands.

Below is the implementation of the unary minus (-) operator:
Logical NOT ( ! )

The logical NOT operator ( ! ) is used to reverse the logical state of its operand. If a condition is true, then the Logical NOT operator will make it false.

Example:

    If x is true, then !x is false
    If x is false, then !x is true

Below is the implementation of the NOT (!) operator:
Bitwise NOT ( ~ )

The bitwise NOT (~) operator inverts all bits of its operand. Each 0 becomes 1, and each 1 becomes 0. It effectively calculates the two’s complement negative equivalent of a number in signed integers.

    x = 5 (00000101 in binary),
    ~x = ~6 (11111010 in binary, two’s complement representation)

Below is the implementation of the bitwise NOT (~) operator:
Addressof Operator (&)

The addressof operator ( & ) gives an address of a variable. It is used to return the memory address of a variable. These addresses returned by the address-of operator are known as pointers because they “point” to the variable in memory.

Example:

    & gives an address on variable n 
    int a;
    int *ptr;
    ptr = &a; // address of a is copied to the location ptr. 

Below is the implementation of the Addressof operator(&):
Indirection Operator (*)

The indirection operator (*), also known as the dereference operator, is used to access the value stored at a memory address. It is used with pointers to retrieve the value stored at the referenced memory location.


sizeof()

This operator returns the size of its operand, in bytes. The sizeof() operator always precedes its operand. The operand is an expression, or it may be a cast.

    Note: The `sizeof()` operator in C++ is machine dependent. For example, the size of an ‘int’ in C++ may be 4 bytes in a 32-bit machine but it may be 8 bytes in a 64-bit machine.


1. Addition Assignment (+=)

Adds the value of the right operand to the left operand and stores the result in the left operand.
2. Subtraction Assignment (-=)

Subtracts the value of the right operand from the left operand and stores the result in the left operand.
3. Multiplication Assignment (*=)

Multiplies the value of the right operand by the left operand and stores the result in the left operand.
4. Division Assignment (/=)

Divides the left operand by the right operand and stores the result in the left operand
5. Modulus Assignment (%=)

Takes the modulus of the left operand by the right operand and stores the result in the left operand
6. Bitwise AND Assignment (&=)

Performs a bitwise AND operation and assigns the result.
7. Bitwise OR Assignment (|=)

Performs a bitwise OR operation and assigns the result.
8. Bitwise XOR Assignment (^=)

Performs a bitwise XOR operation and assigns the result.
9. Bitwise Left Shift Assignment (<<=)

Shifts the bits of the left operand to the left by the number of positions specified by the right operand and assigns the result.
10. Bitwise Right Shift Assignment (>>=)

Shifts the bits of the left operand to the right by the number of positions specified by the right operand and assigns the result

C++ sizeof Operator
Last Updated : 09 Dec, 2024

The sizeof operator is a unary compile-time operator used to determine the size of variables, data types, and constants in bytes at compile time. It can also determine the size of classes, structures, and unions.
Syntax of sizeof in C++

The sizeof operator can be used to find the size of a type or a variable in C++ as shown:

    sizeof (type)
    sizeof (expression)

Examples of sizeof in C++

The below examples demonstrate the common usage of sizeof in C++:




Scope Resolution Operator in C++
Last Updated : 11 Jan, 2025

In C++, the scope resolution operator (::) is used to access the identifiers such as variable names and function names defined inside some other scope in the current scope. Let’s take a look at an example:

1

#include <iostream>

2

​

3

int main() {

4

​

5

      // Accessing cout from std namespace using scope

6

      // resolution operator

7

    std::cout << "GeeksforGeeks";

8

​

9

    return 0;

10

}


Output

GeeksforGeeks

Explanation: The std namespace contains the declaration of cout. So, to use cout, we first need to tell the compiler that it is declared inside the std namespace which is done using ::. The compiler then resolves the cout from there.
Syntax of Scope Resolution Operator

The scope resolution operator follows this general syntax:

    scope_name :: identifier

where scope_name is the name of the scope where identifier is defined.
Applications of Scope Resolution Operator

Following are the main applications of scope resolution operator illustrated with an example:
Accessing Global Variables

When a local variable shadows a global variable, we can use :: to access the global variable
#include <iostream>
using namespace std;

// Global x
int x = 3;

int main() {
      
      // Local x
    int x = 10;
  
      // Printing the global x
    cout << ::x;
  
    return 0;
}
Refer to Base Class Member in Derived Class

The scope resolution operator can also be used to refer to the members of base class in a derived class especially if they have the same name.
#include <bits/stdc++.h>
using namespace std;

class Base {
public:
    void func() {
        cout << "Base class func()" << endl;
    }
};

class Derived : public Base {
public:
  
      // Overridden function
    void func() {
        cout << "Derived class func()" << endl;
    }
};

int main() {
    Derived obj;
  
      // Calling base class's func() from the object of
      // derived class
    obj.Base::func();
  
    obj.func();
    return 0;
}
Base class func()
Derived class func()




input /output 


Basic Input / Output in C++
Last Updated : 09 Jan, 2025

In C++, input and output are performed in the form of a sequence of bytes or more commonly known as streams.

    Input Stream: If the direction of flow of bytes is from the device (for example, Keyboard) to the main memory then this process is called input.
    Output Stream: If the direction of flow of bytes is opposite, i.e. from main memory to device (display screen) then this process is called output.

All of these streams are defined inside the <iostream> header file which contains all the standard input and output tools of C++. The two instances cout and cin of iostream class are used very often for printing outputs and taking inputs respectively. These two are the most basic methods of taking input and printing output in C++.
Standard Output Stream – cout

The C++ cout is the instance of the ostream class used to produce output on the standard output device which is usually the display screen. The data needed to be displayed on the screen is inserted in the standard output stream (cout) using the insertion operator(<<).

Syntax

    cout << value/variable;

For example, if we want to print text “GeeksforGeeks” on the display, we can use the cout as shown:

#include <iostream>
using namespace std;

int main() {

      // Printing the given text using cout
    cout << "GeeksforGeeks";
    return 0;
}


Explanation: In the above program, cout is used to output the text “GeeksforGeeks” to the standard output stream. It works in conjunction with the insertion operator (<<) to send the specified data to the output stream.

We can also print the variable values using cout.

#include <iostream>
using namespace std;

int main() {
    int a = 22;
  
      // Printing variable 'a' using cout
    cout << a;
    return 0;
}


Output

22

Understanding input and output operations is essential for any C++ programmer. The C++ Course includes comprehensive lessons on basic I/O operations, ensuring you can manage user interaction in your programs.
Standard Input Stream – cin

The C++ cin statement is the instance of the class istream and is used to read input from the standard input device which is usually a keyboard. The extraction operator (>>) is used along with the object cin for extracting the data from the input stream and store it in some variable in the program.

Syntax

    cin >> variable;

For example, if we want to ask user for his/her age, then we can use cin as shown:
#include <iostream>
using namespace std;

int main() {
    int age;

      // Output a label
    cout << "Enter your age:";
  
      // Taking input from user and store
      // it in variable
    cin >> age;
  
      // Output the entered age
    cout << "Age entered: " << age;
    return 0;
}

Enter your age: 18 (18 entered by the user)

Output

Your age is: 18

Explanation: The above program asks the user to input the age. The object cin is connected to the input device (keyboard). The age entered by the user is extracted from cin using the extraction operator(>>) and the extracted data is then stored in the variable age present on the right side of the extraction operator.

    The type of input provided should be same as that of the variable being used to store it. Otherwise, it may lead to undefined error or input failure.

Also, while taking text as input using cin, we need to remember that cin stops reading input as soon as it encounters a whitespace (space, tab, or newline). This means it only captures the first word or characters until the first whitespace. It is shown in the below example:
#include <iostream>
using namespace std;

int main() {
    string name;

      // Output a label
    cout << "Enter your name:";
  
      // Taking input from user and store
      // it in variable
    cin >> name;
  
      // Output the entered age
    cout << "Name entered: " << age;
    return 0;
}


Input

Enter your name: Vishal Kumar (User entered Vishal Kumar)

Output

Name entered: Vishal

Un-buffered Standard Error Stream – cerr

The C++ cerr is the standard error stream that is used to output the errors. This is also an instance of the iostream class. As cerr in C++ is un-buffered so it is used when one needs to display the error message immediately. It does not have any buffer to store the error message and display it later.

The main difference between cerr and cout comes when you would like to redirect output using “cout” that gets redirected to file if you use “cerr” the error doesn’t get stored in file.(This is what un-buffered means ..It cant store the message)
#include <iostream>
using namespace std;

int main() {
    cerr << "An error occurred";
    return 0;
}

Buffered Standard Error Stream – clog

This is also an instance of ostream class and used to display errors but unlike cerr the error is first inserted into a buffer and is stored in the buffer until it is not fully filled. or the buffer is not explicitly flushed (using flush()). The error message will be displayed on the screen too.

#include <iostream>
using namespace std;

int main() {
    clog << "An error occurred";
    return 0;
}


i need reason why if enter two words in name it doesnt ask for age in input
ChatGPT said:

Good question! The reason your program doesn’t ask for age after entering a name with two words is due to how cin >> name; handles input.
What Happens in Your Code?

cin >> name;
cin >> x;

    cin >> name; only reads the first word before a space.
    If you enter "John Doe", only "John" is stored in name, and "Doe" remains in the input buffer.
    When cin >> x; runs, it tries to read an integer but sees "Doe", which is not a number.
    Since "Doe" cannot be converted to an integer, input fails and cin goes into an error state.
    Because of this error, cin >> x; does not execute, and the program skips further input.
    
    🚀 Understanding cerr (Unbuffered Standard Error Stream) in C++

You already know cout, which prints output to the console. Now, let's talk about cerr, which is used for error messages.
🔹 What is cerr?

✔ cerr stands for C++ Error Stream.
✔ It is unbuffered, meaning it immediately prints output without waiting.
✔ Used to display error messages instantly.
🔹 cerr vs. cout (The Key Difference)

The main difference is buffering:
Feature	cout (Buffered)	cerr (Unbuffered)
Buffering	Stores output in a buffer before printing	Prints immediately, no buffer
Speed	Slightly faster because of buffering	Slower due to immediate printing
Redirection (> to file)	Redirects output to a file normally	Doesn’t get redirected like cout
🔹 Example 1: cerr Prints Instantly

#include <iostream>
using namespace std;

int main() {
    cout << "This is normal output." << endl;
    cerr << "This is an error message!" << endl;
    return 0;
}

📌 Output on Console

This is normal output.
This is an error message!

✅ Notice that cerr prints immediately, while cout may wait.
🔹 Example 2: Redirecting Output to a File

If you run this program from a terminal and redirect output:

./a.out > output.txt

📌 What happens?

    cout output goes to output.txt (because it’s buffered).
    cerr still appears on the terminal (because it’s unbuffered and doesn’t get redirected).

✅ To redirect both cout and cerr to a file, use this:

./a.out > output.txt 2>&1

Here, 2>&1 means redirect stderr (cerr) to the same location as stdout (cout).
🔹 When to Use cerr?

✔ When you need immediate error messages (e.g., debugging, warnings, fatal errors).
✔ When errors should always appear on the terminal, even if output is redirected.
✔ When you don’t want errors to get mixed with normal output.

Would you like more examples or real-world scenarios? 😃


Buffered Standard Error Stream – clog

This is also an instance of ostream class and used to display errors but unlike cerr the error is first inserted into a buffer and is stored in the buffer until it is not fully filled. or the buffer is not explicitly flushed (using flush()). The error message will be displayed on the screen too.### 🚀 **Understanding `clog` (Buffered Standard Error Stream) in C++**  

In C++, we have **two** ways to print error messages:  
✔ `cerr` – **Unbuffered** (prints immediately)  
✔ `clog` – **Buffered** (stores errors in a buffer before printing)  

---

## **🔹 What is `clog`?**  
✔ `clog` stands for **C++ Log Stream** (used for logging messages).  
✔ It is **buffered**, meaning it **stores messages in memory first** and then prints them **all at once** when the buffer is full or manually flushed.  
✔ It is useful when **writing logs efficiently** without slowing down the program.

---

## **🔹 `clog` vs. `cerr` (The Key Difference)**  

| Feature   | `cerr` (Unbuffered) | `clog` (Buffered) |
|-----------|--------------------|-------------------|
| **Buffering** | Prints immediately, no buffer | Uses a buffer, prints later |
| **Performance** | Slower (prints each message instantly) | Faster (collects messages before printing) |
| **Use Case** | For urgent errors that must be seen immediately | For logging messages efficiently |

---

## **🔹 Example 1: `cerr` vs. `clog` Output**
```cpp
#include <iostream>
using namespace std;

int main() {
    cerr << "This is an error (cerr)!" << endl;
    clog << "This is a log message (clog)!" << endl;
    return 0;
}
```
📌 **What happens?**  
- `cerr` prints **immediately**.  
- `clog` **might** delay printing until the buffer is full.  

✅ To **force `clog` to print immediately**, you can use `.flush()`:  
```cpp
clog << "This is a log message!" << flush;
```

---

## **🔹 Example 2: `clog` Buffering in Action**
```cpp
#include <iostream>
using namespace std;

int main() {
    clog << "Logging some messages..." << endl;
    clog << "These messages are buffered." << endl;
    
    // Flushing the buffer
    clog.flush();  
    
    cout << "Normal output." << endl;
    return 0;
}
```
📌 **Output Order (May Vary)**
```
Normal output.
Logging some messages...
These messages are buffered.
```
✅ The **order might change** because `clog` messages stay in a buffer **until it’s full or explicitly flushed**.

---

## **🔹 When to Use `clog`?**
✔ **Logging messages** efficiently without slowing down performance.  
✔ **Writing to log files** instead of the console (useful for debugging large programs).  
✔ **When errors are not urgent** and don’t need to be seen immediately.  

Would you like a **real-world example** of `clog` in logging? 😃


cin in C++
Last Updated : 12 Dec, 2024

In C++, cin is an object of istream class that is used to accept the input from the standard input stream i.e. stdin which is by default associated with keyboard. The extraction operator (>>) is used along with cin to extract the data from the object and insert it to the given variable.

Let’s take a look at an example:

#include <iostream>
using namespace std;

int main() {
  
      // Variable to store data given by cin
    int a;

    // Take input using cin
    cin >> a;

    cout << a;
    return 0;
}


Input

10

Output

10

Syntax of cin

    cin >> var_name;

Here,

    >>: It is the extraction operator to extract data from cin.
    var_name: It is a variable that will store the input data provided by the user.

    Note: cin is initialized when the program starts to make sure it is ready for input operations. It is also linked to cout to ensure that any buffered output is flushed before cin reads from the input stream.

Understanding how to use cin for input is fundamental in C++. To master input handling in your programs, consider exploring the C++ Course, which provides detailed explanations and practical examples.
Examples of cin

The following examples demonstrate how to use cin in C++ programs:
Taking a Text from User Input
#include <iostream>
using namespace std;

int main() {
  
      // Variable to store data given by cin
    string s;

    // Take input using cin
    cin >> s;

    // Print output
    cout << s;
    return 0;
}

Welcome to GeeksforGeeks

Output

Welcome

Taking Multiple Inputs Using the Extraction Operator(>>) with cin

#include <iostream>
using namespace std;

int main() {
    string name;
    int age;

    // Take multiple input using cin
    cin >> name >> age;

    cout << "Name : " << name << endl;
    cout << "Age : " << age << endl;

    return 0;
}


ABC 13

Output

Name : ABC
Age : 13

cin Member Functions in C++

The below table lists some commonly used member functions of cin in C++:
Member Function	Description
cin.get()	Reads a single character from the input stream, including whitespace.
cin.getline()	Reads a line of text, including whitespace, and stops when it reaches a newline character.
cin.ignore()	Ignores a specified number of characters or until a specified delimiter is encountered.
cin.peek()	Returns the next character from the input stream without extracting it.
cin.putback()	Puts a character back into the input stream.
cin.eof()	Returns true if the end of the input stream has been reached.
cin.fail()	Returns true if an input operation has failed (e.g., when input doesn’t match the expected type).
cin.clear()	Clears the error flags on the input stream, allowing further operations.
cin.sync()	Discards unread characters from the input buffer.
cin.gcount()	Returns the number of characters extracted by the last unformatted input operation.
cin.rdbuf()	Gets or sets the associated stream buffer object for std::cin.
cin.get()

It reads an input character and stores it in a variable. Below is the C++ program to implement cin.get()
// C++ program to illustrate the use
// of cin.get()
#include <iostream>
using namespace std;

// Driver Code
int main()
{
    char ch[30];
    cin.get(ch, 25);

    // Print ch
    cout << ch;
}

Welcome to GFG

Output

Welcome to GFG

cin.getline()

It reads a stream of characters of given length N into the string buffer. It stops when it has read (N – 1) characters or it finds the end of the file or newline character(\n). Below is the C++ program to implement cin.getline():

// C++ program to illustrate the use of cin.getline
#include <iostream>
using namespace std;

int main() {
    char name[5];

    // Reads stream of 3 characters
    cin.getline(name, 3);

    // Print output
    cout << name << endl;

    return 0;
}


Geeks

Output

Ge

cin.read()

It reads a stream of characters of given length N. Below is the C++ program to implement cin.read():

// C++ program to illustrate the use of cin.read()
#include <iostream>
using namespace std;

int main() {
    char gfg[20];

    // Reads stream of characters
    cin.read(gfg, 10);

    // Print output
    cout << gfg << endl;

    return 0;
}


Welcome to GFG

Output

Welcome to

cin.ignore()
cin.ignore()

It ignores or clears one or more characters from the input buffer. Below is the C++ program to implement cin.ignore():

// C++ program to illustrate the use of cin.ignore()
#include <iostream>
#include <ios>
#include <limits>
using namespace std;

int main() {
    int x;
    char str[80];
    cout << "Enter a number and string:\n";
    cin >> x;

    // clear buffer before taking
    // new line
    cin.ignore(numeric_limits<streamsize>::max(), '\n');

    // Input a string
    cin.getline(str, 80);
    cout << "You have entered:\n";
    cout << x << endl;
    cout << str << endl;

    return 0;
}


Enter a number and string:
8
Welcome to GFG

Output

You have entered:
8
Welcome to GFG

Explanation: In the above program if cin.ignore() has not been used then after entering the number when the user presses the enter to input the string, the output will be only the number entered. The program will not take the string input. To avoid this problem cin.ignore() is used, this will ignore the newline character.

### 🚀 **Understanding `cin.get()` in C++**  

`cin.get()` is a function used for **reading input**, especially when dealing with **characters, whitespace, and newlines**. It gives more control over **how input is taken** compared to `cin >>` (which ignores whitespace).  

---

## **🔹 Why Use `cin.get()`?**
✔ Reads **single characters**, including spaces and newlines.  
✔ Useful when handling **strings with spaces** or **pausing execution**.  
✔ Can be used with **multiple overloads** (different ways to use it).  

---

## **🔹 `cin.get()` vs. `cin >>` (Key Difference)**  
| Feature         | `cin.get()`         | `cin >>` |
|----------------|-------------------|---------|
| **Reads**       | Single character (including spaces/newlines) | Single word (ignores spaces) |
| **Stops at**    | First newline or when full | First whitespace |
| **Best for**    | Reading characters, stopping at newlines | Reading words or numbers |

---

## **🔹 Example 1: Reading a Single Character**  
```cpp
#include <iostream>
using namespace std;

int main() {
    char ch;
    cout << "Enter a character: ";
    ch = cin.get();
    cout << "You entered: " << ch << endl;
    return 0;
}
```
📌 **Input**: `A`  
📌 **Output**: `You entered: A`  

✅ Unlike `cin >> ch;`, this also reads **whitespace characters** like `space` or `\n`.

---

## **🔹 Example 2: Reading a Full Line (Including Spaces)**  
```cpp
#include <iostream>
using namespace std;

int main() {
    char str[50];  
    cout << "Enter a sentence: ";
    cin.get(str, 50);  // Reads full line including spaces
    cout << "You entered: " << str << endl;
    return 0;
}
```
📌 **Input**: `Hello World!`  
📌 **Output**: `You entered: Hello World!`  

✅ `cin >> str;` would only take `Hello` and stop at the first space!  

---

## **🔹 Example 3: Using `cin.get()` to Pause the Program**
```cpp
#include <iostream>
using namespace std;

int main() {
    cout << "Press any key to continue...";
    cin.get();  // Waits for user to press Enter
    return 0;
}
```
📌 This is used to **pause** the program until the user presses Enter.

---

## **🔹 Example 4: Handling `\n` (Newline Issue)**
When you use `cin >>`, it **leaves a `\n` in the buffer**, which can cause problems with `cin.get()`.  
### ❌ **Problem**
```cpp
#include <iostream>
using namespace std;

int main() {
    int age;
    char name[50];

    cout << "Enter your age: ";
    cin >> age;  // Reads number but leaves '\n' in buffer

    cout << "Enter your name: ";
    cin.get(name, 50);  // This will NOT work correctly!

    cout << "You entered: " << name << endl;
    return 0;
}
```
📌 **Problem:** `cin.get()` sees the `\n` left in the buffer and **doesn’t wait for input!**  

### ✅ **Solution: Use `cin.ignore()`**
```cpp
cin.ignore();  // Clears leftover '\n' before calling cin.get()
cin.get(name, 50);
```

---

## **🔹 Summary**
✔ `cin.get()` reads **characters** (including spaces & newlines).  
✔ `cin.get(char[], size)` reads **full lines**, including spaces.  
✔ `cin.ignore()` clears **leftover `\n` from `cin >>`** before using `cin.get()`.  
✔ Used for **pausing execution** or handling **special input cases**.  

Would you like a real-world example where `cin.get()` is **essential**? 😃

🚀 Final Summary

✔ cin.get() → Reads one character at a time
✔ getline(cin, string_var) → Reads a full line into a string
✔ cin.get(char[], size) → Reads a full line into a char array

Want an example where getline() and cin >> cause issues together? 😃
dont use string data type with cin get use array ;


cout Member Functions in C++

Below is a list of some commonly used member functions of cout in C++:
Member Function	Description
cout.put(char)	Writes a single character to the output stream.
cout.write(char*, int)	Writes a block of characters from the array to the output stream.
cout.precision(int)	Sets the decimal precision for displaying floating-point numbers.
cout.setf(ios::fmtflags)	Sets the format flags for the stream.
cout.width(int)	Sets the minimum field width for the next output.
cout.fill(char)	Sets the fill character for padding the field.

Below is the implementation of the member functions of the cout.write() and cout.put():
#include <iostream>
using namespace std;

int main() {
    char s[] = "Welcome at GFG";
    char c = 'e';

    // Print first 6 characters
    cout.write(s, 6);

    // Print the character c
    cout.put(c);
  
    return 0;
}

Below is the C++ program to illustrate the use of cout.precision():

#include <iostream>
using namespace std;

int main() {
    double pi = 3.14159783;

    // Set precision to 5
    cout.precision(5);

    cout << pi << endl;

    // Set precision to 7
    cout.precision(7);

    cout << pi << endl;

    return 0;
}


Output

3.1416
3.141598


Manipulators in C++
Last Updated : 10 Jan, 2025

Manipulators are helping functions that can modify the input or output stream. They can be included in the I/O statement to alter the format parameters of a stream. They are defined inside <iomanip> and some are also defined inside <iostream> header file.

For example, if we want to print the hexadecimal value of 100 then we can print it as:

    cout << setbase(16) << 100

Types of Manipulators

There are various types of manipulators classified on the basis type of entity they manipulate:

Table of Content

    Output Stream Manipulators
    Input Stream Manipulators
    Boolean Manipulators
    Alignment and Sign Manipulators
    Base Manipulators

1. Output Stream Manipulators

Output stream manipulators are used to control and format the output stream, such as setting the width, precision, or alignment of printed data. They allow for a better presentation of output.

Following table lists some common output stream manipulators:
Manipulator	Description	Header File
endl	Inserts a newline and flushes the output stream.	iostream
flush	Flushes the output stream manually.	iostream
setw(x)	Sets the width of the next output field to x.	iomanip
setprecision(x)	Sets the precision for floating-point numbers to x.	iomanip
fixed	Displays numbers in fixed-point notation.	iomanip
scientific	Displays numbers in scientific notation.	iomanip
showpoint	Forces the display of the decimal point.	iomanip
noshowpoint	Hides the decimal point unless necessary.	iomanip
Example
C++

#include <iostream>
#include <iomanip>
using namespace std;

int main() {
  
    // Output a new line and flush the stream
    cout << "Hello" << endl;

    // Set width to 10 for the next output
    cout << setw(10) << 42 << endl;

    // Set precision to 3 for floating-point numbers
    cout << setprecision(3) << 3.14159 << endl;

    // Use fixed-point notation
    cout << fixed << 3.14159 << endl;

    // Use scientific notation
    cout << scientific << 3.14159 << endl;

    // Show the decimal point even for whole numbers
    cout << showpoint << 42.0;

    return 0;
}


Output

Hello
        42
3.14
3.142
3.142e+00
4.200e+01

2. Input Stream Manipulators

Input stream manipulators are used to modify the behaviour of the input stream. They help in processing input efficiently, such as skipping unnecessary whitespaces with ws.

Following table lists some common input stream manipulators:
Manipulator	Description	Header File
ws	Skips leading whitespaces in the input stream.	iostream
noskipws	Disables skipping of leading whitespaces.	iostream
Example
C++

#include <iostream>
using namespace std;

int main() {
    char c1, c2;

    // Input skips whitespace by default
    cin >> c1;  

    // Input the next character without skipping whitespace
    cin >> noskipws >> c2;  

    cout << "c1: " << c1 << ", c2: " << c2;
    return 0;
}


Input

    s    x

Output

c1: s, c2:  

3. Boolean Manipulators

Boolean manipulators are used to format boolean values in output. They allow displaying boolean values as true or false or as 1 and 0, depending on the requirement.

Following table lists some common boolean manipulators:
Manipulator	Description	Header File
boolalpha	Displays true or false for boolean values.	iostream
noboolalpha	Displays 1 or 0 for boolean values.	iostream
Example
C++

#include <iostream>
using namespace std;

int main() {
    bool value = true;

    // Display boolean as true/false
    cout << boolalpha << value << endl;

    // Display boolean as 1/0
    cout << noboolalpha << value;

    return 0;
}


Output

true
1

4. Alignment and Sign Manipulators

These manipulators control how text and numbers are aligned or how their signs are displayed in the output.

Following table lists some common alignment and sign manipulators:
Manipulator	Description	Header File
left	Aligns output to the left.	iomanip
right	Aligns output to the right.	iomanip
internal	Aligns signs and base prefixes to the left.	iomanip
showpos	Displays a + sign for positive numbers.	iostream
noshowpos	Hides the + sign for positive numbers.	iostream
Example
C++

#include <iostream>
#include <iomanip>
using namespace std;

int main() {
    int n = 42;

    // Align output to the left
    cout << left << setw(10) << n << endl;

    // Align output to the right
    cout << right << setw(10) << n << endl;

    // Show positive sign for numbers
    cout << showpos << n << endl;

    // Don't show positive sign for numbers
    cout << noshowpos << n;

    return 0;
}


Output

42        
        42
+42
42

5. Base Manipulators

Base manipulators are used to format numbers in different bases, such as decimal, hexadecimal, or octal. They help in representing numbers in a way suited to specific applications.

Following table lists some common base manipulators:
Manipulator	Description	Header File
hex	Formats output in hexadecimal base.	iostream
dec	Formats output in decimal base.	iostream
oct	Formats output in octal base.	iostream
Example
C++

#include <iostream>
using namespace std;

int main() {
    int n = 42;

    // Output in hexadecimal base
    cout << hex << n << endl;

    // Output in decimal base
    cout << dec << n << endl;

    // Output in octal base
    cout << oct << n;

    return 0;
}


Output

2a
42
52

C++ Manipulators – FAQs
What is the difference between endl and \n?

    endl inserts a newline and flushes the stream, while \n only inserts a newline without flushing the stream.

Can manipulators be used without arguments?

    Yes, manipulators like endl, flush, and hex do not require arguments, while others like setw(x) and setprecision(x) need arguments.

What happens if setw() is used with text shorter than the specified width?

    The text is aligned, and the remaining width is filled with spaces by default.




### **📌 `setprecision(x)` vs. `fixed` in C++ (`iomanip`)**  

Both `setprecision(x)` and `fixed` are used for **formatting floating-point numbers**, but they work **differently**. Here’s a clear breakdown:  

---

## **🔹 `setprecision(x)`**
📌 **Sets the total number of significant digits (not just decimals!)**  
📌 Works for both **fixed-point** and **scientific notation**  
📌 **Used with `#include <iomanip>`**  

### **Example 1: `setprecision(x)` (Default Behavior)**
```cpp
#include <iostream>
#include <iomanip>
using namespace std;

int main() {
    double num = 123.456789;

    cout << setprecision(5) << num << endl;
    cout << setprecision(3) << num << endl;  // Only 3 significant digits!

    return 0;
}
```
📌 **Output:**  
```
123.46
123
```
✔ **It counts total significant digits, not just decimal places!**  
✔ In the second case, `setprecision(3)` **rounds it to `123`** because it counts **total digits**, not just decimals.

---

## **🔹 `fixed`**
📌 **Forces `setprecision(x)` to apply only to decimal places**  
📌 Without `fixed`, `setprecision(x)` affects **total digits**  
📌 **Used with `#include <iomanip>`**  

### **Example 2: `fixed` + `setprecision(x)`**
```cpp
#include <iostream>
#include <iomanip>
using namespace std;

int main() {
    double num = 123.456789;

    cout << fixed << setprecision(5) << num << endl;
    cout << fixed << setprecision(3) << num << endl;  // 3 decimal places!

    return 0;
}
```
📌 **Output:**  
```
123.45679
123.457
```
✔ `fixed` makes `setprecision(x)` **only affect decimal places**, not total digits.  
✔ `setprecision(3)` now **keeps 3 decimal places (`.457`)**, instead of limiting significant digits.

---

## **🔹 Key Difference**
| Feature            | `setprecision(x)` (without `fixed`) | `fixed` + `setprecision(x)` |
|--------------------|---------------------------------|---------------------------|
| Affects           | **Total significant digits**    | **Decimal places only**    |
| Works with        | **Both scientific and normal notation** | **Fixed-point notation only** |
| Example (`123.456789`) | `setprecision(5) → 123.46`  | `setprecision(5) → 123.45679` |
| Example (`setprecision(3)`) | `123` (rounds total digits) | `123.457` (3 decimal places) |

---

## **🔹 Summary**
✔ **Use `setprecision(x)` alone for total significant digits.**  
✔ **Use `fixed` with `setprecision(x)` for decimal places.**  
✔ **If you need scientific notation, use `scientific` instead of `fixed`.**  

Would you like a comparison with `scientific` formatting as well? 🚀 


3. Boolean Manipulators

Boolean manipulators are used to format boolean values in output. They allow displaying boolean values as true or false or as 1 and 0, depending on the requirement.

Following table lists some common boolean manipulators:
Manipulator	Description	Header File
boolalpha	Displays true or false for boolean values.	iostream
noboolalpha	Displays 1 or 0 for boolean values.	iostream
Example

#include <iostream>
using namespace std;

int main() {
    bool value = true;

    // Display boolean as true/false
    cout << boolalpha << value << endl;

    // Display boolean as 1/0
    cout << noboolalpha << value;

    return 0;
}


Output

true
1
Decision Making in C++


C++ if Statement
Last Updated : 12 Dec, 2024

The C++ if statement is the most simple decision-making statement. It is used to decide whether a certain statement or block of statements will be executed or not executed based on a certain condition. Let’s take a look at an example: 
#include <iostream> 
using namespace std; 
  
int main()  { 
    int i = 10; 
  
      // If statement
    if (i < 15) { 
        cout << "10 is less than 15"; 
    } 
  
    return 0;
} 


C++ if else Statement
Last Updated : 12 Dec, 2024

The if statement alone tells us that if a condition is true it will execute a block of statements and if the condition is false, it won’t. But what if we want to do something else if the condition is false. Here comes the C++ if else statement. We can use the else statement with if statement to execute a block of code when the condition is false.
#include <iostream> 
using namespace std; 
  
int main()  { 
    int i = 10; 
  
    // If statement
    if (i < 15) { 
        cout << "10 is less than 15"; 
    }
  
      // Else statement with the above if
      else {
          cout << "10 is not less than 15";
    }
  
    return 0;
}


C++ if else if Ladder
Last Updated : 02 Jan, 2025

In C++, the if-else-if ladder helps the user decide from among multiple options. The C++ if statements are executed from the top down. As soon as one of the conditions controlling the if is true, the statement associated with that if is executed, and the rest of the C++ else-if ladder is bypassed. If none of the conditions is true, then the final statement will be executed.

#include <iostream> 
using namespace std; 
  
int main()  { 
    int i = 20;
  
    // If - else ladder
    if (i == 10) 
        cout << "i is 10"; 
    else if (i == 15) 
        cout << "i is 15"; 
    else if (i == 20) 
        cout << "i is 20"; 
    else
        cout << "i is not present"; 
  
    return 0; 
} 


C++ Nested if-else Statement
Last Updated : 12 Dec, 2024

Nested if-else statements are those statements in which there is an if statement inside another if else. We use nested if-else statements when we want to implement multilayer conditions (condition inside the condition inside the condition and so on). C++ allows any number of nesting levels.
#include <iostream>
using namespace std;

int main() {
      int n = 6;
      
      // Outer if statement
      if (n % 2 == 0) {
      
          // Inner if statement
          if (n % 3 == 0) {
              cout << "Divisible by 2 and 3";
        }
          else {
              cout << "Divisible by 2 but not 3";
        }
      }
      else {
          cout << "Not Divisible by 2";
    }

    return 0;
}
Switch Statement in C++
In C++, the switch statement is a flow control statement that is used to execute the different blocks of statements based on the value of the given expression. It is an alternative to the long if-else-if ladder which provides an easy way to execute different parts of code based on the value of the expression. 
#include <iostream>
using namespace std;

int main() {
      
    // Variable to the used as switch expression
    char x = 'A';

    // Switch statement with three cases
    switch (x) {
    case 'A':
        cout << "A";
        break;
    case 'B':
        cout << "B";
        break;
    default:
        cout << "Other than A and B";
        break;
    }
    return 0;
}

A

Explanation: In the above program, the switch statement evaluates the value of x and executes the matching case. If x is ‘A’, it prints “A”; if ‘B’, it prints “B”. The default case handles other values.
Syntax of switch Statement in C++

    switch (expression) {
        case value_1:
            // statements_break.
            break;
        case value_2:
            // statements_2;
            break;
        …..
        …..
        default:
            // default_statements;
            break;
    }


Here,

    The default case is executed if none of the cases are matched.
    The break keyword in each case is used to break out of the switch statement after the matching case is found. Otherwise, all the statements after the matching case will be executed.

Rules of the switch Statement in C++

There are some rules that we need to follow when using switch statements in C++. They are as follows:

    The case value must be either int or char type.
    There can be any number of cases.
    No duplicate case values are allowed.
    Each statement of the case can have a break statement. It is optional.
    The default Statement is also optional.
    
    Working of switch Statement in C++

The working of the switch statement in C is as follows:

    Step 1: The switch expression is evaluated.
    Step 2: The evaluated value is then matched against the present case values.
    Step 3A: If the matching case value is found, that case block is executed.
    Step 3B: If the matching code is not found, then the default case block is executed if present.
    Step 4A: If the break keyword is present in the block, then program control comes out of the switch statement.
    Step 4B: If the break keyword is not present, then all the cases after the matching case are executed.
    Step 5: Statements after the switch statement is executed.
    
    Important Points About switch Statement
1. Switch expression should result in a constant value

If the expression provided in the switch statement does not result in a constant value, it would not be valid. Some valid expressions for switch case will be,

// Constant expressions allowed
switch(1 + 2 + 23);
switch(1 * 2 + 3 % 4);
 
// Variable expression are allowed provided
// they are assigned with fixed values
switch(a * b + c * d);
switch(a + b + c);


2. Expression must evaluate only int or char type values.

The switch statement can only evaluate the integer or character value. So, the switch expression should return the values of type int or char only.
3. Break in switch case

The break keyword is used in the switch case to break out of the switch when encountered. It is used at the end of every case block so that when the matching case is executed, the program control comes out of the loop.

The break statement is optional. If omitted, all the cases after the matching case will also be executed.
4. Default in switch case

The default keyword is used to define a default case which will be executed when no case value is matched. It is also an optional statement, and the switch case statement runs without problem if it is omitted.
5. No duplicate Case Values

In the C switch statement, duplicate case values are not allowed. All the case values must be unique.
6. Nested Switch Statements

In C++, we can nest one switch inside another switch statement without any problem. Though it is avoided most of the time as it makes the program more complex and unreadable.
7. Position of Default Case Does Not Matters

Regardless of its placement, the default case only gets executed if none of the other case conditions are met. So, putting it at the beginning, middle, or end doesn’t change the core logic (unless you’re using a less common technique called fall-through).
8. Differences between switch and if else if ladder in C?

Following are the main differences between switch and if else if ladder in C++:

switch
	

if else if
It executes the different cases on the basis of the value of the switch variable.	It executes the different blocks based on the condition specified.
It can only evaluate the int or char type expressions.	It can evaluate any type of expression.
Faster and easier to read for a large number of conditions.	It can get messy when there are lots of conditions.

continue Statement

The C++ continue statement is used to execute other parts of the loop while skipping some parts declared inside the condition, rather than terminating the loop, it continues to execute the next iteration of the same loop. It is used with a decision-making statement which must be present inside the loop.

This statement can be used inside for loop or while or do-while loop. Let’s take a look at an example:
#include <iostream>
using namespace std;

int main() {
    for (int i = 1; i < 10; i++) {

          // Skip the execution for i = 5
        if (i == 5)
            continue;
        cout << i << " ";
    }
    return 0;
}

break Statement

The C++ break statement is used to terminate the whole loop if the condition is met. It is used with decision-making statements such as if, if-else, or switch statement to break out of the block. It forces the loop to stop the execution of the further iteration.
#include <iostream>
using namespace std;

int main() {
  
      // Loop to print digits from 1 to 4
    for (int i = 1; i < 10; i++) {

        // Breaking Condition
        if (i == 5)
            break;
        cout << i << " ";
    }
  
    return 0;
}

return Statement

The return statement takes control out of the function itself. It is stronger than a break. It is used to terminate the entire function after the execution of the function or after some condition. Every function has a return statement with some returning value except the void() function. Although void() function can also have the return statement to end the execution of the function.
#include <iostream>
using namespace std;

void findNum (int n) {
      for (int i = 0; i <= 100; i++) {
          if (i == n) {
              cout << "Number in Range [0, 100]";
              
              // This will stop the function here
              return;
        }
    }
      cout << "Number not in Range [0, 100]";
      
      // Final return if the above one is not reached.
      return;
}

int main() {
    int n = 10;

      // Caaling the function
    findNum(n);

    return 0;
}

goto Statement

The C++ goto statement is used to jump directly to that part of the program to which it is being called.  Every goto statement is associated with the label which takes them to part of the program for which they are called. The label statements can be written anywhere in the program it is not necessary to use them before or after the goto statement.

Let’s take a look at an example:
#include <iostream>
using namespace std;

int main() {
    int n = 4;

    if (n % 2 == 0) {
      
          // Skipping to label1
        goto label1;
    }
    else {
      
          // Skipping to label2
        goto label2;
    }

label1:
    cout << "Even" << endl;
    return 0;

label2:
    cout << "Odd" << endl;
    return 0;
label3:
    cout << "Unspecified";
    return 0;
}


for Loop in C++
Last Updated : 12 Dec, 2024

In C++, for loop is an entry-controlled loop that is used to execute a block of code repeatedly for the given number of times. It is generally preferred over while and do-while loops in case the number of iterations is known beforehand.

Let’s take a look at an example:
#include <bits/stdc++.h>
using namespace std;

int main() {

      // for loop to print "Hi" 5 times
    for (int i = 5; i < 10; i++) {
          cout << "Hi" << endl;
    }
  
    return 0;
}
Hi
Hi
Hi
Hi
Hi

Syntax of for Loop

The syntax of for loop in C++ is shown below:

    for ( initialization; test condition; updation) { 
         // body of for loop
    }

The various parts of the for loop are:

    Initialization: Initialize the loop variable to some initial value.
    Test Condition: This specifies the test condition. If the condition evaluates to true, then body of the loop is executed, and loop variable is updated according to update expression. If evaluated false, loop is terminated.
    Update Expression: After executing the loop body, this expression increments/decrements the loop variable by some value.
    
    Note: The loop variable can also be declared in the initialization section but the scope of the loop variables that are declared in the initialization section is limited to the for loop block.
    
    Working of a for Loop in C++

The flowchart works as shown below:

    Control falls into the for loop. Initialization is done.
    The flow jumps to Condition.
    Condition is tested.
        If the Condition yields true, the flow goes into the Body.
        If the Condition yields false, the flow goes outside the loop.
    The statements inside the body of the loop get executed.
    The flow goes to the update.
    Updating takes place and the flow goes to Step 3 again.
    The for loop has ended and the flow has gone outside.
    

C++ While Loop
Last Updated : 12 Dec, 2024

In C++, the while loop is an entry-controlled loop that repeatedly executes a block of code as long as the given condition remains true. Unlike the for loop, while loop is used in situations where we do not know the exact number of iterations of the loop beforehand as the loop execution is terminated on the basis of the test condition.

Let’s take a look at an example:
#include <iostream>
using namespace std;

int main() {
  
      // while loop to print numbers from 1 to 5
    int i = 0;
    while (i < 5) {
        cout << "Hi" << endl;
        i++;
    }

    return 0;
}
Hi
Hi
Hi
Hi
Hi

Explanation: The above loop prints the text “Hi” till the given condition is true i.e. i is less than 5. In each execution of the loop’s statement, it increments i till i is less than 5.
Syntax of while Loop

    while (condition) {
        // Body of the loop
        update expression
    }

Though the above is the formal syntax of the while loop, we need to declare the loop variable beforehand and update it in the body of the loop. The various parts of the While loop are:

    Condition: The loop executes its body till this condition remains true.
    Update Expression: Update the value of loop variable to make it closer to the termination condition.
    Body: It is a group of statement that will be executed till the condition remains true.
    Working of while Loop
    The working of the while loop can be understood using the above image:

    Control falls into the while loop.
    The flow jumps to Condition
    Condition is tested.
        If the Condition yields true, the flow goes into the Body.
        If the Condition yields false, the flow goes outside the loop
    The statements inside the body of the loop get executed.
    Updation takes place.
    Control flows back to Step 2.
    The while loop has ended, and the flow has gone outside.
    
C++ do while Loop
Last Updated : 12 Dec, 2024

In C++, the do-while loop is an exit-controlled loop that repeatedly executes a block of code at least once and continues executing as long as a given condition remains true. Unlike the while loop, the do-while loop guarantees that the loop body will execute at least once, regardless of whether the condition is true or false.
Syntax of do-while Loop

    do {
        // Body of the loop
        // Update expression
    } while (condition);

We have to define the loop variable beforehand and update it manually in the body of the loop. Notice the semicolon (“;”) in the end of loop. It is compulsory to terminate the do while loop after the semicolon.

The various parts of the do-while loop are: 

    Condition: The condition is checked after the loop body executes. If the condition evaluates to true, the loop continues. If false, the loop exits.
    Update Expression: Update the loop variable bringing it closer to termination condition.
    Body: Body: It is a group of statement that will be executed surely for the first time and then till the condition remains true.
    Working of do while Loop in C++

Let’s understand the working of the do while loop using the given image:

    Control falls into the do-while loop.
    The statements inside the body of the loop get executed.
    Updation takes place.
    The flow jumps to Condition
    Condition is tested. 
        If the Condition yields true, go to Step 6.
        If the Condition yields false, the flow goes outside the loop
    The flow goes back to Step 2.
    The do-while loop has been ended and flow has gone outside the loop.
    


Range-Based for Loop in C++
Last Updated : 11 Jan, 2025

In C++, the range-based for loop introduced in C++ 11 is a version of for loop that is able to iterate over a range. This range can be anything that is iteratable, such as arrays, strings and STL containers. It provides a more readable and concise syntax compared to traditional for loops.
#include <bits/stdc++.h>
using namespace std;

int main() {
    vector<int> v = {1, 2, 3, 4, 5};

    // Iterating through vector
    for (int i : v) {
        cout << i << " ";
    }
  
    return 0;
}
1 2 3 4 5 

Explanation: In this program, the vector is iterated using range based for loop. As we can see, we don’t need to pass any size information or any iterator to iterate the vector. We just use the name of the vector.

Syntax of Range Based for Loop

    for (declaration: range) {
        // statements
    }

where,

    declaration: Declaration of the variable that will be used to represent each element of the rage.
    range: Name of the range.

The range-based for loop simplifies iteration over containers in C++.
Examples of Range Based for Loop

The below example demonstrates the use of range based for loop in our C++ programs:
Iterate over an Array using Range Based for Loop

Iterate over a Map using Range Based for Loop do map first


Each element of the map is a pair of the same type as that of a map. We have to specify that in declaration, or we can use auto keyword.
#include <bits/stdc++.h>
using namespace std;

int main() {
    map<int, char> m = {{1, 'A'}, {2, 'B'}, {3, 'C'},
                  {4, 'D'}, {5, 'E'}};
      
      // Range based for loop to iterate over array
      // and i is used to represent each element 
    for (auto p: m) {
        cout << p.first << ": " << p.second << endl;
    }

    return 0;
}
 
C++ Arrays

In C++, an array is a data structure that is used to store multiple values of similar data types in a contiguous memory location.

For example, if we have to store the marks of 4 or 5 students then we can easily store them by creating 5 different variables but what if we want to store marks of 100 students or say 500 students then it becomes very challenging to create that numbers of variable and manage them. Now, arrays come into the picture that can do it easily by just creating an array of the required size.
Properties of Arrays in C++

    An Array is a collection of data of the same data type, stored at a contiguous memory location.
    Indexing of an array starts from 0. It means the first element is stored at the 0th index, the second at 1st, and so on.
    Elements of an array can be accessed using their indices.
    Once an array is declared its size remains constant throughout the program.
    An array can have multiple dimensions.
    The size of the array in bytes can be determined by the sizeof operator using which we can also find the number of elements in the array.
    We can find the size of the type of elements stored in an array by subtracting adjacent addresses.

Array Declaration in C++

In C++, we can declare an array by simply specifying the data type first and then the name of an array with its size.
data_type array_name[Size_of_array];

Example

int arr[5];

Here,

    int: It is the type of data to be stored in the array. We can also use other data types such as char, float, and double.
    arr: It is the name of the array.
    5: It is the size of the array which means only 5 elements can be stored in the array.
    Initialization of Array in C++

In C++, we can initialize an array in many ways but we will discuss some most common ways to initialize an array. We can initialize an array at the time of declaration or after declaration.
1. Initialize Array with Values in C++

We have initialized the array with values. The values enclosed in curly braces ‘{}’ are assigned to the array. Here, 1 is stored in arr[0], 2 in arr[1], and so on. Here the size of the array is 5.
int arr[5] = {1, 2, 3, 4, 5};
2. Initialize Array with Values and without Size in C++

We have initialized the array with values but we have not declared the length of the array, therefore, the length of an array is equal to the number of elements inside curly braces.
int arr[] = {1, 2, 3, 4, 5};

3. Initialize Array after Declaration (Using Loops)

We have initialized the array using a loop after declaring the array. This method is generally used when we want to take input from the user or we cant to assign elements one by one to each index of the array. We can modify the loop conditions or change the initialization values according to requirements.

for (int i = 0; i < N; i++) {
    arr[i] = value;
}

4. Initialize an array partially in C++

Here, we have declared an array ‘partialArray’ with size ‘5’ and with values ‘1’ and ‘2’ only. So, these values are stored at the first two indices, and at the rest of the indices ‘0’ is stored.

int partialArray[5] = {1, 2};

5. Initialize the array with zero in C++

We can initialize the array with all elements as ‘0’ by specifying ‘0’ inside the curly braces. This will happen in case of zero only if we try to initialize the array with a different value say ‘2’ using this method then ‘2’ is stored at the 0th index only.
5. Initialize the array with zero in C++

We can initialize the array with all elements as ‘0’ by specifying ‘0’ inside the curly braces. This will happen in case of zero only if we try to initialize the array with a different value say ‘2’ using this method then ‘2’ is stored at the 0th index only.

int zero_array[5] = {0};
Accessing an Element of an Array in C++

Elements of an array can be accessed by specifying the name of the array, then the index of the element enclosed in the array subscript operator []. For example, arr[i].
//  C++ Program to Illustrate How to Access Array Elements
#include <iostream>
using namespace std;

int main()
{

    int arr[3];

    // Inserting elements in an array
    arr[0] = 10;
    arr[1] = 20;
    arr[2] = 30;

    // Accessing and printing elements of the array
    cout << "arr[0]: " << arr[0] << endl;
    cout << "arr[1]: " << arr[1] << endl;
    cout << "arr[2]: " << arr[2] << endl;

    return 0;
}

arr[0]: 10
arr[1]: 20
arr[2]: 30

Update Array Element

To update an element in an array, we can use the index which we want to update enclosed within the array subscript operator and assign the new value.
arr[i] = new_value;
Traverse an Array in C++

We can traverse over the array with the help of a loop using indexing in C++. First, we have initialized an array ‘table_of_two’ with a multiple of 2. After that, we run a for loop from 0 to 9 because in an array indexing starts from zero. Therefore, using the indices we print all values stored in an array.
Example 2: The C++ Program to Illustrate How to Traverse an Array
// C++ Program to Illustrate How to Traverse an Array
#include <iostream>
using namespace std;

int main()
{

    // Initialize the array
    int table_of_two[10]
        = { 2, 4, 6, 8, 10, 12, 14, 16, 18, 20 };

    // Traverse the array using for loop
    for (int i = 0; i < 10; i++) {
        // Print the array elements using indexing
        cout << table_of_two[i] << " ";
    }

    return 0;
}

2 4 6 8 10 12 14 16 18 20 

Size of an Array in C++

In C++, we do not have the length function as in Java to find array size but we can calculate the size of an array using sizeof() operator trick. First, we find the size occupied by the whole array in the memory and then divide it by the size of the type of element stored in the array. This will give us the number of elements stored in the array.
data_type size = sizeof(Array_name) / sizeof(Array_name[index]);
// C++ Program to Illustrate How to Find the Size of an
// Array
#include <iostream>
using namespace std;

int main()
{
    int arr[] = { 1, 2, 3, 4, 5 };

    // Size of one element of an array
    cout << "Size of arr[0]: " << sizeof(arr[0]) << endl;

    // Size of array 'arr'
    cout << "Size of arr: " << sizeof(arr) << endl;

    // Length of an array
    int n = sizeof(arr) / sizeof(arr[0]);

    cout << "Length of an array: " << n << endl;

    return 0;
    Size of arr[0]: 4
Size of arr: 20
Length of an array: 5
Relation between Arrays and Pointers in C++

In C++, arrays and pointers are closely related to each other. The array name is treated as a pointer that stored the memory address of the first element of the array. As we have discussed earlier, In array elements are stored at contiguous memory locations that’s why we can access all the elements of an array using the array name.
Example 4: Illustrating the Relationship between Array and Pointers
// C++ Program to Illustrate that Array Name is a Pointer
// that Points to First Element of the Array
#include <iostream>
using namespace std;

int main()
{
    // Defining an array
    int arr[] = { 1, 2, 3, 4 };

    // Define a pointer
    int* ptr = arr;

    // Printing address of the arrary using array name
    cout << "Memory address of arr: " << &arr << endl;

    // Printing address of the array using ptr
    cout << "Memory address of arr: " << ptr << endl;

    return 0;
}
Memory address of arr: 0x7fff2f2cabb0
Memory address of arr: 0x7fff2f2cabb0

Explanation:

In the above code, we first define an array “arr” and then declare a pointer “ptr” and assign the array “arr” to it. We are able to assign arr to ptr because arr is also a pointer. After that, we print the memory address of arr using reference operator (&) and also print the address stored in pointer ptr and we can see arr and ptr, both stores the same memory address. But &arr is gives the memory address of the entire array arr and arr(ptr) gives the address of the first element of array.
Example 5: Printing Array Elements without Indexing in C++

We generally access and print the array elements using indexing. For example to access the first element we use array_name[0]. We have discussed above that the array name is a pointer that stored the address of the first element and array elements are stored at contiguous locations. Now, we are going to access the elements of an array using the array name only.
// C++ Program to Print Array Elements without Indexing
#include <iostream>
using namespace std;

int main()
{

    // Define an array
    int arr[] = { 11, 22, 33, 44 };

    // Print elements of an array
    cout << "first element: " << *arr << endl;
    cout << "Second element: " << *(arr + 1) << endl;
    cout << "Third element: " << *(arr + 2) << endl;
    cout << "fourth element: " << *(arr + 3) << endl;

    return 0;
}

Explanation

In the above code, we first declared an array “arr” with four elements. After that, we are printing the array elements. Let’s discuss how we do it. We discussed that the array name is a pointer that stores the address of the first element of an array so, to print the first element we have dereferenced that pointer (*arr) using dereferencing operator (*) which prints the data stored at that address.

To print the second element of an array we first add 1 to arr which is equivalent to (address of arr + size_of_one_element *1) that takes the pointer to the address just after the first one and after that, we dereference that pointer to print the second element. Similarly, we print rest of the elements of an array without using indexing.

Passing Array to Function in C++

To use arrays efficiently we should know how to pass arrays to function. We can pass arrays to functions as an argument same as we pass variables to functions but we know that the array name is treated as a pointer using this concept we can pass the array to functions as an argument and then access all elements of that array using pointer.

So ultimately, arrays are always passed as pointers to the function. Let’s see 3 ways to pass an array to a function that are majorly used.
1. Passing Array as a Pointer

In this method, we simply pass the array name in function call which means we pass the address to the first element of the array. In this method, we can modify the array elements within the function
Syntax

return_type function_name ( data_type *array_name ) {
        // set of statements
}
2. Passing Array as an Unsized Array

In this method, the function accepts the array using a simple array declaration with no size as an argument.

Syntax

return_type function_name ( data_type array_name[] ) {
        // set of statements
}

3. Passing Array as a Sized Array
In this method, the function accepts the array using a simple array declaration with size as an argument. We use this method by sizing an array just to indicate the size of an array.

Syntax

return_type function_name(data_type array_name[size_of_array]){
        // set of statements
}

    Note: Array will be treated as a pointer in the passed function no matter what method we use. As the array are passed as pointers, they will loose the information about its size leading to a phenomenon named as Array Decay.

#include <iostream>
using namespace std;

// passing array as a sized array argument
void printArraySized(int arr[3], int n)
{
    cout << "Array as Sized Array Argument: ";
    for (int i = 0; i < n; i++) {
        cout << arr[i] << " ";
    }
    cout << endl;
}

// passing array as an unsized array argument
void printArrayUnsized(int arr[], int n)
{
    cout << "Array as Unsized Array Argument: ";
    for (int i = 0; i < n; i++) {
        cout << *(arr + i) << " ";
    }
    cout << endl;
}

// Passing array as a pointer argument
void printArrayPointer(int* ptr, int n)
{
    // Print array elements using pointer ptr
    // that store the address of array passed
    cout << "Array as Pointer Argument: ";
    for (int i = 0; i < n; i++) {
        cout << ptr[i] << " ";
    }
}

// driver code
int main()
{

    int arr[] = { 10, 20, 30 };

    // Call function printArray and pass
    // array and its size to it.
    printArraySized(arr, 3);
    printArrayUnsized(arr, 3);
    printArrayPointer(arr, 3);

    return 0;
}

Array as Sized Array Argument: 10 20 30 
Array as Unsized Array Argument: 10 20 30 
Array as Pointer Argument: 10 20 30 

Multidimensional Arrays in C++

Arrays declared with more than one dimension are called multidimensional arrays. The most widely used multidimensional arrays are 2D arrays and 3D arrays. These arrays are generally represented in the form of rows and columns.

Multidimensional Array Declaration

Data_Type Array_Name[Size1][Size2]...[SizeN];

where,

    Data_Type: Type of data to be stored in the array.
    Array_Name: Name of the array.
    Size1, Size2,…, SizeN: Size of each dimension.

Two Dimensional Array in C++

In C++, a two-dimensional array is a grouping of elements arranged in rows and columns. Each element is accessed using two indices: one for the row and one for the column, which makes it easy to visualize as a table or grid.
Syntax of 2D array

data_Type array_name[n][m];

Where,

    n: Number of rows.
    m: Number of columns.
    two dimensional array in c++

Example: The C++ Program to Illustrate the Two-Dimensional Array
// c++ program to illustrate the two dimensional array
#include <iostream>
using namespace std;

int main()
{
    // Declaring 2D array
    int arr[4][4];

    // Initialize 2D array using loop
    for (int i = 0; i < 4; i++) {
        for (int j = 0; j < 4; j++) {
            arr[i][j] = i + j;
        }
    }

    // Printing the element of 2D array
    for (int i = 0; i < 4; i++) {
        for (int j = 0; j < 4; j++) {
            cout << arr[i][j] << " ";
        }
        cout << endl;
    }

    return 0;
}
Three-Dimensional Array in C++

The 3D array uses three dimensions. A collection of various two-dimensional arrays piled on top of one another can be used to represent it. Three indices—the row index, column index, and depth index are used to uniquely identify each element in a 3D array.

Declaration of Three-Dimensional Array in C++

To declare a 3D array in C++, we need to specify its third dimension along with 2D dimensions.

Data_Type Array_Name[D][R][C];

Where,

    Data_Type: Type of data to be stored in each element.
    Array_Name: Name of the array
    D: Number of 2D arrays or Depth of array.
    R: Number of rows in each 2D array.
    C: Number of columns in each 2D array.

Example

int array[3][3][3];

three dimensional array in c++
Example: The C++ Program to Illustrate the 3d Array

// C++ program to illustrate the 3d array
#include <iostream>
using namespace std;

int main()
{

    // declaring 3d array
    int arr[3][3][3];
    // initializing the array
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++) {
            for (int k = 0; k < 3; k++) {
                arr[i][j][k] = i + j + k;
            }
        }
    }

    // printing the array
    for (int i = 0; i < 3; i++) {
        cout << i << "st layer:" << endl;
        for (int j = 0; j < 3; j++) {
            for (int k = 0; k < 3; k++) {
                cout << arr[i][j][k] << " ";
            }
            cout << endl;
        }
        cout << endl;
    }

       return 0;
}


Output

0st layer:
0 1 2 
1 2 3 
2 3 4 

1st layer:
1 2 3 
2 3 4 
3 4 5 

2st layer:
2 3 4 
3 4 5 
4 5 6 

Explanation

In the above code, we have declared a 3D array and then initialized it using three nested for loops. After that, we printed all layers of the 3D array again using three nested for loops as seen in the output.

Variable Length Arrays (VLAs) in C
In C, variable length arrays (VLAs) are also known as runtime-sized or variable-sized arrays. The size of such arrays is defined at run-time.

Variably modified types include variable-length arrays and pointers to variable-length arrays. Variably changed types must be declared at either block scope or function prototype scope.

Variable length arrays are a feature where we can allocate an auto array (on stack) of variable size. It can be used in a typedef statement. C supports variable-sized arrays from the C99 standard. For example, the below program compiles and runs fine in C.

// C program to demonstrate variable length array
#include <stdio.h>

// function to initialize array
void initialize(int* arr, int size)
{
    for (int i = 0; i < size; i++) {
        arr[i] = i + 1;
    }
}

// function to print an array
void printArray(int size)
{
    // variable length array
    int arr[size];
    initialize(arr, size);

    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
}

// driver code
int main()
{
    int n;
    printf("Enter the Size: ");
    scanf("%d", &n);
    printArray(n);

    return 0;
}
Enter the Size: 5
1 2 3 4 5 

Explanation: The above program illustrate how to create a variable size array in a function in C program. This size is passed as parameter and the variable array is created on the stack memory.


How to print size of array parameter in C++?

// A C++ program to show that it is wrong to
// compute size of an array parameter in a function
#include <iostream>
using namespace std;

void findSize(int arr[]) 
{ 
cout << sizeof(arr) << endl; 
}

int main()
{
	int a[10];
	cout << sizeof(a) << " ";
	findSize(a);
	return 0;
}

40 8

Time Complexity: O(1)  
Auxiliary Space: O(n) where n is the size of the array.

The above output is for a machine where the size of an integer is 4 bytes and the size of a pointer is 8 bytes.
The cout statement inside main() prints 40, and cout in findSize() prints 8. The reason for different outputs is that the arrays always pass pointers in functions. Therefore, findSize(int arr[]) and findSize(int *arr) mean exact same thing. Therefore the cout statement inside findSize() prints the size of a pointer.

For details, refer to the following articles:

    Do Not Use sizeof For Array Parameters in C
    Why Does C Treat Array Parameters as Pointers?

How to find the size of an array in function?

We can pass a ‘reference to the array’.

// A C++ program to show that we can use reference to
// find size of array
#include <iostream>
using namespace std;

void findSize(int (&arr)[10])
{
	cout << sizeof(arr) << endl;
}

int main()
{
	int a[10];
	cout << sizeof(a) << " ";
	findSize(a);
	return 0;
}

40 40

Time Complexity: O(1)
Space Complexity: O(n) where n is the size of the array.

The above program isn’t appealing as we have used the hardcoded size of the array parameter. 
We can do it better using templates in C++

We can use templates to define the function instead of using the hardcoded size.


// A C++ program to show that we use template and
// reference to find size of integer array parameter
#include <iostream>
using namespace std;

template <size_t n>
void findSize(int (&arr)[n])
{
	cout << sizeof(int) * n << endl;
}

int main()
{
	int a[10];
	cout << sizeof(a) << " ";
	findSize(a);
	return 0;
}

40 40

Time Complexity: O(1)
Space Complexity: O(n) where n is the size of the array.
We can make a generic function as well

// A C++ program to show that we use template and
// reference to find size of any type array parameter
#include <iostream>
using namespace std;

template <typename T, size_t n>
void findSize(T (&arr)[n])
{
	cout << sizeof(T) * n << endl;
}

int main()
{
	int a[10];
	cout << sizeof(a) << " ";
	findSize(a);

	float f[20];
	cout << sizeof(f) << " ";
	findSize(f);
	return 0;
}

40 40
80 80

Time Complexity: O(1)
Space Complexity: O(n) where n is the size of array.
Now the next step is to print the size of a dynamically allocated array. 

It’s your task man! I’m giving you a hint.

#include <iostream>
#include <cstdlib>
using namespace std;
 
int main()
{
    int *arr = (int*)malloc(sizeof(int) * 20);
    return 0;
    
    What is Array Decay in C++? How can it be prevented?
    What is Array Decay? 
The loss of type and dimensions of an array is known as decay of an array. This generally occurs when we pass the array into function by value or pointer. What it does is, it sends first address to the array which is a pointer, hence the size of array is not the original one, but the one occupied by the pointer in the memory.

// C++ code to demonstrate array decay
#include <iostream>
using namespace std;

// Driver function to show Array decay
// Passing array by value
void aDecay(int* p)
{
    // Printing size of pointer
    cout << "Modified size of array is by "
            " passing by value: ";
    cout << sizeof(p) << endl;
}

int main()
{
    int a[7] = {
        1, 2, 3, 4, 5, 6, 7,
    };

    // Printing original size of array
    cout << "Actual size of array is: ";
    cout << sizeof(a) << endl;

    // Passing a pointer to array
    aDecay(a);

    return 0;
}
Actual size of array is: 28
Modified size of array is by  passing by value: 8

In the above code, the actual array has 7 int elements and hence has 28 size. But by calling by value and pointer, array decays into pointer and prints the size of 1 pointer i.e. 8 (4 in 32 bit).

Another way to prevent array decay is to send the array into functions by reference. This prevents conversion of array into a pointer, hence prevents the decay.
// C++ code to demonstrate prevention of
// decay of array
#include<iostream>
using namespace std;

// A function that prevents Array decay
// by passing array by reference
void fun(int (&p)[7])
{
    // Printing size of array
    cout << "Modified size of array by "
            "passing by reference: ";
    cout << sizeof(p) << endl;
}

int main()
{
    int a[7] = {1, 2, 3, 4, 5, 6, 7,};

    // Printing original size of array
    cout << "Actual size of array is: ";
    cout << sizeof(a) <<endl;

    // Calling function by reference
    fun(a);

    return 0;
}

Actual size of array is: 28
Modified size of array by passing by reference: 28


In the above code, passing array by reference solves the problem of decay of array. Sizes in both cases is 28. 

We can also preserve the size of the array by passing it as a pointer to the array which have one more dimension as compared to our array
// C++ code to demonstrate array decay
#include <iostream>
using namespace std;

// Function to show that array decay happens
// even if we use pointer
void pDecay(int (*p)[7])
{
    // Printing size of array
    cout << "Modified size of array by "
            "passing by pointer: ";
    cout << sizeof(p) << endl;
}

int main()
{
    int a[7] = { 1, 2, 3, 4, 5, 6, 7 };

    // Printing original size of array
    cout << "Actual size of array is: ";
    cout << sizeof(a) << endl;

    // Passing a pointer to array
    pDecay(&a);

    return 0;
}

Actual size of array is: 28
Modified size of array by passing by pointer: 8

But in this case, we will have to treat the array in the function as 2d array and to access the value stored in the array, we have to access it like this: arr[0][1], arr[0][3], .. and so on.

### **📌 Concise Notes on `vector<int>` in C++**  

---

### **🔹 What is a `vector<int>`?**  
A **vector** is a **dynamic array** in C++ that can resize itself automatically when needed. It is part of the **Standard Template Library (STL)** and provides various built-in functions for easier manipulation of elements.

---

### **🔹 Why Use `vector<int>` Over Arrays?**  

| Feature            | `vector<int>` | `int arr[n]` (Array) |
|--------------------|--------------|----------------------|
| **Size**          | Dynamic (Auto-expanding) | Fixed at compile-time |
| **Memory Management** | Automatic | Manual |
| **Ease of Use**   | Built-in functions (push, pop, etc.) | No built-in functions |
| **Safety**        | Checks for out-of-bounds access (via `.at()`) | No safety checks |
| **Resizing**      | Can grow/shrink dynamically | Cannot resize |

---

### **🔹 Declaration & Initialization**
```cpp
vector<int> v;        // Empty vector  
vector<int> v(5);     // Vector of size 5 (default 0)  
vector<int> v(5, 10); // Vector of size 5, all elements = 10  
vector<int> v = {1, 2, 3, 4, 5}; // Initialize with values  
```

---

### **🔹 Input & Output**
```cpp
int n;
cin >> n;
vector<int> v(n);  // Declare vector of size n
for (int i = 0; i < n; i++) cin >> v[i];  // Input
for (int x : v) cout << x << " ";  // Print using range-based loop
```

---

### **🔹 Adding & Removing Elements**
```cpp
v.push_back(10);   // Add 10 to the end  
v.pop_back();      // Remove last element  
v.clear();         // Remove all elements  
```

---

### **🔹 Checking Size & Accessing Elements**
```cpp
cout << v.size();  // Get number of elements  
cout << v[2];      // Access 3rd element  
cout << v.at(2);   // Safe access (checks bounds)  
```

---

### **🔹 Looping Over a Vector**
```cpp
for (int i = 0; i < v.size(); i++) cout << v[i] << " ";  
for (int x : v) cout << x << " ";  // For-each loop  
```

---

### **🔹 When to Use `vector<int>`?**
✅ When you **don’t know the size** beforehand.  
✅ When you **need dynamic resizing**.  
✅ When you **want built-in functions** for efficiency.  

**✨ `vector<int>` is a powerful, flexible, and safer alternative to arrays!** 🚀





