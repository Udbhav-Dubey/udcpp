
Writing First C++ Program – Hello World Example
Last Updated : 11 Jan, 2025

The “Hello World” program is the first step towards learning any programming language and is also one of the most straightforward programs you will learn. It is the basic program that is used to demonstrate how the coding process works. All you have to do is display the message “Hello World” on the output screen.
C++ Hello World Program

Below is the C++ program to print “Hello World” on the console screen.
1

// Header file for input output functions

2

#include <iostream>

3

using namespace std;

4

​

5

// main() function: where the execution of

6

// C++ program begins

7

int main() {

8

  

9

    // This statement prints "Hello World"

10

    cout << "Hello World";

11

​

12

    return 0;

13

}

Try it on GfG Practice
redirect icon

Output

Hello World

To write and run C++ programs, you need to set up the local environment on your computer. Refer to the complete article Setting up C++ Development Environment. If you do not want to set up the local environment on your computer, you can also use online IDE to write and run your C++ programs.
Working of Hello World Program in C++

Let us now understand every line and the terminologies of the above program.

    // C++ program to display “Hello World”

This line is a comment line. A comment is used to display additional information about the program. A comment does not contain any programming logic. When a comment is encountered by a compiler, the compiler simply skips that line of code.

    #include <iostream>

The #include is a preprocessor directive tells the compiler to include the content of a file in the source code. For example, #include<iostream> tells the compiler to include the input-output library which contains all C++’s input/output library functions.

    using namespace std

This is used to import the entity of the stdnamespace into the current namespace of the program. It is basically the space where all the inbuilt features of C++ are declared. For example, std::cout.

    int main() { }

The main() function is the entry point of every C++ program, no matter where the function is located in the program. The opening braces ‘{‘ indicates the beginning of the main function and the closing braces ‘}’ indicates the ending of the main function.

    cout<<“Hello World”;

The coutis a tool (object) that is used to display output on the console screen. Everything followed by the character << in double quotes ” ” is displayed on the output screen. The semi-colon character at the end of the statement is used to indicate that the statement is ending there.

    return 0

This statement is used to return a value from a function and indicates the finishing of a function. Here, it is used to sent the signal of successful execution of the main function.

Also, as you can see, the cout and the return statement have been indented or moved to the right side. This is done to make the code more readable. We must always use indentations and comments to make the code more readable. Must read the FAQ on the style of writing programs.


C++ Basic Syntax
Last Updated : 03 Feb, 2025

Syntax refers to the rules and regulations for writing statements in a programming language. They can also be viewed as the grammatical rules defining the structure of a programming language.

The C++ language also has its syntax for the functionalities it provides. Different statements have different syntax specifying their usage, but C++ programs also have basic syntax rules that are followed throughout all the programs.
Basic Syntax of a C++ Program

We can learn about basic C++ Syntax using the following program

// C++ program to demonstrate the basic syntax
// Header File Library
#include <iostream>

// Standard Namespace
using namespace std;

// Main Function
int main()
{

    // Body of the Function

    // Declaration of Variable
    int num1 = 24;
    int num2 = 34;

    int result = num1 + num2;

    // Output
    cout << result << endl;

    // Return Statement
    return 0;
}
58

The program above shows the basic C++ program that contains header files, main function, namespace declaration, etc. Let’s try to understand them one by one.
1. Header File

The header files contain the definition of the functions and macros we are using in our program. In line #1, we used the #include  <iostream> statement to tell the compiler to include an iostream header file library which stores the definition of the cin and cout standard input/output streams that we have used for input and output. #include is a preprocessor directive using which we import header files.
2. Namespace

A namespace in C++ is used to provide a scope or a region where we define identifiers. In line #2, we have used the using namespace std statement for specifying that we will be the standard namespace where all the standard library functions are defined.
3. Main Function

In line #3, we defined the main function as int main(). The main function is the most important part of any C++ program. The program execution always starts from the main function. All the other functions are called from the main function. In C++, the main function is required to return some value indicating the execution status.
4. Blocks

Blocks are the group of statements that are enclosed within { } braces. The body of the main function is from line #4 to line #9 enclosed within  { }.
5. Semicolons

As you may have noticed by now, each statement in the above code is followed by a ( ; ) semicolon symbol. It is used to terminate each line of the statement of the program.
6. Identifiers

We use identifiers for the naming of variables, functions, and other user-defined data types. An identifier may consist of uppercase and lowercase alphabetical characters, underscore, and digits. The first letter must be an underscore or an alphabet.
7. Keywords

In the C++ programming language, there are some reserved words that are used for some special meaning in the C++ program. It can’t be used for identifiers. For example, the words int, return, and using are some keywords used in our program.
8. Basic Output cout

In line #7, we have used the cout stream object (declared in the <iostream> header file) to print the sum of two numbers to the standard output stream (stdout).
Object-Oriented Programming in C++

C++ programming language supports both procedural-oriented and object-oriented programming. The above example is based on the procedural-oriented programming paradigm. So let’s take another example to discuss Object Oriented Programming in C++.
1

#include <iostream>

2

using namespace std;

3

​

4

class Calculate {

5

​

6

    // Access Modifiers

7

public:

8

​

9

    // data member

10

    int num1 = 50;

11

    int num2 = 30;

12

​

13

    // member function

14

    void addition() {

15

        int result = num1 + num2;

16

        cout << result << endl;

17

    }

18

};

19

​

20

int main() {

21

​

22

    // object declaration

23

    Calculate add;

24

    

25

    // member function calling

26

    add.addition();

27

​

28

    return 0;

29

}


Output

80

1. Class

A class is a user-defined data type. A class has its own attributes (data members) and behavior (member functions). In line #3, we have declared a class named Calculate and its body expands from line #3 to line #7.
2. Data Members & Member Functions

The attributes or data in the class are defined by the data members & the functions that work on these data members are called the member functions.

In the above example, num1 and num2 are the data member & addition() is a member function that is working on these two data members. There is a keyword here public that is access modifiers. The access modifier decides who has access to these data members & member functions.
3. Object

The object is an instance of a class. The class itself is just a template that is not allocated any memory. To use the data and methods defined in the class, we have to create an object of that class.

C++ Comments

Single Line Comment

In C++, single line comments are represented as // double forward slash. It applies comments to a single line only. The compiler ignores any text after // and it will not be executed.

Syntax:

    // Single line comment


Multi-Line Comment

A multi-line comment can occupy many lines of code, it starts with /* and ends with */, but it cannot be nested. Any text between /* and */ will be ignored by the compiler.

Syntax:

     /*
         Multiline Comment
         .
         .
         .
     */


Why Comments are used in C++?

Comments in C++ are used to summarize an algorithm, identify a variable’s purpose, or clarify a code segment that appears unclear. Comments are also used for:

    Comments are used for easier debugging.
    It makes a program more readable and gives an overall description of the code.
    Comments are helpful in skipping the execution of some parts of the code.
    Every time a program or code is reused after long periods of time, the comment recaps all the information of the code quickly.
    
    How does the compiler process C++ Comments?

As a part of the compiler, the Lexical Analyzer scans the characters and transforms them into tokens with no passing of the commented text to the parser. Since Comments do not contribute to the functionality of the program they are simply omitted at the time of compilation. Accordingly, we can understand that comments are just text in programs that are ignored by the compiler.

Tokens in C
Last Updated : 21 Jan, 2025

In C programming, tokens are the smallest units in a program that have meaningful representations. Tokens are the building blocks of a C program, and they are recognized by the C compiler to form valid expressions and statements. Tokens can be classified into various categories, each with specific roles in the program.
Types of Tokens in C
Tokens-in-C

The tokens of C language can be classified into six types based on the functions they are used to perform. The types of C tokens are as follows:

Table of Content

    Punctuators
    Keywords
    Strings
    Operators
    Identifiers
    Constants

1. Punctuators

The following special symbols are used in C having some special meaning and thus, cannot be used for some other purpose. Some of these are listed below:

    Brackets[]: Opening and closing brackets are used as array element references. These indicate single and multidimensional subscripts.
    Parentheses(): These special symbols are used to indicate function calls and function parameters.
    Braces{}: These opening and ending curly braces mark the start and end of a block of code containing more than one executable statement.
    Comma (, ): It is used to separate more than one statement like for separating parameters in function calls.
    Colon(:): It is an operator that essentially invokes something called an initialization list.
    Semicolon(;): It is known as a statement terminator.  It indicates the end of one logical entity. That’s why each individual statement must be ended with a semicolon.
    Asterisk (*): It is used to create a pointer variable and for the multiplication of variables.
    Assignment operator(=): It is used to assign values and for logical operation validation.
    Pre-processor (#): The preprocessor is a macro processor that is used automatically by the compiler to transform your program before actual compilation.
    Period (.): Used to access members of a structure or union.
    Tilde(~): Bitwise One’s Complement Operator.

Example:
1

#include <stdio.h>  

2

int main() {

3

  

4

    // '\n' is a special symbol that

5

    // represents a newline

6

    printf("Hello, World!\n");  

7

    return 0;

8

}


Output

Hello, World!

2. Keywords

Keywords are reserved words that have predefined meanings in C. These cannot be used as identifiers (variable names, function names, etc.). Keywords define the structure and behavior of the program C language supports 32 keywords some of them are:

    int, for, if, else, while, return, etc.

Example:
1

#include <stdio.h>  

2

int main() {

3

   

4

    // 'int' is a keyword used to define

5

    // variable type

6

    int x = 5;  

7

    printf("%d", x);

8

  

9

    // 'return' is a keyword used to exit

10

    // main function

11

    return 0;  

12

}


Output

5

    Note: The number of keywords may change depending on the version of C you are using. For example, keywords present in ANSI C are 32 while in C11, it was increased to 44. Moreover, in the latest c23, it is increased to around 54.

3. Strings

Strings are nothing but an array of characters ended with a null character (‘\0’). This null character indicates the end of the string. Strings are always enclosed in double quotes. Whereas a character is enclosed in single quotes in C and C++.

Examples:
1

#include <stdio.h>  

2

int main() {

3

  

4

    // "Hello, World!" is a string literal

5

    char str[] = "Hello, World!";  

6

    printf("%s", str);

7

    return 0;

8

}


Output

Hello, World!

4. Operators

Operators are symbols that trigger an action when applied to C variables and other objects. The data items on which operators act are called operands. 
Depending on the number of operands that an operator can act upon, operators can be classified as follows: 

    Unary Operators: Those operators that require only a single operand to act upon are known as unary operators.For Example increment and decrement operators
    Binary Operators: Those operators that require two operands to act upon are called binary operators. Binary operators can further are classified into: 
        Arithmetic operators
        Relational Operators
        Logical Operators
        Assignment Operators
        Bitwise Operator
    Ternary Operator: The operator that requires three operands to act upon is called the ternary operator. Conditional Operator(?) is also called the ternary operator.

Example:
1

#include <stdio.h>  

2

int main() {

3

    int a = 10, b = 5;  

4

  

5

    // '+' is an arithmetic operator used

6

    // for addition

7

    int sum = a + b;  

8

    printf("%d", sum); 

9

    return 0;

10

}


Output

15

5. Identifiers

Identifiers are names given to variables, functions, arrays, and other user-defined items. They must begin with a letter (a-z, A-Z) or an underscore (_) and can be followed by letters, digits (0-9), and underscores.

Example:
1

#include <stdio.h>  

2

int main() {

3

  

4

    // 'num' is an identifier used to name

5

    // a variable

6

    int num = 10;  

7

    printf("%d", num); 

8

    return 0;

9

}


Output

10

6. Constants

Constants are fixed values used in a C program. These values do not change during the execution of the program. Constants can be integers, floating-point numbers, characters, or strings.

Examples:
1

#include <stdio.h>  

2

int main() {

3

  

4

    // 'MAX_VALUE' is a constant that holds

5

    // a fixed value

6

    const int MAX_VALUE = 100;  

7

    printf("%d", MAX_VALUE);

8

    return 0;

9

}


Output

100


C++ Keywords
Last Updated : 23 Dec, 2024

Keywords are the reserved words that have special meanings in the C++ language. They are the words that the language uses for a specifying the components of the language, such as void, int, public, etc. They can’t be used for a variable name or function name or any other identifiers.

Let’s take a look at the hello world code:
#include <iostream>
using namespace std;

int main() {
  
    cout << "Hello World";
  
    return 0;
}
ello World

Explanation: In the above code, using, namespace, and return are the keywords that are used to implement some functionality of the language. Their meaning is predefined in C++ and will always remain same.

The total number of keywords in C++ are 95 upto C++ 23 specification. Below is the table for all C++ keywords:
alignas	alignof	and	and_eq	asm
auto	bitand	bitor	bool	break
case	catch	char	char8_t	char16_t
char32_t	class	compl	concept	const
consteval	constexpr	constinit	const_cast	continue
co_await	co_return	co_yield	decltype	default
delete	do	double	dynamic_cast	else
enum	explicit	export	extern	false
final	float	for	friend	goto
if	inline	int	long	mutable
namespace	new	noexcept	not	not_eq
nullptr	operator	or	or_eq	private
protected	public	register	reinterpret_cast	requires
return	short	signed	sizeof	static
static_assert	static_cast	struct	switch	template
this	thread_local	throw	true	try
typedef	typeid	typename	union	unsigned
using	virtual	void	volatile	wchar_t
while	xor	xor_eq		
Keywords vs Identifiers

So, there are some properties of keywords that distinguish keywords from identifiers. They listed in the below table
Keywords	 Identifiers
Keywords are predefined/reserved words	 identifiers are the values used to define different programming items like a variable, integers, structures, and unions.
It defines the type of entity.	It classifies the name of the entity.
A keyword contains only alphabetical characters, 	an identifier can consist of alphabetical characters, digits, and underscores.
It should be lowercase.	It can be both upper and lowercase.
No special symbols or punctuations are used in keywords and identifiers. 	No special symbols or punctuations are used in keywords and identifiers.  The only underscore can be used in an identifier.
Example: int, char, while, do.	Example: Geeks_for_Geeks, GFG, Gfg1
ifference between Keyword and Identifier in C
Last Updated : 23 Dec, 2024

In C, keywords and identifiers are basically the fundamental parts of the language used. Identifiers are the names that can be given to a variable, function or other entity while keywords are the reserved words that have predefined meaning in the language.

The below table illustrates the primary differences between the keywords and identifiers:
Parameters	Keywords	Identifiers
Definition	Keywords are predefined word that gets reserved for working program that have special meaning and cannot get used anywhere else.	Identifiers are the values used to define different programming items such as variables, integers, structures, unions and others and mostly have an alphabetic character.
Use	Specify the type/kind of entity.	Identify the name of a particular entity.
	It always starts with a lowercase letter.	First character can be a uppercase, lowercase letter or underscore.
Rules of Definition	A keyword should be in lower case and can only contains alphabetical characters.	An identifier can be in upper case or lower case and can consist of alphabetical characters, digits and underscores.
Purpose	They help to identify a specific property that exists within a computer language.	They help to locate the name of the entity that gets defined along with a keyword.
Examples	int, char, if, while, do, class etc.	Test, count1, high_speed, etc.
Keywords

Keywords are specific reserved words in C each of which has a specific feature associated with it. Almost all of the words which help us use the functionality of the C language are included in the list of keywords. So, you can imagine that the list of keywords is not going to be a small one! There are a total of 32 keywords in C:

auto
	

break
	

case
	

char
	

const
	

continue
	

default
	

do

double
	

else
	

enum
	

extern
	

float
	

for
	

goto
	

if

int
	

long
	

register
	

return
	

short
	

signed
	

sizeof
	

static

struct
	

switch
	

typedef
	

union
	

unsigned
	

void
	

volatile
	

while
Identifiers

Identifiers are used as the general terminology for naming of variables, functions and arrays. These are user defined names consisting of arbitrarily long sequence of letters and digits with either a letter or the underscore(_) as a first character. Identifier names must differ in spelling and case from any keywords. You cannot use keywords as identifiers; they are reserved for special use. Once declared, you can use the identifier in later program statements to refer to the associated value. A special kind of identifier, called a statement label, can be used in goto statements.
Code Illustration

The below example illustrate the different purpose of the keywords and identifers in C:
1

#include <stdio.h>

2

​

3

// 'main' is also an identifier

4

// although it is predefined

5

int main() {

6

  

7

    // Example of a keyword: int

8

      // Here, age is identifier

9

    int age = 25;

10

​

11

    printf("Age: %d\n", age);

12

​

13

    // return is a keyword that exits function

14

    return 0; 

15

}


Output

Age: 25

Explanation: In the above code, age is an identifier used to name a variable. The type of variable is integer that is specified using int keyword as it already is defined in C to indicate that the variable will store integer data.

C++ Variables
Last Updated : 19 Dec, 2024

In C++, variable is a name given to a memory location. It is the basic unit of storage in a program. The value stored in a variable can be accessed or changed during program execution. In this article, we will learn about the variables in C++ and how to use them in our programs.

Let’s take a look at an example:
1

#include <iostream>

2

using namespace std;

3

​

4

int main() {

5

    

6

      // A variable that may store the data of

7

      // int type (whole numbers)

8

    int var;

9

  

10

      // Assigning a whole number

11

      var = 100;

12

  

13

      // Printing the variable

14

      cout << var;

15

  

16

    return 0;

17

}


Output

100

Explanation: A variable with name var is created. It is of the type int (keyword for integer) and can store the whole numbers. In the next step, we assigned a value 100 to it and finally, we access the stored value using the variable’s name.

The C++ Course covers the types of variables in C++ and how to use them effectively in your programs.
Syntax of Variables

Creating a variable and giving it a name is called variable definition. The syntax of variable definition is:

    type name;

Here,

    type: type of data that a variable can store.
    name: name assigned to the variable.

Multiple variables of the same type can be defined as:

    type name1, name2, name3 ….;

Types of Variables

In C++, following are the data types a variable can store:

    int: For storing integers or whole numbers.
    float: For storing real numbers with decimal points.
    char: For storing single characters.
    bool: For storing boolean value i.e. true and false.
    string: For storing the textual data.

Rules For Naming Variable

The names given to a variable is called identifiers. There are some rules for giving a name to the variable:

    The name of the variable contains letters, digits, and underscores.
    The name of the variable is case sensitive (e.g. Arr and arr both are different variables).
    The name of the variable does not contain any whitespace and special characters (ex #, $, %, *, etc).
    All the variable names must begin with a letter of the alphabet or an underscore (_).
    We cannot used C++ keyword (e.g. float, double, class) as a variable name.

Some valid variable names: x, var, _here, arr40
Some invalid variable names: 89, a b, double
Variable Initialization

The next step is initialization. It means assigning an initial value to the variable. It is done by using an assignment operator = with the variable name as left operand and the value as the right operand.

    type name = value;      // At the time of declaration
    name = value;      // After declaration
    type name1 = value1, name2 = value2;      // For multiple variables

The value should be of the same type as variable. For example, a variable declared as int var; should only store the integer variable.
Examples of Variables

The below examples demonstrate how to use the variables in our C++ programs:
Store Data in a Variable and Print It
1

#include <iostream>

2

using namespace std;

3

​

4

int main() {

5

​

6

    // Defining and initializing a variable

7

      int age1 = 15;

8

  

9

      // Defining a variable

10

      int age2;

11

  

12

      // Initialize the variable

13

      age2 = 99;

14

  

15

      // Displaying variable

16

      cout << age1 << endl;

17

      cout << age2;

18

    return 0;

19

}


Output

15
99

Create Multiple Variables at Once
1

#include <iostream>

2

using namespace std;

3

​

4

int main() {

5

  

6

      // Creating three variables that store characters

7

      char a = 'A', b = 'B', c = 'C';

8

  

9

      // Update the value

10

      c = 'c';

11

​

12

    cout << a << " " << b << " " << c;

13

    return 0;

14

}


Output

A B c

Memory Management of Variables

When a variable is declared, the compiler is told about the variable name and the type of data it will store. It is not allocated the any memory at this point. It is when the variable is defined it is allocated the memory. The amount of memory allocated depends upon the type of data that a variable intends to store.

Initially, the variable only stores some garbage value (value that does not mean anything). At the time of initialization, it is assigned some meaningful value that using the assignment operator that is then stored in the memory allocated to the function. So basically, we are manipulating a specific part of memory using the variable name.

At last, the data stored in the allocated memory can be accessed using the variable name.


Scope of Variables in C++
Last Updated : 10 Dec, 2024

In C++, the scope of a variable is the extent in the code upto which the variable can be accessed or worked with. It is the region of the program where the variable is accessible using the name it was declared with.

Let’s take a look at an example

#include <iostream>
using namespace std;

// Declaring first variable
int a = 10;

int main() {

      // Declaring second variable
      int b = 9;

      // Accessing a and b variable in their scope
    cout << a << " " << b;

    return 0;
}
Global Scope

Global scope refers to the region outside any function or a block. The variables declared here are accessible throughout the entire program and are called Global Variables.

Local Scope

The local scope is the region inside the curly braces { }. Variables defined within a function or block are said to be local to those functions or a block and are called local variables. Local variables do not exist outside the block in which they are declared, i.e. they cannot be accessed or used outside that block.
Variable Shadowing

Consider that there is a local variable inside a function with the same name as that of a global variable. If the function tries to access the variable with that name, then which variable will be given precedence? Look at the below program to understand the question:  
1

#include<iostream>

2

using namespace std;

3

​

4

// Global variable

5

int a = 5;

6

​

7

int main() {

8

  

9

    // Local variable with same name as that of

10

      // global variable

11

    int a = 100;

12

  

13

      // Accessing a

14

    cout << a;

15

  

16

      return 0;

17

}


Output

100

Explanation: The variable a declared at the top is global variable and stores the value 5 whereas a declared within main function is local and stores a value 100. When accessed inside the main function, the local a’s value is printed. Also, there is no compilation error. It implies that

        If two variables with same name are defined in different scopes, the compiler allows it and does not show error.
        Whenever there is a local variable defined with same name as that of a global variable, the precedence is given to the local variable. This is called variable shadowing.
        Access Global Variable in Variable Shadowing

The global a is still available in the main function but is shadowed by the local a as it is available everywhere. One may ask if there is any way we can access the global a in the main function.

Yes, C++ allows the users to access global variable with the same name as local variable using scope resolution operator. The below examples show how it is done:
1

#include<iostream>

2

using namespace std;

3

​

4

// Global variable

5

int a = 5;

6

​

7

int main() {

8

  

9

    // Local variable with same name as that of

10

      // global variable

11

    int a = 100;

12

  

13

      // Accessing global a

14

    cout << ::a;

15

  

16

      return 0;

17

}


Output

5
why do we use << in cpp, i was used to = in c during printf
ChatGPT said:
ChatGPT

In C, you use printf for output, which relies on format specifiers:

printf("Hello, %s!\n", "world");

In C++, << is the insertion operator, used with cout for output:

std::cout << "Hello, world!" << std::endl;

Why use << instead of =?

    Operator Overloading: << is overloaded in C++ to work as a stream insertion operator for std::cout. It sends data to the output stream.

    Type Safety: Unlike printf, cout automatically handles different data types without format specifiers.

    Chaining: You can chain multiple insertions easily:

    std::cout << "Number: " << 42 << ", Pi: " << 3.14 << std::endl;

    This avoids dealing with format specifiers like %d or %f.

    Extensibility: You can overload << for custom classes, allowing seamless output formatting.

Would you like a deeper comparison of printf vs. cout in terms of performance or use cases?



Variations of Scopes in C++

Apart from the primary classification of the scopes as global and local, there are few other specialized variations of these scopes that divides the declared variable based on its accessibility and visibility. Following are some common variations of variable scopes in C++.

    Instance Scope
    Static Member Scope
    Namespace Scope

Instance Scope

In C++, instance scope refers to the region inside a class but outside any member function of the class. The variable declared here are called instance variables and are accessible to whole class. They can be accessed by the objects of the class.


#include <iostream>
using namespace std;

class A {
public:
  
      // Instance variable with instance scope i.e. accessible
      // in whole class
    int instanceVar;

    A(int val) {
        instanceVar = val;
    }

    void display() {
        cout << instanceVar << endl;
    }
};

int main() {
  
      // Creates a1 with instanceVar = 10
    A a1(1);
    a1.display();

      // Creates a2 with instanceVar = 20
    A a2(33);
    a2.display();

    return 0;
}
Static Member Scope

The static scope applies to variables and functions declared with the static keyword within the class. These variables are shared across all instances of a class and can be accessed using the class name without creating the instance.

Let’s take a look at an example:
#include <iostream>
using namespace std;

class A {
public:
  
      // Static variable with static scope i.e. accessible
      // in whole class
    static int staticVar;
};

int A::staticVar = 1;

int main() {
  
      // Access static variable
      cout << A::staticVar;

    return 0;
}
1

Namespace Scope

A namespace in C++ is a container that allows users to create a separate scope where the given variables are defined. It is used to avoid name conflicts and group related code together. These variables can be then accessed using their namespace name and scope resolution operator.

For example, the below program creates a variable inside a namespace and access it later using namespace name and scope resolution operator.
#include <iostream>
using namespace std;

namespace N {
      
      // Variable with namespace scope
    int namespaceVar = 10;
}

int main() {
  
      // Access variable using namespace
    cout << N::namespaceVar;  

    return 0;
}
10

Storage Classes in C++ with Examples
Last Updated : 24 Dec, 2024

C++ Storage Classes are used to describe the characteristics of a variable/function. It determines the lifetime, visibility, default value, and storage location which helps us to trace the existence of a particular variable during the runtime of a program. Storage class specifiers are used to specify the storage class for a variable.

C++ provides 6 different storage classes, which are as follows:

Table of Content

    auto Storage Class
    extern Storage Class
    static Storage Class
    register Storage Class
    mutable Storage Class
    thread_local Storage Class

Below is a detailed explanation of each storage class:
1. auto Storage Class

The auto storage class is the default class of all the variables declared inside a block. The auto stands for automatic and all the local variables that are declared in a block automatically belong to this class.

Properties of auto Storage Class Objects

    Scope: Local
    Default Value: Garbage Value
    Memory Location: RAM
    Lifetime: Till the end of its scope

Let’s take a look at an example:

Storage Classes in C++ with Examples
Last Updated : 24 Dec, 2024

C++ Storage Classes are used to describe the characteristics of a variable/function. It determines the lifetime, visibility, default value, and storage location which helps us to trace the existence of a particular variable during the runtime of a program. Storage class specifiers are used to specify the storage class for a variable.

C++ provides 6 different storage classes, which are as follows:

Table of Content

    auto Storage Class
    extern Storage Class
    static Storage Class
    register Storage Class
    mutable Storage Class
    thread_local Storage Class

Below is a detailed explanation of each storage class:
1. auto Storage Class

The auto storage class is the default class of all the variables declared inside a block. The auto stands for automatic and all the local variables that are declared in a block automatically belong to this class.

Properties of auto Storage Class Objects

    Scope: Local
    Default Value: Garbage Value
    Memory Location: RAM
    Lifetime: Till the end of its scope

Let’s take a look at an example:
#include <iostream>
using namespace std;

int main() {

    // Declaring an auto variable
    int a = 32;
    float b = 3.2;
    string c = "GeeksforGeeks";

    // Printing the auto variables
    cout << a << " \n";
    cout << b << " \n";
      cout << c << " \n";

    return 0;
}
32 
3.2 
GeeksforGeeks 

    Note: Earlier in C++, we could use the auto keyword to declare the auto variables explicitly but after C++11, the meaning of auto keyword is changed, and we could no longer use it to define the auto variables.

2. extern Storage Class

The extern storage class simply tells us that the variable is defined elsewhere and not within the same scope (or even source file) where it is used (i.e. external linkage). Basically, the variable is created in a different scope or file and can be used in a different file as well.

A normal global variable can be made extern as well by placing the extern keyword before its declaration/definition in any function/block. The main purpose of using extern variables is that they can be accessed between two different files which are part of a large program.

Properties of extern Storage Class Objects

    Scope: Global
    Default Value: Zero
    Memory Location: RAM
    Lifetime: Till the end of the program.

Let’s take a look at an example:

def.cpp
1

// Defining a global variable with external linkage

2

int var = 10;


#include <iostream>
using namespace std;

// Telling compiler that variable x is extern variable
// and has been defined elsewhere
extern int x;

int main() {
  
      // Printing the value of x
    cout << x;

    return 0;
}
10

3. static Storage Class

The static storage class is used to declare static variables that have the property of preserving their value even after they are out of their scope. They are initialized only once and exist until the termination of the program. Thus, no new memory is allocated because they are not re-declared. Global static variables can be accessed anywhere in the program but unlike extern variable, they have internal linkage so they cannot be accessed outside the program.

They are declared using static keyword.

Properties of static Storage Class

    Scope: Local
    Default Value: Zero
    Memory Location: RAM
    Lifetime: Till the end of the program
    
    #include <iostream>
using namespace std;

// Function containing static variables
// memory is retained during execution
int func() {
  
      // Static variable
    static int count = 0;
    count++;
    return count;
}

int main() {
    cout << func() << "\n";
    cout << func();
    
    return 0;
}
4. register Storage Class

The register storage class declares register variables using the register keyword which has the same functionality as that of the auto variables. The only difference is that the compiler tries to store these variables in the register of the microprocessor if a free register is available. This makes the use of register variables to be much faster than that of the variables stored in the memory during the runtime of the program. If a free register is not available, these are then stored in the RAM.

An important and interesting point to be noted here is that we cannot obtain the address of a register variable using pointers.

Properties of register Storage Class Objects

    Scope: Local
    Default Value: Garbage Value
    Memory Location: Register in CPU or RAM
    Lifetime: Till the end of its scope
    
    #include <iostream>
using namespace std;

int main() {

    // Declaring a register variable
    register char b = 'G';

    // Printing the register variable 'b'
    cout << b;
  
    return 0;
}
G

    Note: The register keyword is deprecated in C++17 onwards.

5. mutable Storage Class

Sometimes there is a requirement to modify one or more data members of class/struct through the const function even though you don’t want the function to update other members of class/struct. This task can be easily performed by using the mutable keyword. The keyword mutable is mainly used to allow a particular data member of a const object to be modified. 

When we declare a function as const, this pointer passed to the function becomes const. Adding a mutable to a variable allows a const pointer to change members.
Properties of mutable Storage Class

The mutable specifier does not affect the linkage or lifetime of the object. It will be the same as the normal object declared in that place.

Let’s take a look at an example:
#include <iostream>
using namespace std;

class A {
public:
    int x;

    // Defining mutable variable y
    // now this can be modified
    mutable int y;

    A(): x(4), y(10) {}
};

int main() {
  
    // a is created as constant
    const A a;

    // Trying to change the value
    a.y = 200;
    cout << a.y;

    // Uncommenting below lines
    // will throw error
    /* a.x = 8;
    cout << a.x; */
  
    return 0;
}
200

6. thread_local Storage Class

The thread_local Storage Class is the new storage class that was added in C++11. We can use the thread_local storage class specifier to define the object as thread_local. The thread_local variable can be combined with other storage specifiers like static or extern and the properties of the thread_local object changes accordingly.

Properties of thread_local Storage Class

    Memory Location: RAM
    Lifetime: Till the end of its thread
    #include <iostream>
#include <mutex>
#include <thread>

using namespace std;

// Defining thread-local variable
thread_local int val = 10;

// Mutex for synchronization
mutex mtx;

int main() {
  
    // Created 3 threads
    // Modify value in thread 1
    thread th1([]() {
        val += 18;
        lock_guard<mutex> lock(mtx);
        cout << "Thread 1 value: " << val << '\n';
    });

    thread th2([]() {
      
        // Modify value in thread 2
        val += 7;
        lock_guard<mutex> lock(mtx);
        cout << "Thread 2 value: " << val << '\n';
    });

    thread th3([]() {
      
        // Modify value in thread 3
        val += 13;
        lock_guard<mutex> lock(mtx);
        cout << "Thread 3 value: " << val << '\n';
    });

    // Wait for all threads to finish
    th1.join();
    th2.join();
    th3.join();

    // Print the value of value in the main thread
    cout << "Main thread value: " << val << '\n';

    return 0;
}
Thread 1 value Value: 28
Thread 2 value Value: 17
Thread 3 value Value: 23
Main thread value Value: 10

As we can see, each thread got its own copy of the thread_local variable and was only assigned the value that was specified in its callable.
Summary

The below table summarize the above storage classes:
2. extern Storage Class

The extern storage class simply tells us that the variable is defined elsewhere and not within the same scope (or even source file) where it is used (i.e. external linkage). Basically, the variable is created in a different scope or file and can be used in a different file as well.

A normal global variable can be made extern as well by placing the extern keyword before its declaration/definition in any function/block. The main purpose of using extern variables is that they can be accessed between two different files which are part of a large program.

Properties of extern Storage Class Objects

    Scope: Global
    Default Value: Zero
    Memory Location: RAM
    Lifetime: Till the end of the program.

Let’s take a look at an example:
// Defining a global variable with external linkage
int var = 10;
#include <iostream>
#include >
using namespace std;

// Telling compiler that variable x is extern variable
// and has been defined elsewhere
extern int x;

int main() {
  
      // Printing the value of x
    cout << x;

    return 0;
}


Static Keyword in C++
Last Updated : 11 Jan, 2025

The static keyword in C++ has different meanings when used with different types. In this article, we will learn about the static keyword in C++ along with its various uses.

In C++, a static keyword can be used in the following context:

Table of Content

    Static Variables in a Function
    Static Member Variable in a Class
    Static Member Functions in a Class
    Global Static Variable

Static Variables in a Function

In a function, when a variable is declared as static, space for it gets allocated for the lifetime of the program. Even if the function is called multiple times, space for the static variable is allocated only once and the value of the variable in the previous call gets carried through the next function call.

Let’s take a look at an example:
	
	You can see in the above program that the variable count is declared static. So, its value is carried through the function calls. The variable count is not getting initialized every time the function is called. As a side note, Java doesn’t allow static local variables in functions.

Applications

The static variables in a function have the following applications:

    Return local variable address from the function.
    Useful for implementing coroutines in C++ or any other application where the previous state of function needs to be stored.
    Memoization in recursive calls.
    
    Static Data Member in a Class

As the variables declared as static are initialized only once as they are allocated space in separate static storage so, the static member variables in a class are shared by the objects. There cannot be multiple copies of the same static variables for different objects. Also because of this reason static variables cannot be initialized using constructors.
undefined reference to `GfG::i'
collect2: error: ld returned 1 exit status

Explanation: You can see in the above program that we have tried to create multiple copies of the static variable i for multiple objects. But this didn’t happen.

So, a static variable inside a class should be initialized explicitly by the user using the class name and scope resolution operator outside the class as shown below: 

Let’s take a look at an example:

#include <iostream>
using namespace std;

class GfG {
public:
  
      // Static data member
    static int i;

    GfG(){
        // Do nothing
    };
};

int main() {
    GfG obj1;
    GfG obj2;
    obj1.i = 2;
    obj2.i = 3;

    // Prints value of i
    cout << obj1.i << " " << obj2.i;
}
		
		
		#include <iostream>
using namespace std;

class GfG {
public:
  
      // Static data member
    static int i;

    GfG(){
        // Do nothing
    };
};

// Static member inintialization
int GfG::i = 1;

int main() {
  
    // Prints value of i
    cout << GfG::i;
}
1

Explanation: We were able to access the static variable when is was initialized globally outside the class. Moreover, we can access the static data member without creating the object of the class.

Applications

The static data members can be used to implement the following:

    Counting Objects of a Class
    Store and share configuration or settings globally.
    Tracking Shared Resources
    Regulate or limit operations performed by multiple objects.
    Ensure a class has only one instance by using static members.


Static Member Functions in a Class

Just like the static data members or static variables inside the class, static member functions also do not depend on the object of the class. We are allowed to invoke a static member function using the object and the ‘.’ operator but it is recommended to invoke the static members using the class name and the scope resolution operator. Static member functions are allowed to access only the static data members or other static member functions, they cannot access the non-static data members or member functions of the class. 

Let’s take a look at an example:
1

#include <iostream>

2

using namespace std;

3

​

4

class GfG {

5

public:

6

  

7

    // Static member function

8

    static void printMsg() { cout << "Welcome to GfG!"; }

9

};

10

​

11

int main() {

12

  

13

    // Invoking a static member function

14

    GfG::printMsg();

15

}


Output

Welcome to GfG!
Applications

The static member functions have the following uses in C++:

    Accessing Static Member Variables
    Implement helper functions that do not depend on specific instances.
    Singleton Pattern Implementation
    Factory Methods to create and return objects without requiring an instance of the class.
    Logging and Debugging

Global Static Variable

A global static variable in C++ is a static variable declared outside of any class or function. Unlike regular global variables, a global static variable has internal linkage, meaning it is accessible only within the file where it is defined. This ensures that its scope is limited to the current translation unit, preventing conflicts with variables in other files that may have the same name.

Let’s take a look at an example:
1

#include <iostream>

2

using namespace std;

3

​

4

// Global static variable

5

static int count = 0;

6

​

7

void increment() {

8

    count++;

9

    cout << count << " ";

10

}

11

​

12

int main() {

13

    increment();

14

    increment();

15

    return 0;

16

}


Output

1 2 

Applications

The global static variables have the following uses in C++:

    Limiting variable scope to a file to prevent conflicts by ensuring the variable is accessible only within the file.
    Global counters or flags.
    Store settings or values that are specific to the functionality implemented in a single file.
    Use for shared resources in scenarios where frequent initialization and destruction can be avoided.
    Shared state across functions in a file.
    	
    DAta types
    	
    	
    	n C++, data types are classified into the following types:

S. No.
	Type	Description	Data Types

1
	Basic Data Types	Built-in or primitive data types that are used to store simple values.	int, float, double, char, bool, void

2
	Derived Data Types	Data types derived from basic types.	array, pointer, reference, function

3

	User Defined Data Types	Custom data types created by the programmer according to their need.	class, struct, union, typedef, using
	
	
1. Character Data Type (char)

The character data type is used to store a single character. The keyword used to define a character is char. Its size is 1 byte and it stores characters enclosed in single quotes (‘ ‘). It can generally store upto 256 characters according to their ASCII codes.

Syntax

    char name;



	#include <iostream>
using namespace std;

int main() {
  
      // Character variable
      char c = 'A';  
    cout << c;
  
    return 0;
}

2. Integer Data Type (int)

Integer data type denotes that the given variable can store the integer numbers. The keyword used to define integers is int. Its size is 4-bytes (for 64-bit) systems and can store numbers for binary, octal, decimal and hexadecimal base systems in the range from -2,147,483,648 to 2,147,483,647.

2. Integer Data Type (int)

Integer data type denotes that the given variable can store the integer numbers. The keyword used to define integers is int. Its size is 4-bytes (for 64-bit) systems and can store numbers for binary, octal, decimal and hexadecimal base systems in the range from -2,147,483,648 to 2,147,483,647
    int name;

where, name is the identifier assigned to the variable.
#include <iostream>
using namespace std;

int main() {

      // Creating an integer variable
    int x = 25;
    cout << x << endl;
  
      // Using hexadecimal base value
      x = 0x15;
      cout << x;

    return 0;
}
3. Boolean Data Type (bool)

The boolean data type is used to store logical values: true(1) or false(0). The keyword used to define a boolean variable is bool. Its size is 1 byte.

Syntax

    bool name;

where name is the identifier assigned to the variable.

Example
#include <iostream>
using namespace std;

int main() {
  
      // Creating a boolean variable
    bool isTrue = true;  
    cout << isTrue;
    return 0;
}
1

4. Floating Point Data Type (float)

Floating-point data type is used to store numbers with decimal points. The keyword used to define floating-point numbers is float. Its size is 4 bytes (on 64-bit systems) and can store values in the range from 1.2E-38 to 3.4e+38.

Syntax

    float name;


#include <iostream>
using namespace std;

int main() {
  
      // Floating point variable with a decimal value
      float f = 36.5;
      cout << f;
  
    return 0;
}
5. Double Data Type (double)

The double data type is used to store decimal numbers with higher precision. The keyword used to define double-precision floating-point numbers is double. Its size is 8 bytes (on 64-bit systems) and can store the values in the range from 1.7e-308 to 1.7e+308

Syntax
double name;

#include <iostream>
using namespace std;

int main() {
  
      // double precision floating point variable
      double pi = 3.1415926535;
      cout << pi;
  
    return 0;
}
3.14159

6. Void Data Type (void)

The void data type represents the absence of value. We cannot create a variable of void type. It is used for pointer and functions that do not return any value using the keyword void.
    void functionName();


#include <iostream>
using namespace std;

// Function with void return type
void hello() {
    cout << "Hello, World!" << endl;
}

int main() {
      hello();
    return 0;
}
Hello, World!

Size of Data Types in C++

Earlier, we mentioned that the size of the data types is according to the 64-bit systems. Does it mean that the size of C++ data types is different for different computers?

Actually, it is partially true. The size of C++ data types can vary across different systems, depending on the architecture of the computer (e.g., 32-bit vs. 64-bit systems) and the compiler being used. But if the architecture of the computer is same, then the size across different computers remains same.

We can find the size of the data type using sizeof operator.
#include <iostream>
using namespace std;

int main() {

    // Printing the size of each data type
    cout << "Size of int: " << sizeof(int) << " bytes" << endl;
    cout << "Size of char: " << sizeof(char) << " byte" << endl;
    cout << "Size of float: " << sizeof(float) << " bytes" << endl;
    cout << "Size of double: " << sizeof(double) << " bytes";

    return 0;
}
Size of int: 4 bytes
Size of char: 1 byte
Size of float: 4 bytes
Size of double: 8 bytes

Data Type Modifiers

Data type modifiers are the keywords used to change or give extra meaning to already existing data types. It is added to primitive data types as a prefix to modify their size or range of data they can store. There are 4 type modifiers in C++: short, long, signed and unsigned.

For Example,

Defining an int with long type modifier will change its size to 8 bytes:

    int => 4 bytes
    long int => 8 bytes

Similarly, other type modifiers also affect the size or range of the data type.

    long double, long long int, unsigned int, etc.

Data Types in C++ – FAQs
Is size of data types in C++ is different for different machines?

    Partially yes as the size of data types in C++ can vary across different machines depending on the system architecture (32-bit or 64-bit). But if the architecture is same, then size remains same.

Can I convert one data type value or variable to another?

    Yes, in C++, you can convert one data type to another using type casting. 

How many data types are there in C++?

    There are following number of data types in C++:

        Primitive Data Types: 6
        Derived Data Types: 4
        User Defined Data Types: 5

Why we need int if we can already represent integer values with float?

    int is more efficient for representing whole numbers as it avoids the rounding errors inherent in float allows for fast integer-specific operations like bitwise manipulation
    
Literals in C
Last Updated : 21 Jun, 2024

In C, Literals are the constant values that are assigned to the variables. Literals represent fixed values that cannot be modified. Literals contain memory but they do not have references as variables. Generally, both terms, constants, and literals are used interchangeably. 
For example, “const int = 5;“, is a constant expression and the value 5 is referred to as a constant integer literal.
Types of C Literals

There are 4 types of literal in C:

    Integer Literal
    Float Literal
    Character Literal
    String Literal


C-literals
1. Integer Literals

Integer literals are used to represent and store the integer values only. Integer literals are expressed in two types i.e.

A) Prefixes: The Prefix of the integer literal indicates the base in which it is to be read.
For Example:

    0x10 = 16

    Because 0x prefix represents a HexaDecimal base. So 10 in HexaDecimal is 16 in Decimal. Hence the value 16.

There are basically represented into 4 types:

a. Decimal-literal(base 10): A non-zero decimal digit followed by zero or more decimal digits(0, 1, 2, 3, 4, 5, 6, 7, 8, 9).

Example:

56, 78

b. Octal-literal(base 8): a 0 followed by zero or more octal digits(0, 1, 2, 3, 4, 5, 6, 7).

Example:

045, 076, 06210

c. Hex-literal(base 16): 0x or 0X followed by one or more hexadecimal digits(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, a, A, b, B, c, C, d, D, e, E, f, F).

Example:

0x23A, 0Xb4C, 0xFEA

d. Binary-literal(base 2): 0b or 0B followed by one or more binary digits(0, 1).

Example:

0b101, 0B111

B) Suffixes: The Suffixes of the integer literal indicates the type in which it is to be read.

For example:

    12345678901234LL 

    indicates a long long integer value 12345678901234 because of the suffix LL

These are represented in many ways according to their data types.

    int: No suffix is required because integer constant is by default assigned as an int data type.
    unsigned int: character u or U at the end of an integer constant.
    long int: character l or L at the end of an integer constant.
    unsigned long int: character ul or UL at the end of an integer constant.
    long long int: character ll or LL at the end of an integer constant.
    unsigned long long int: character ull or ULL at the end of an integer constant.

Example:
1

#include <stdio.h>

2

​

3

int main()

4

{

5

​

6

    // constant integer literal

7

    const int intVal = 10;

8

​

9

    printf("Integer Literal:%d \n", intVal);

10

    return 0;

11

}


Output

Integer Literal:10 

2. Floating-Point Literals

These are used to represent and store real numbers. The real number has an integer part, real part, fractional part, and exponential part. The floating-point literals can be stored either in decimal form or exponential form. While representing the floating-point decimals one must keep two things in mind to produce valid literal:

    In the decimal form, one must include the integer part, or fractional part, or both, otherwise, it will lead to an error.
    In the exponential form, one must include both the significand and exponent part, otherwise, it will lead to an error.

A few floating-point literal representations are shown below:

Valid Floating Literals:

10.125
1.215e-10L
10.5E-3

Invalid Floating Literals:

123E
1250f
0.e879

Example:
1

#include <stdio.h>

2

​

3

int main()

4

{

5

    // constant float literal

6

    const float floatVal = 4.14;

7

​

8

    printf("Floating point literal: %.2f\n",

9

        floatVal);

10

    return 0;

11

}


Output

Floating point literal: 4.14

3. Character Literals

This refers to the literal that is used to store a single character within a single quote. To store multiple characters, one needs to use a character array. Storing more than one character within a single quote will throw a warning and display just the last character of the literal. It gives rise to the following two representations:

    char type: This is used to store normal character literal or narrow-character literals. 

Example:

char chr = 'G';

Example:
1

#include <stdio.h>

2

​

3

int main()

4

{

5

    // constant char literal

6

    const char charVal = 'A';

7

​

8

    printf("Character Literal: %c\n",

9

        charVal);

10

    return 0;

11

}


Output

Character Literal: A


Escape Sequences: There are various special characters that one can use to perform various operations.
4. String Literals

String literals are similar to that character literals, except that they can store multiple characters and uses a double quote to store the same. It can also accommodate the special characters and escape sequences mentioned in the table above. We can break a long line into multiple lines using string literal and can separate them with the help of white spaces.
Example:

char stringVal[] = "GeeksforGeeks";

Example:
1

#include <stdio.h>

2

​

3

int main()

4

{

5

    const char str[]

6

        = "Welcome\nTo\nGeeks\tFor\tGeeks";

7

    printf("%s", str);

8

    return 0;

9

}


Output

Welcome
To
Geeks    For    Geeks
Derived Data Types in C++
Last Updated : 18 Dec, 2024

The data types that are derived from the primitive or built-in datatypes are referred to as Derived Data Types. They are generally the data types that are created from the primitive data types and provide some additional functionality.

In C++, there are four different derived data types:

Table of Content

    Functions
    Arrays
    Pointers
    References
    
    
User Defined Data Types in C++
Last Updated : 16 Jan, 2025

User defined data types are those data types that are defined by the user himself. In C++, these data types allow programmers to extend the basic data types provided and create new types that are more suited to their specific needs. C++ supports 5 user-defined data types:

Table of Content

    Class
    Structure
    Union
    Enumeration
    Typedef

Let’s take a look at each of them one by one.
1. Class

A Class is the building block of C++’s Object-Oriented programming paradigm. It is a user-defined data type, which holds its own data members and member functions, which can be accessed and used by creating an instance of that class. A class is like a blueprint for an object.
#include <bits/stdc++.h>
using namespace std;

class GfG {
  
    // Access specifier
public:
  
    // Data Member
    string name;

    // Member Function
    void printname() {
        cout << name;
    }
};

int main() {

    // Declare an object of class geeks
    GfG g;

    // Accessing data member
    g.name = "GeeksForGeeks";

    // Accessing member function
    g.printname();

    return 0;
}
Explanation: The above program defines a class named GfG with a name attribute and a function printname() to print the name. In the main function, it creates an object named g, sets the geekname as “GeeksforGeeks“, and calls the printname() function to display it.
2. Structure

A Structure is a user-defined data type like class. A structure creates a data type that can be used to group items of possibly different types into a single type.

3. Union

Like structures , union is also user-defined data type used to group data of different type into a single type. But in union, all members share the same memory location.
Explanation: The above program demonstrates the use of unions. Union named A with members i and c is defined that shares the same memory space. It is shown that when we only assign c some value, the i also stores the same value.
4. Enumeration

Enumeration (or enum) is a user-defined data type in C++ mainly used to assign names to integral constants, the names make a program easy to read and maintain.
5. Typedef and Using

C++ allows you to define explicitly new data type names by using the keywords typedef or using. They do not create a new data class, rather, defines a name for an existing type. This can increase the portability (the ability of a program to be used across different types of machines; i.e., mini, mainframe, micro, etc; without many changes to the code) of a program as only the typedef statements would have to be changed.

Data Type Ranges and Their Macros in C++
Last Updated : 18 Dec, 2024

Most of the times, in competitive programming, there is a need to assign the variable, the maximum or minimum value that data type can hold but remembering such a large and precise number comes out to be a difficult job. Therefore, C++ has certain macros to represent these numbers, so that these can be directly assigned to the variable without actually typing the whole number.

The <climits> header file in C++ defines macros that represent the upper and lower bounds of integer data types and <cfloat> defines the macros for float and double limits. These macros allow you to easily assign these extreme values to variables without manually typing them out.

Let’s take a look at an example:
#include <iostream>

// for int, char macros
#include <climits>

// for float, double macros
#include <cfloat>

using namespace std;

int main() {
  
    // Displaying ranges with the help of macros
    cout << "char ranges from: " << CHAR_MIN << " to "
         << CHAR_MAX << endl;

    cout << "\nnshort int ranges from: " << SHRT_MIN
         << " to " << SHRT_MAX << endl;
    cout << "\nint ranges from: " << INT_MIN << " to "
         << INT_MAX << endl;
    cout << "\nlong int ranges from: " << LONG_MIN << " to "
         << LONG_MAX << endl;
    cout << "\nfloat ranges from: " << FLT_MIN << " to "
         << FLT_MAX << endl;

    return 0;
}
Output

char ranges from: -128 to 127

nshort int ranges from: -32768 to 32767

int ranges from: -2147483648 to 2147483647

long int ranges from: -9223372036854775808 to 9223372036854775807

float ranges from: 1.17549e-38 to 3.40282e+38
Data Types and Their Range Macros

A list of some of the data type macros is mentioned below:

Data Type
	

Range
	

Macro for min value
	

Macro for max value

char
	

-128 to +127
	

CHAR_MIN
	

CHAR_MAX

short char
	

-128 to +127
	

SCHAR_MIN
	

SCHAR_MAX

unsigned char
	

0 to 255
	

—
	

UCHAR_MAX

short int
	

-32768 to +32767
	

SHRT_MIN
	

SHRT_MAX

unsigned short int
	

0 to 65535
	

—
	

USHRT_MAX

int
	

-2147483648 to +2147483647
	

INT_MIN
	

INT_MAX

unsigned int
	

0 to 4294967295
	

—
	

UINT_MAX

long int
	

-9223372036854775808 to +9223372036854775807
	

LONG_MIN
	

LONG_MAX

unsigned long int
	

0 to 18446744073709551615
	

—
	

ULONG_MAX

long long int
	

-9223372036854775808 to +9223372036854775807
	

LLONG_MIN
	

LLONG_MAX

unsigned long long int
	

0 to 18446744073709551615
	

—
	

ULLONG_MAX

float
	

1.17549e-38 to 3.40282e+38
	

FLT_MIN
	

FLT_MAX

float (negative)
	

-1.17549e-38 to -3.40282e+38
	

-FLT_MIN
	

-FLT_MAX

double
	

2.22507e-308 to 1.79769e+308
	

DBL_MIN
	

DBL_MAX

double (negative)
	

-2.22507e-308 to -1.79769e+308
	

-DBL_MIN
	

-DBL_MAX
Data Type Limits in Modern C++

The above macro approach for the upper and lower limits of the data type is the old C language approach inherited by C++. But C++ also have its own method to provide programmers with the same information.

C++ offers the numeric_limits<> class template as a modern alternative to these macros. This template provides a more object-oriented approach for accessing data type limits. It is defined inside the <limits> header file.

Let’s take a look at an example:
#include <iostream>
#include <limits>
using namespace std;

int main() {
  
    // Displaying ranges with the help of macros
    cout << "short int ranges from: " << numeric_limits<short int>::min()
         << " to " << numeric_limits<short int>::max() << endl;
    cout << "\nint ranges from: " << numeric_limits<int>::min() << " to "
         << numeric_limits<int>::max() << endl;
    cout << "\nlong int ranges from: " << numeric_limits<long>::min() << " to "
         << numeric_limits<long>::max() << endl;
    cout << "\nfloat ranges from: " << numeric_limits<float>::min() << " to "
         << numeric_limits<float>::max() << endl;

    return 0;
}
short int ranges from: -32768 to 32767

int ranges from: -2147483648 to 2147483647

long int ranges from: -9223372036854775808 to 9223372036854775807

float ranges from: 1.17549e-38 to 3.40282e+38
.
Data Types and Their Range Macros

A list of some of the data type macros is mentioned below:

Data Type
	

Range
	

Macro for min value
	

Macro for max value

char
	

-128 to +127
	

CHAR_MIN
	

CHAR_MAX

short char
	

-128 to +127
	

SCHAR_MIN
	

SCHAR_MAX

unsigned char
	

0 to 255
	

—
	

UCHAR_MAX

short int
	

-32768 to +32767
	

SHRT_MIN
	

SHRT_MAX

unsigned short int
	

0 to 65535
	

—
	

USHRT_MAX

int
	

-2147483648 to +2147483647
	

INT_MIN
	

INT_MAX

unsigned int
	

0 to 4294967295
	

—
	

UINT_MAX

long int
	

-9223372036854775808 to +9223372036854775807
	

LONG_MIN
	

LONG_MAX

unsigned long int
	

0 to 18446744073709551615
	

—
	

ULONG_MAX

long long int
	

-9223372036854775808 to +9223372036854775807
	

LLONG_MIN
	

LLONG_MAX

unsigned long long int
	

0 to 18446744073709551615
	

—
	

ULLONG_MAX

float
	

1.17549e-38 to 3.40282e+38
	

FLT_MIN
	

FLT_MAX

float (negative)
	

-1.17549e-38 to -3.40282e+38
	

-FLT_MIN
	

-FLT_MAX

double
	

2.22507e-308 to 1.79769e+308
	

DBL_MIN
	

DBL_MAX

double (negative)
	

-2.22507e-308 to -1.79769e+308
	

-DBL_MIN
	

-DBL_MAX 


Data Type Limits in Modern C++

The above macro approach for the upper and lower limits of the data type is the old C language approach inherited by C++. But C++ also have its own method to provide programmers with the same information.

C++ offers the numeric_limits<> class template as a modern alternative to these macros. This template provides a more object-oriented approach for accessing data type limits. It is defined inside the <limits> header file.

Let’s take a look at an example:
#include <iostream>
#include <limits>
using namespace std;

int main() {
  
    // Displaying ranges with the help of macros
    cout << "short int ranges from: " << numeric_limits<short int>::min()
         << " to " << numeric_limits<short int>::max() << endl;
    cout << "\nint ranges from: " << numeric_limits<int>::min() << " to "
         << numeric_limits<int>::max() << endl;
    cout << "\nlong int ranges from: " << numeric_limits<long>::min() << " to "
         << numeric_limits<long>::max() << endl;
    cout << "\nfloat ranges from: " << numeric_limits<float>::min() << " to "
         << numeric_limits<float>::max() << endl;

    return 0;
}
short int ranges from: -32768 to 32767

int ranges from: -2147483648 to 2147483647

long int ranges from: -9223372036854775808 to 9223372036854775807

float ranges from: 1.17549e-38 to 3.40282e+38

It is recommended to use this approach to find the upper and lower limits of the data type instead of macros as it is more type safe, and readable compared to the macro-based approach.




C++ Type Modifiers
Last Updated : 30 Dec, 2024

In C++, type modifiers are the keywords used to change or give extra meaning to already existing data types. It is added to primitive data types as a prefix to modify their size or range of data they can store.

C++ have 4 type modifiers which are as follows:

Let’s understand at each of them one by one.
1. signed Modifier

The signed modifier indicates that the given variable variables can store both positive and negative values. To specify any variable as signed, just add the keyword signed at the start of the variable declaration.

Syntax

    signed type name;


#include <iostream>
using namespace std;

int main() {
  
      // Printing the size of normal and signed int
      cout << "signed int size: " << sizeof(signed int)
          << " bytes" << endl;
    cout << "int size: " << sizeof(int) << " bytes";

    return 0;
}
signed int's size: 4 bytes
int's size: 4 bytes

    Note: The int datatype is signed by default. So, int can directly be used instead of signed int.


2. unsigned Modifier

The unsigned modifier indicates that the given variables can store only non-negative integer values. Like signed modifier, it is also added at the start of the variable declaration to define the given variable as unsigned.

Syntax

    unsigned type name;

Unsigned modifier can only be used with integer and character data types.

2. unsigned Modifier

The unsigned modifier indicates that the given variables can store only non-negative integer values. Like signed modifier, it is also added at the start of the variable declaration to define the given variable as unsigned.

Syntax

    unsigned type name;

Unsigned modifier can only be used with integer and character data types.
As we can see, when we assigned some negative value to unsigned integer, the value gets converted to its 2’s complement because unsigned types cannot store the negative values.
3. short Modifier

The short keyword decreases the size of the data type in the memory. It leads to the decrease in the range of value that the given data type can store. A variable can be declared as short by adding the short keyword before the variable declaration.

Syntax

    short type name;

#include <iostream>
using namespace std;

int main() {
  
      // Printing the size of short and normal ints
    cout << "short int size: " << sizeof(short int)
          << " bytes" << endl;
      cout << "int size: " << sizeof(int)
          << " bytes";
    return 0;
}
4. long Modifier

The long keyword increases the size of the data type in memory. It leads to increase in the range of value that the given data type can store. A variable can be declared as long by adding the long keyword before the variable declaration.

Syntax

    long type name;

The long modifier can be used with integer and double data type. It can also be used twice on integers.

Example:
1

#include <iostream>

2

using namespace std;

3

​

4

int main() {

5

  

6

      // Printing the size of long and normal ints

7

      // double and long double

8

    cout << "int size: " << sizeof(int)

9

          << " bytes" << endl;

10

      cout << "long int size: " << sizeof(long int)

11

          << " bytes" << endl;

12

      cout << "double size: " << sizeof(double)

13

          << " bytes" << endl;

14

      cout << "long double size: " << sizeof(long double)

15

          << " bytes";

16

    return 0;

17

}
int size: 4 bytes
long int size: 8 bytes
double size: 8 bytes
long double size: 16 bytes

    Note: The long int can be written as long also. They are equivalent.


Size and Range of Data Types with Modifiers

The below table lists the size and the range of data type (in 64-bit compiler) that is changed with the help of modifiers:
Data Type	Modifiers	Size (bytes)	Range
char	signed	1	-128 to 127
unsigned (default)	1	0 to 255
short int	signed (default)	2	-32,768 to 32,767
unsigned	2	0 to 65,535
int	signed (default)	4	-2,147,483,648 to 2,147,483,647
unsigned	4	0 to 4,294,967,295
long int	signed (default)	8	-9,223,372,036,854,775,808 to 9,223,372,036,854,775,807
unsigned	8	0 to 18,446,744,073,709,551,615
long long int	signed (default)	8	-9,223,372,036,854,775,808 to 9,223,372,036,854,775,807
unsigned	8	0 to 18,446,744,073,709,551,615
double	None	8	~1.7E-308 to 1.7E+308
long double	None	16	Higher precision, range varies depending on implementatio

The short keyword can only be used with integer data type.
    Note: The short int can be written as short also. They are equivalent.


Type Conversion in C++
Last Updated : 30 Dec, 2024

Type conversion means converting one type of data to another compatible type such that it doesn’t lose its meaning. It is essential for managing different data types in C++.

Let’s take a look at an example:
#include <iostream>
using namespace std;

int main() {
  
      // Two variables of different type
    int i = 10;
    char c = 'A';
  
      // printing c after manually converting it
      cout << (int)c << endl;
      
      // Adding i and c,
      int sum = i + c;
  
      // Printing sum
      cout << sum;
      
    return 0;
}
65
75

Explanation: The character c = (‘A’) is manually converted to its ASCII integer value using (int)c. The addition of i = 10 and c involves automatic type conversion, where the character c is automatically converted to its ASCII value (65) before the addition. The C++ Course covers the various methods of type conversion, helping you understand how to handle data types correctly.

In C++, there are two types of type conversion:
Implicit Type Conversion

Implicit type conversion (also known as coercion) is the conversion of one type of data to another type automatically by the compiler when needed. It happens automatically when:

    Operations are performed on values of different data types.
    If you pass an argument to a function that expects a different data type.
    Assigning a value of one data type to a variable of another data type.
    
    #include <iostream>
using namespace std;

int main() {
  
    int i = 10;
    char c = 'a';

    // c implicitly converted to int. ASCII
    // value of 'a' is 97
    i = i + c;

    // x is implicitly converted to float
    float f = i + 1.0;

    cout << "i = " << i << endl
         << "c = " << c << endl
         << "f = " << f;

    return 0;
}
i = 107
c = a
f = 108

It is possible for implicit conversions to lose information, signs can be lost (when signed is implicitly converted to unsigned), and overflow can occur (when long long is implicitly converted to float).
Cases of Implicit Type Conversion

1. For Numeric Type

All the data types of the variables are upgraded to the data type of the variable with largest data type. For numeric type,

    bool -> char -> short int -> int ->  unsigned int -> long -> unsigned -> long long -> float -> double -> long double

2. Pointer Conversions

Pointers to derived classes can be converted to pointers to base classes automatically.

3. Boolean Conversion

Any scalar type (integer, floating-point, pointer) is implicitly converted to bool in a context that requires a Boolean value (e.g., if, while, for conditions).
Explicit Type Conversion

Explicit type conversion, also called type casting is the conversion of one type of data to another type manually by a programmer. Here the user can typecast the result to make it of a particular data type. In C++, it can be done by two ways: 
1. C Style Typecasting

This method is inherited by C++ from C. The conversion is done by explicitly defining the required type in front of the expression in parenthesis. This can be also known as forceful casting.

    (type) expression;

where type indicates the data type to which the final result is converted. 
#include <iostream>
using namespace std;

int main() {
    double x = 1.2;

    // Explicit conversion from double to int
    int sum = (int)x + 1;

    cout << sum;

    return 0;
}
2

This typecasting is considered old and unsafe because it performs no checks whatsoever to determine whether the casting is valid or not.
C++ Style Typecasting

C++ introduced its own typecasting method using cast operators. Cast operator is an unary operator which forces one data type to be converted into another data type. C++ supports four types of casting:

    Static Cast: Used for standard compile time type conversions.
    Dynamic Cast: Used for runtime type conversion in polymorphism and inheritance.
    Const Cast: Removes or adds const or volatile qualifiers.
    Reinterpret Cast: Used for low-level reinterpretation of bits (e.g., converting pointers).
    #include <iostream>
using namespace std;

int main() {
    double x = 1.2;

    // Explicit conversion from double to int
    int sum = static_cast<int>(x + 1);

    cout << sum;
    return 0;
}
2

Risks of Type Conversion

Type conversion provides useful functionality to the language but also introduces certain risks:

    Data loss that occurs when converting from a larger type to a smaller type (e.g., int to char).
    Undefined behavior that happens when casting pointers between unrelated types and dereferencing them.
    Violation of const correctness when removing const with const_cast and modifying the variable leads to undefined behavior.
    Memory misalignment casting pointers to types with stricter alignment can cause crashes.
    
    ### **`#include <bits/stdc++.h>` vs. `#include <iostream>` in C++**
Both headers serve different purposes in C++ programming. Let's break it down:

---

## **1️⃣ `#include <bits/stdc++.h>` (All-in-One Header)**
This is a **non-standard header** that includes **almost all** C++ standard libraries at once.  
It is mainly used in **competitive programming** to save time.

### ✅ **Advantages:**
✔ **Includes Everything** – You don’t need to manually `#include` multiple headers like `<vector>`, `<map>`, `<cmath>`, etc.  
✔ **Faster to Write** – Saves time in contests.  
✔ **Reduces Debugging Effort** – No missing header errors.  

### ❌ **Disadvantages:**
❌ **Non-Standard** – It **only works with GCC/Clang**, not in MSVC (Microsoft Visual C++).  
❌ **Increases Compilation Time** – Since it includes **everything**, compiling is slower.  
❌ **Not Recommended for Production Code** – Makes code **less readable** and includes unnecessary libraries.  

### **Example Usage (`bits/stdc++.h`)**
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    vector<int> v = {1, 2, 3};
    cout << "Size: " << v.size() << endl;
    return 0;
}
```
- This works because `<bits/stdc++.h>` automatically includes `<vector>` and `<iostream>`.

---

## **2️⃣ `#include <iostream>` (Standard Library)**
This is a **standard** header file that only includes **input-output functionality**.

### ✅ **Advantages:**
✔ **Standard and Portable** – Works on all compilers.  
✔ **Faster Compilation** – Only includes necessary code.  
✔ **Better for Large Projects** – Keeps dependencies minimal.  

### ❌ **Disadvantages:**
❌ **Requires Manual Inclusion of Other Headers** – If you need vectors, maps, etc., you must include `<vector>`, `<map>`, etc.  

### **Example Usage (`iostream` Only)**
```cpp
#include <iostream>
using namespace std;

int main() {
    cout << "Hello, World!" << endl;
    return 0;
}
```
- This only provides **input/output** (`cin`, `cout`).
- If you need `vector`, `map`, etc., you must manually `#include` them.

---

## **🚀 Which One Should You Use?**
| Feature              | `#include <bits/stdc++.h>` | `#include <iostream>` |
|----------------------|-------------------------|------------------|
| **Compilation Speed** | ❌ Slower | ✅ Faster |
| **Portability**       | ❌ GCC/Clang Only | ✅ Works Everywhere |
| **Readability**      | ❌ Messy | ✅ Clearer |
| **Memory Usage**     | ❌ Higher | ✅ Lower |
| **Use Case**         | ✅ Competitive Programming | ✅ Production & Large Projects |

👉 **Use `#include <bits/stdc++.h>`** in **competitive programming** for speed.  
👉 **Use `#include <iostream>` and proper headers** in **real-world applications** for better performance and maintainability.  

Let me know if you have more questions! 🚀

1. static_cast

The static_cast operator is the most commonly used casting operator in C++. It performs compile-time type conversion and is mainly used for explicit conversions that are considered safe by the compiler. 

Syntax


    static_cast <new_type> (exp);

where,

    exp: Data to be converted.
    new_type: Desired type of expression

The static_cast can be used to convert between related types, such as numeric types or pointers in the same inheritance hierarchy.

Example
#include <bits/stdc++.h>
using namespace std;

int main() {

    int n = 10;

    // converting int to double
    double nd = static_cast<double>(n);

    // printing data type
    cout << typeid(n).name() << endl;

    // typecasting
    cout << typeid(static_cast<double>(n)).name() << endl;

    // Printing double type
    cout << typeid(nd).name();

    return 0;
}

typeid operator in C++ with Examples
Last Updated : 03 Sep, 2021

typeid is an operator in C++. 

    It is used where the dynamic type or runtime type information of an object is needed.
    It is included in the <typeinfo> library. Hence inorder to use typeid, this library should be included in the program.
    The typeid expression is an lvalue expression.

Syntax:  

typeid(type);
OR
typeid(expression);

Parameters: typeid operator accepts a parameter, based on the syntax used in the program:  

    type: This parameter is passed when the runtime type information of a variable or an object is needed. In this, there is no evaluation that needs to be done inside type and simply the type information is to be known.
    expression: This parameter is passed when the runtime type information of an expression is needed. In this, the expression is first evaluated. Then the type information of the final result is then provided.

Return value: This operator provides the runtime type information of the specified parameter and hence that type information is returned, as a reference to an object of class type_info.
Usage: typeid() operator is used in different way according to the operand type. 

    When operand is a variable or an object.
    // C++ program to show the use of typeid operator 

#include <iostream> 
#include <typeinfo> 
using namespace std; 

int main() 
{ 
	int i, j; 
	char c; 

	// Get the type info using typeid operator 
	const type_info& ti1 = typeid(i); 
	const type_info& ti2 = typeid(j); 
	const type_info& ti3 = typeid(c); 

	// Check if both types are same 
	if (ti1 == ti2) 
		cout << "i and j are of"
			<< " similar type" << endl; 
	else
		cout << "i and j are of"
			<< " different type" << endl; 

	// Check if both types are same 
	if (ti2 == ti3) 
		cout << "j and c are of"
			<< " similar type" << endl; 
	else
		cout << "j and c are of"
			<< " different type" << endl; 

	return 0; 
} 

i and j are of similar type
j and c are of different type
// C++ program to show the use of typeid operator 

#include <iostream> 
#include <typeinfo> 
using namespace std; 

int main() 
{ 
	int i = 5; 
	float j = 1.0; 
	char c = 'a'; 

	// Get the type info using typeid operator 
	const type_info& ti1 = typeid(i * j); 
	const type_info& ti2 = typeid(i * c); 
	const type_info& ti3 = typeid(c); 

	// Print the types 
	cout << "ti1 is of type "
		<< ti1.name() << endl; 

	cout << "ti2 is of type "
		<< ti2.name() << endl; 

	cout << "ti3 is of type "
		<< ti3.name() << endl; 

	return 0; 
} 

ti1 is of type f
ti2 is of type i
ti3 is of type c

Explanation: In this example, we have used typeid() operator to check the data type. We have defined an integer variable n and converted it into a double using static_cast. After that, we print the data types of variables and pass static_cast<double>(n) in typeid() to check its data type. we can see the output “i, d, d” is printed where i denotes integer and d denotes double.
1. static_cast

The static_cast operator is the most commonly used casting operator in C++. It performs compile-time type conversion and is mainly used for explicit conversions that are considered safe by the compiler. 

Syntax


    static_cast <new_type> (exp);

where,

    exp: Data to be converted.
    new_type: Desired type of expression

The static_cast can be used to convert between related types, such as numeric types or pointers in the same inheritance hierarchy.
#include <bits/stdc++.h>
using namespace std;

int main() {

    int n = 10;

    // converting int to double
    double nd = static_cast<double>(n);

    // printing data type
    cout << typeid(n).name() << endl;

    // typecasting
    cout << typeid(static_cast<double>(n)).name() << endl;

    // Printing double type
    cout << typeid(nd).name();

    return 0;
}

i
d
d

Explanation: In this example, we have used typeid() operator to check the data type. We have defined an integer variable n and converted it into a double using static_cast. After that, we print the data types of variables and pass static_cast<double>(n) in typeid() to check its data type. we can see the output “i, d, d” is printed where i denotes integer and d denotes double.

2. dynamic_cast - after oops

3. const_cast

The const_cast operator is used to modify the const or volatile qualifier of a variable. It allows programmers to temporarily remove the constancy of an object and make modifications. Caution must be exercised when using const_cast, as modifying a const object can lead to undefined behavior.

Syntax

    const_cast <new_type> (exp);


#include <iostream>
using namespace std;

int main() {

    const int n = 5;
  
    // Pointer to a const int
    const int* ptr = &n;

    // int* nonConstPtr = ptr; if we use this
    // instead of without using const_cast
    // we will get error of invalid conversion
    int* nonConstPtr = const_cast<int*>(ptr);
    *nonConstPtr = 10;

    cout << *nonConstPtr;

    return 0;
}

10

Explanation: In the above example, we have modified the value of the const type pointer by changing its qualifier from const to non-const and then printing the modified value.
4. reinterpret_cast

The reinterpret_cast operator is used to convert the pointer to any other type of pointer. It does not perform any check whether the pointer converted is of the same type or not.

Syntax

    reinterpret_cast <new_type> (exp);


#include <iostream>
using namespace std;

int main() {
    int n = 10;
  
    // Store the address of number in nptr
    int* nptr = &n;

    // Reinterpreting the pointer as a char pointer
    char* charptr = reinterpret_cast<char*>(nptr);

    // Printing the memory addresses and values
    cout << "Integer Address: " << nptr << endl;
    cout << "Char Address: " << charptr;

    return 0;
}
Integer Address: 0x7ffcd595d6fc
Char Address: 0x7ffcd595d6fc

Explanation: In the above example, we have defined an int variable n and then store the address of n in nptr of the int type after that we have converted the nptr of the int type into char pointer and then store it into charptr variable. To verify that we have printed the address of both nptr and charptr. To print the address stored in charptr reinterpret_cast<void*> is used to bypass the type-checking mechanism of C++ and allow the pointer to be printed as a generic memory address without any type-specific interpretation.
    Note: const_cast and reinterpret_cast are generally not recommended as they vulnerable to different kinds of errors.



