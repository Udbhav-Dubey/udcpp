
Writing First C++ Program – Hello World Example
Last Updated : 11 Jan, 2025

The “Hello World” program is the first step towards learning any programming language and is also one of the most straightforward programs you will learn. It is the basic program that is used to demonstrate how the coding process works. All you have to do is display the message “Hello World” on the output screen.
C++ Hello World Program

Below is the C++ program to print “Hello World” on the console screen.
1

// Header file for input output functions

2

#include <iostream>

3

using namespace std;

4

​

5

// main() function: where the execution of

6

// C++ program begins

7

int main() {

8

  

9

    // This statement prints "Hello World"

10

    cout << "Hello World";

11

​

12

    return 0;

13

}

Try it on GfG Practice
redirect icon

Output

Hello World

To write and run C++ programs, you need to set up the local environment on your computer. Refer to the complete article Setting up C++ Development Environment. If you do not want to set up the local environment on your computer, you can also use online IDE to write and run your C++ programs.
Working of Hello World Program in C++

Let us now understand every line and the terminologies of the above program.

    // C++ program to display “Hello World”

This line is a comment line. A comment is used to display additional information about the program. A comment does not contain any programming logic. When a comment is encountered by a compiler, the compiler simply skips that line of code.

    #include <iostream>

The #include is a preprocessor directive tells the compiler to include the content of a file in the source code. For example, #include<iostream> tells the compiler to include the input-output library which contains all C++’s input/output library functions.

    using namespace std

This is used to import the entity of the stdnamespace into the current namespace of the program. It is basically the space where all the inbuilt features of C++ are declared. For example, std::cout.

    int main() { }

The main() function is the entry point of every C++ program, no matter where the function is located in the program. The opening braces ‘{‘ indicates the beginning of the main function and the closing braces ‘}’ indicates the ending of the main function.

    cout<<“Hello World”;

The coutis a tool (object) that is used to display output on the console screen. Everything followed by the character << in double quotes ” ” is displayed on the output screen. The semi-colon character at the end of the statement is used to indicate that the statement is ending there.

    return 0

This statement is used to return a value from a function and indicates the finishing of a function. Here, it is used to sent the signal of successful execution of the main function.

Also, as you can see, the cout and the return statement have been indented or moved to the right side. This is done to make the code more readable. We must always use indentations and comments to make the code more readable. Must read the FAQ on the style of writing programs.


C++ Basic Syntax
Last Updated : 03 Feb, 2025

Syntax refers to the rules and regulations for writing statements in a programming language. They can also be viewed as the grammatical rules defining the structure of a programming language.

The C++ language also has its syntax for the functionalities it provides. Different statements have different syntax specifying their usage, but C++ programs also have basic syntax rules that are followed throughout all the programs.
Basic Syntax of a C++ Program

We can learn about basic C++ Syntax using the following program

// C++ program to demonstrate the basic syntax
// Header File Library
#include <iostream>

// Standard Namespace
using namespace std;

// Main Function
int main()
{

    // Body of the Function

    // Declaration of Variable
    int num1 = 24;
    int num2 = 34;

    int result = num1 + num2;

    // Output
    cout << result << endl;

    // Return Statement
    return 0;
}
58

The program above shows the basic C++ program that contains header files, main function, namespace declaration, etc. Let’s try to understand them one by one.
1. Header File

The header files contain the definition of the functions and macros we are using in our program. In line #1, we used the #include  <iostream> statement to tell the compiler to include an iostream header file library which stores the definition of the cin and cout standard input/output streams that we have used for input and output. #include is a preprocessor directive using which we import header files.
2. Namespace

A namespace in C++ is used to provide a scope or a region where we define identifiers. In line #2, we have used the using namespace std statement for specifying that we will be the standard namespace where all the standard library functions are defined.
3. Main Function

In line #3, we defined the main function as int main(). The main function is the most important part of any C++ program. The program execution always starts from the main function. All the other functions are called from the main function. In C++, the main function is required to return some value indicating the execution status.
4. Blocks

Blocks are the group of statements that are enclosed within { } braces. The body of the main function is from line #4 to line #9 enclosed within  { }.
5. Semicolons

As you may have noticed by now, each statement in the above code is followed by a ( ; ) semicolon symbol. It is used to terminate each line of the statement of the program.
6. Identifiers

We use identifiers for the naming of variables, functions, and other user-defined data types. An identifier may consist of uppercase and lowercase alphabetical characters, underscore, and digits. The first letter must be an underscore or an alphabet.
7. Keywords

In the C++ programming language, there are some reserved words that are used for some special meaning in the C++ program. It can’t be used for identifiers. For example, the words int, return, and using are some keywords used in our program.
8. Basic Output cout

In line #7, we have used the cout stream object (declared in the <iostream> header file) to print the sum of two numbers to the standard output stream (stdout).
Object-Oriented Programming in C++

C++ programming language supports both procedural-oriented and object-oriented programming. The above example is based on the procedural-oriented programming paradigm. So let’s take another example to discuss Object Oriented Programming in C++.
1

#include <iostream>

2

using namespace std;

3

​

4

class Calculate {

5

​

6

    // Access Modifiers

7

public:

8

​

9

    // data member

10

    int num1 = 50;

11

    int num2 = 30;

12

​

13

    // member function

14

    void addition() {

15

        int result = num1 + num2;

16

        cout << result << endl;

17

    }

18

};

19

​

20

int main() {

21

​

22

    // object declaration

23

    Calculate add;

24

    

25

    // member function calling

26

    add.addition();

27

​

28

    return 0;

29

}


Output

80

1. Class

A class is a user-defined data type. A class has its own attributes (data members) and behavior (member functions). In line #3, we have declared a class named Calculate and its body expands from line #3 to line #7.
2. Data Members & Member Functions

The attributes or data in the class are defined by the data members & the functions that work on these data members are called the member functions.

In the above example, num1 and num2 are the data member & addition() is a member function that is working on these two data members. There is a keyword here public that is access modifiers. The access modifier decides who has access to these data members & member functions.
3. Object

The object is an instance of a class. The class itself is just a template that is not allocated any memory. To use the data and methods defined in the class, we have to create an object of that class.

C++ Comments

Single Line Comment

In C++, single line comments are represented as // double forward slash. It applies comments to a single line only. The compiler ignores any text after // and it will not be executed.

Syntax:

    // Single line comment


Multi-Line Comment

A multi-line comment can occupy many lines of code, it starts with /* and ends with */, but it cannot be nested. Any text between /* and */ will be ignored by the compiler.

Syntax:

     /*
         Multiline Comment
         .
         .
         .
     */


Why Comments are used in C++?

Comments in C++ are used to summarize an algorithm, identify a variable’s purpose, or clarify a code segment that appears unclear. Comments are also used for:

    Comments are used for easier debugging.
    It makes a program more readable and gives an overall description of the code.
    Comments are helpful in skipping the execution of some parts of the code.
    Every time a program or code is reused after long periods of time, the comment recaps all the information of the code quickly.
    
    How does the compiler process C++ Comments?

As a part of the compiler, the Lexical Analyzer scans the characters and transforms them into tokens with no passing of the commented text to the parser. Since Comments do not contribute to the functionality of the program they are simply omitted at the time of compilation. Accordingly, we can understand that comments are just text in programs that are ignored by the compiler.

Tokens in C
Last Updated : 21 Jan, 2025

In C programming, tokens are the smallest units in a program that have meaningful representations. Tokens are the building blocks of a C program, and they are recognized by the C compiler to form valid expressions and statements. Tokens can be classified into various categories, each with specific roles in the program.
Types of Tokens in C
Tokens-in-C

The tokens of C language can be classified into six types based on the functions they are used to perform. The types of C tokens are as follows:

Table of Content

    Punctuators
    Keywords
    Strings
    Operators
    Identifiers
    Constants

1. Punctuators

The following special symbols are used in C having some special meaning and thus, cannot be used for some other purpose. Some of these are listed below:

    Brackets[]: Opening and closing brackets are used as array element references. These indicate single and multidimensional subscripts.
    Parentheses(): These special symbols are used to indicate function calls and function parameters.
    Braces{}: These opening and ending curly braces mark the start and end of a block of code containing more than one executable statement.
    Comma (, ): It is used to separate more than one statement like for separating parameters in function calls.
    Colon(:): It is an operator that essentially invokes something called an initialization list.
    Semicolon(;): It is known as a statement terminator.  It indicates the end of one logical entity. That’s why each individual statement must be ended with a semicolon.
    Asterisk (*): It is used to create a pointer variable and for the multiplication of variables.
    Assignment operator(=): It is used to assign values and for logical operation validation.
    Pre-processor (#): The preprocessor is a macro processor that is used automatically by the compiler to transform your program before actual compilation.
    Period (.): Used to access members of a structure or union.
    Tilde(~): Bitwise One’s Complement Operator.

Example:
1

#include <stdio.h>  

2

int main() {

3

  

4

    // '\n' is a special symbol that

5

    // represents a newline

6

    printf("Hello, World!\n");  

7

    return 0;

8

}


Output

Hello, World!

2. Keywords

Keywords are reserved words that have predefined meanings in C. These cannot be used as identifiers (variable names, function names, etc.). Keywords define the structure and behavior of the program C language supports 32 keywords some of them are:

    int, for, if, else, while, return, etc.

Example:
1

#include <stdio.h>  

2

int main() {

3

   

4

    // 'int' is a keyword used to define

5

    // variable type

6

    int x = 5;  

7

    printf("%d", x);

8

  

9

    // 'return' is a keyword used to exit

10

    // main function

11

    return 0;  

12

}


Output

5

    Note: The number of keywords may change depending on the version of C you are using. For example, keywords present in ANSI C are 32 while in C11, it was increased to 44. Moreover, in the latest c23, it is increased to around 54.

3. Strings

Strings are nothing but an array of characters ended with a null character (‘\0’). This null character indicates the end of the string. Strings are always enclosed in double quotes. Whereas a character is enclosed in single quotes in C and C++.

Examples:
1

#include <stdio.h>  

2

int main() {

3

  

4

    // "Hello, World!" is a string literal

5

    char str[] = "Hello, World!";  

6

    printf("%s", str);

7

    return 0;

8

}


Output

Hello, World!

4. Operators

Operators are symbols that trigger an action when applied to C variables and other objects. The data items on which operators act are called operands. 
Depending on the number of operands that an operator can act upon, operators can be classified as follows: 

    Unary Operators: Those operators that require only a single operand to act upon are known as unary operators.For Example increment and decrement operators
    Binary Operators: Those operators that require two operands to act upon are called binary operators. Binary operators can further are classified into: 
        Arithmetic operators
        Relational Operators
        Logical Operators
        Assignment Operators
        Bitwise Operator
    Ternary Operator: The operator that requires three operands to act upon is called the ternary operator. Conditional Operator(?) is also called the ternary operator.

Example:
1

#include <stdio.h>  

2

int main() {

3

    int a = 10, b = 5;  

4

  

5

    // '+' is an arithmetic operator used

6

    // for addition

7

    int sum = a + b;  

8

    printf("%d", sum); 

9

    return 0;

10

}


Output

15

5. Identifiers

Identifiers are names given to variables, functions, arrays, and other user-defined items. They must begin with a letter (a-z, A-Z) or an underscore (_) and can be followed by letters, digits (0-9), and underscores.

Example:
1

#include <stdio.h>  

2

int main() {

3

  

4

    // 'num' is an identifier used to name

5

    // a variable

6

    int num = 10;  

7

    printf("%d", num); 

8

    return 0;

9

}


Output

10

6. Constants

Constants are fixed values used in a C program. These values do not change during the execution of the program. Constants can be integers, floating-point numbers, characters, or strings.

Examples:
1

#include <stdio.h>  

2

int main() {

3

  

4

    // 'MAX_VALUE' is a constant that holds

5

    // a fixed value

6

    const int MAX_VALUE = 100;  

7

    printf("%d", MAX_VALUE);

8

    return 0;

9

}


Output

100


C++ Keywords
Last Updated : 23 Dec, 2024

Keywords are the reserved words that have special meanings in the C++ language. They are the words that the language uses for a specifying the components of the language, such as void, int, public, etc. They can’t be used for a variable name or function name or any other identifiers.

Let’s take a look at the hello world code:
#include <iostream>
using namespace std;

int main() {
  
    cout << "Hello World";
  
    return 0;
}
ello World

Explanation: In the above code, using, namespace, and return are the keywords that are used to implement some functionality of the language. Their meaning is predefined in C++ and will always remain same.

The total number of keywords in C++ are 95 upto C++ 23 specification. Below is the table for all C++ keywords:
alignas	alignof	and	and_eq	asm
auto	bitand	bitor	bool	break
case	catch	char	char8_t	char16_t
char32_t	class	compl	concept	const
consteval	constexpr	constinit	const_cast	continue
co_await	co_return	co_yield	decltype	default
delete	do	double	dynamic_cast	else
enum	explicit	export	extern	false
final	float	for	friend	goto
if	inline	int	long	mutable
namespace	new	noexcept	not	not_eq
nullptr	operator	or	or_eq	private
protected	public	register	reinterpret_cast	requires
return	short	signed	sizeof	static
static_assert	static_cast	struct	switch	template
this	thread_local	throw	true	try
typedef	typeid	typename	union	unsigned
using	virtual	void	volatile	wchar_t
while	xor	xor_eq		
Keywords vs Identifiers

So, there are some properties of keywords that distinguish keywords from identifiers. They listed in the below table
Keywords	 Identifiers
Keywords are predefined/reserved words	 identifiers are the values used to define different programming items like a variable, integers, structures, and unions.
It defines the type of entity.	It classifies the name of the entity.
A keyword contains only alphabetical characters, 	an identifier can consist of alphabetical characters, digits, and underscores.
It should be lowercase.	It can be both upper and lowercase.
No special symbols or punctuations are used in keywords and identifiers. 	No special symbols or punctuations are used in keywords and identifiers.  The only underscore can be used in an identifier.
Example: int, char, while, do.	Example: Geeks_for_Geeks, GFG, Gfg1
ifference between Keyword and Identifier in C
Last Updated : 23 Dec, 2024

In C, keywords and identifiers are basically the fundamental parts of the language used. Identifiers are the names that can be given to a variable, function or other entity while keywords are the reserved words that have predefined meaning in the language.

The below table illustrates the primary differences between the keywords and identifiers:
Parameters	Keywords	Identifiers
Definition	Keywords are predefined word that gets reserved for working program that have special meaning and cannot get used anywhere else.	Identifiers are the values used to define different programming items such as variables, integers, structures, unions and others and mostly have an alphabetic character.
Use	Specify the type/kind of entity.	Identify the name of a particular entity.
	It always starts with a lowercase letter.	First character can be a uppercase, lowercase letter or underscore.
Rules of Definition	A keyword should be in lower case and can only contains alphabetical characters.	An identifier can be in upper case or lower case and can consist of alphabetical characters, digits and underscores.
Purpose	They help to identify a specific property that exists within a computer language.	They help to locate the name of the entity that gets defined along with a keyword.
Examples	int, char, if, while, do, class etc.	Test, count1, high_speed, etc.
Keywords

Keywords are specific reserved words in C each of which has a specific feature associated with it. Almost all of the words which help us use the functionality of the C language are included in the list of keywords. So, you can imagine that the list of keywords is not going to be a small one! There are a total of 32 keywords in C:

auto
	

break
	

case
	

char
	

const
	

continue
	

default
	

do

double
	

else
	

enum
	

extern
	

float
	

for
	

goto
	

if

int
	

long
	

register
	

return
	

short
	

signed
	

sizeof
	

static

struct
	

switch
	

typedef
	

union
	

unsigned
	

void
	

volatile
	

while
Identifiers

Identifiers are used as the general terminology for naming of variables, functions and arrays. These are user defined names consisting of arbitrarily long sequence of letters and digits with either a letter or the underscore(_) as a first character. Identifier names must differ in spelling and case from any keywords. You cannot use keywords as identifiers; they are reserved for special use. Once declared, you can use the identifier in later program statements to refer to the associated value. A special kind of identifier, called a statement label, can be used in goto statements.
Code Illustration

The below example illustrate the different purpose of the keywords and identifers in C:
1

#include <stdio.h>

2

​

3

// 'main' is also an identifier

4

// although it is predefined

5

int main() {

6

  

7

    // Example of a keyword: int

8

      // Here, age is identifier

9

    int age = 25;

10

​

11

    printf("Age: %d\n", age);

12

​

13

    // return is a keyword that exits function

14

    return 0; 

15

}


Output

Age: 25

Explanation: In the above code, age is an identifier used to name a variable. The type of variable is integer that is specified using int keyword as it already is defined in C to indicate that the variable will store integer data.

C++ Variables
Last Updated : 19 Dec, 2024

In C++, variable is a name given to a memory location. It is the basic unit of storage in a program. The value stored in a variable can be accessed or changed during program execution. In this article, we will learn about the variables in C++ and how to use them in our programs.

Let’s take a look at an example:
1

#include <iostream>

2

using namespace std;

3

​

4

int main() {

5

    

6

      // A variable that may store the data of

7

      // int type (whole numbers)

8

    int var;

9

  

10

      // Assigning a whole number

11

      var = 100;

12

  

13

      // Printing the variable

14

      cout << var;

15

  

16

    return 0;

17

}


Output

100

Explanation: A variable with name var is created. It is of the type int (keyword for integer) and can store the whole numbers. In the next step, we assigned a value 100 to it and finally, we access the stored value using the variable’s name.

The C++ Course covers the types of variables in C++ and how to use them effectively in your programs.
Syntax of Variables

Creating a variable and giving it a name is called variable definition. The syntax of variable definition is:

    type name;

Here,

    type: type of data that a variable can store.
    name: name assigned to the variable.

Multiple variables of the same type can be defined as:

    type name1, name2, name3 ….;

Types of Variables

In C++, following are the data types a variable can store:

    int: For storing integers or whole numbers.
    float: For storing real numbers with decimal points.
    char: For storing single characters.
    bool: For storing boolean value i.e. true and false.
    string: For storing the textual data.

Rules For Naming Variable

The names given to a variable is called identifiers. There are some rules for giving a name to the variable:

    The name of the variable contains letters, digits, and underscores.
    The name of the variable is case sensitive (e.g. Arr and arr both are different variables).
    The name of the variable does not contain any whitespace and special characters (ex #, $, %, *, etc).
    All the variable names must begin with a letter of the alphabet or an underscore (_).
    We cannot used C++ keyword (e.g. float, double, class) as a variable name.

Some valid variable names: x, var, _here, arr40
Some invalid variable names: 89, a b, double
Variable Initialization

The next step is initialization. It means assigning an initial value to the variable. It is done by using an assignment operator = with the variable name as left operand and the value as the right operand.

    type name = value;      // At the time of declaration
    name = value;      // After declaration
    type name1 = value1, name2 = value2;      // For multiple variables

The value should be of the same type as variable. For example, a variable declared as int var; should only store the integer variable.
Examples of Variables

The below examples demonstrate how to use the variables in our C++ programs:
Store Data in a Variable and Print It
1

#include <iostream>

2

using namespace std;

3

​

4

int main() {

5

​

6

    // Defining and initializing a variable

7

      int age1 = 15;

8

  

9

      // Defining a variable

10

      int age2;

11

  

12

      // Initialize the variable

13

      age2 = 99;

14

  

15

      // Displaying variable

16

      cout << age1 << endl;

17

      cout << age2;

18

    return 0;

19

}


Output

15
99

Create Multiple Variables at Once
1

#include <iostream>

2

using namespace std;

3

​

4

int main() {

5

  

6

      // Creating three variables that store characters

7

      char a = 'A', b = 'B', c = 'C';

8

  

9

      // Update the value

10

      c = 'c';

11

​

12

    cout << a << " " << b << " " << c;

13

    return 0;

14

}


Output

A B c

Memory Management of Variables

When a variable is declared, the compiler is told about the variable name and the type of data it will store. It is not allocated the any memory at this point. It is when the variable is defined it is allocated the memory. The amount of memory allocated depends upon the type of data that a variable intends to store.

Initially, the variable only stores some garbage value (value that does not mean anything). At the time of initialization, it is assigned some meaningful value that using the assignment operator that is then stored in the memory allocated to the function. So basically, we are manipulating a specific part of memory using the variable name.

At last, the data stored in the allocated memory can be accessed using the variable name.


Scope of Variables in C++
Last Updated : 10 Dec, 2024

In C++, the scope of a variable is the extent in the code upto which the variable can be accessed or worked with. It is the region of the program where the variable is accessible using the name it was declared with.

Let’s take a look at an example

#include <iostream>
using namespace std;

// Declaring first variable
int a = 10;

int main() {

      // Declaring second variable
      int b = 9;

      // Accessing a and b variable in their scope
    cout << a << " " << b;

    return 0;
}
Global Scope

Global scope refers to the region outside any function or a block. The variables declared here are accessible throughout the entire program and are called Global Variables.

Local Scope

The local scope is the region inside the curly braces { }. Variables defined within a function or block are said to be local to those functions or a block and are called local variables. Local variables do not exist outside the block in which they are declared, i.e. they cannot be accessed or used outside that block.
Variable Shadowing

Consider that there is a local variable inside a function with the same name as that of a global variable. If the function tries to access the variable with that name, then which variable will be given precedence? Look at the below program to understand the question:  
1

#include<iostream>

2

using namespace std;

3

​

4

// Global variable

5

int a = 5;

6

​

7

int main() {

8

  

9

    // Local variable with same name as that of

10

      // global variable

11

    int a = 100;

12

  

13

      // Accessing a

14

    cout << a;

15

  

16

      return 0;

17

}


Output

100

Explanation: The variable a declared at the top is global variable and stores the value 5 whereas a declared within main function is local and stores a value 100. When accessed inside the main function, the local a’s value is printed. Also, there is no compilation error. It implies that

        If two variables with same name are defined in different scopes, the compiler allows it and does not show error.
        Whenever there is a local variable defined with same name as that of a global variable, the precedence is given to the local variable. This is called variable shadowing.
        Access Global Variable in Variable Shadowing

The global a is still available in the main function but is shadowed by the local a as it is available everywhere. One may ask if there is any way we can access the global a in the main function.

Yes, C++ allows the users to access global variable with the same name as local variable using scope resolution operator. The below examples show how it is done:
1

#include<iostream>

2

using namespace std;

3

​

4

// Global variable

5

int a = 5;

6

​

7

int main() {

8

  

9

    // Local variable with same name as that of

10

      // global variable

11

    int a = 100;

12

  

13

      // Accessing global a

14

    cout << ::a;

15

  

16

      return 0;

17

}


Output

5
why do we use << in cpp, i was used to = in c during printf
ChatGPT said:
ChatGPT

In C, you use printf for output, which relies on format specifiers:

printf("Hello, %s!\n", "world");

In C++, << is the insertion operator, used with cout for output:

std::cout << "Hello, world!" << std::endl;

Why use << instead of =?

    Operator Overloading: << is overloaded in C++ to work as a stream insertion operator for std::cout. It sends data to the output stream.

    Type Safety: Unlike printf, cout automatically handles different data types without format specifiers.

    Chaining: You can chain multiple insertions easily:

    std::cout << "Number: " << 42 << ", Pi: " << 3.14 << std::endl;

    This avoids dealing with format specifiers like %d or %f.

    Extensibility: You can overload << for custom classes, allowing seamless output formatting.

Would you like a deeper comparison of printf vs. cout in terms of performance or use cases?



Variations of Scopes in C++

Apart from the primary classification of the scopes as global and local, there are few other specialized variations of these scopes that divides the declared variable based on its accessibility and visibility. Following are some common variations of variable scopes in C++.

    Instance Scope
    Static Member Scope
    Namespace Scope

Instance Scope

In C++, instance scope refers to the region inside a class but outside any member function of the class. The variable declared here are called instance variables and are accessible to whole class. They can be accessed by the objects of the class.


#include <iostream>
using namespace std;

class A {
public:
  
      // Instance variable with instance scope i.e. accessible
      // in whole class
    int instanceVar;

    A(int val) {
        instanceVar = val;
    }

    void display() {
        cout << instanceVar << endl;
    }
};

int main() {
  
      // Creates a1 with instanceVar = 10
    A a1(1);
    a1.display();

      // Creates a2 with instanceVar = 20
    A a2(33);
    a2.display();

    return 0;
}
Static Member Scope

The static scope applies to variables and functions declared with the static keyword within the class. These variables are shared across all instances of a class and can be accessed using the class name without creating the instance.

Let’s take a look at an example:
#include <iostream>
using namespace std;

class A {
public:
  
      // Static variable with static scope i.e. accessible
      // in whole class
    static int staticVar;
};

int A::staticVar = 1;

int main() {
  
      // Access static variable
      cout << A::staticVar;

    return 0;
}
1

Namespace Scope

A namespace in C++ is a container that allows users to create a separate scope where the given variables are defined. It is used to avoid name conflicts and group related code together. These variables can be then accessed using their namespace name and scope resolution operator.

For example, the below program creates a variable inside a namespace and access it later using namespace name and scope resolution operator.
#include <iostream>
using namespace std;

namespace N {
      
      // Variable with namespace scope
    int namespaceVar = 10;
}

int main() {
  
      // Access variable using namespace
    cout << N::namespaceVar;  

    return 0;
}
10

Storage Classes in C++ with Examples
Last Updated : 24 Dec, 2024

C++ Storage Classes are used to describe the characteristics of a variable/function. It determines the lifetime, visibility, default value, and storage location which helps us to trace the existence of a particular variable during the runtime of a program. Storage class specifiers are used to specify the storage class for a variable.

C++ provides 6 different storage classes, which are as follows:

Table of Content

    auto Storage Class
    extern Storage Class
    static Storage Class
    register Storage Class
    mutable Storage Class
    thread_local Storage Class

Below is a detailed explanation of each storage class:
1. auto Storage Class

The auto storage class is the default class of all the variables declared inside a block. The auto stands for automatic and all the local variables that are declared in a block automatically belong to this class.

Properties of auto Storage Class Objects

    Scope: Local
    Default Value: Garbage Value
    Memory Location: RAM
    Lifetime: Till the end of its scope

Let’s take a look at an example:

Storage Classes in C++ with Examples
Last Updated : 24 Dec, 2024

C++ Storage Classes are used to describe the characteristics of a variable/function. It determines the lifetime, visibility, default value, and storage location which helps us to trace the existence of a particular variable during the runtime of a program. Storage class specifiers are used to specify the storage class for a variable.

C++ provides 6 different storage classes, which are as follows:

Table of Content

    auto Storage Class
    extern Storage Class
    static Storage Class
    register Storage Class
    mutable Storage Class
    thread_local Storage Class

Below is a detailed explanation of each storage class:
1. auto Storage Class

The auto storage class is the default class of all the variables declared inside a block. The auto stands for automatic and all the local variables that are declared in a block automatically belong to this class.

Properties of auto Storage Class Objects

    Scope: Local
    Default Value: Garbage Value
    Memory Location: RAM
    Lifetime: Till the end of its scope

Let’s take a look at an example:
#include <iostream>
using namespace std;

int main() {

    // Declaring an auto variable
    int a = 32;
    float b = 3.2;
    string c = "GeeksforGeeks";

    // Printing the auto variables
    cout << a << " \n";
    cout << b << " \n";
      cout << c << " \n";

    return 0;
}
32 
3.2 
GeeksforGeeks 

    Note: Earlier in C++, we could use the auto keyword to declare the auto variables explicitly but after C++11, the meaning of auto keyword is changed, and we could no longer use it to define the auto variables.

2. extern Storage Class

The extern storage class simply tells us that the variable is defined elsewhere and not within the same scope (or even source file) where it is used (i.e. external linkage). Basically, the variable is created in a different scope or file and can be used in a different file as well.

A normal global variable can be made extern as well by placing the extern keyword before its declaration/definition in any function/block. The main purpose of using extern variables is that they can be accessed between two different files which are part of a large program.

Properties of extern Storage Class Objects

    Scope: Global
    Default Value: Zero
    Memory Location: RAM
    Lifetime: Till the end of the program.

Let’s take a look at an example:

def.cpp
1

// Defining a global variable with external linkage

2

int var = 10;


#include <iostream>
using namespace std;

// Telling compiler that variable x is extern variable
// and has been defined elsewhere
extern int x;

int main() {
  
      // Printing the value of x
    cout << x;

    return 0;
}
10

3. static Storage Class

The static storage class is used to declare static variables that have the property of preserving their value even after they are out of their scope. They are initialized only once and exist until the termination of the program. Thus, no new memory is allocated because they are not re-declared. Global static variables can be accessed anywhere in the program but unlike extern variable, they have internal linkage so they cannot be accessed outside the program.

They are declared using static keyword.

Properties of static Storage Class

    Scope: Local
    Default Value: Zero
    Memory Location: RAM
    Lifetime: Till the end of the program
    
    #include <iostream>
using namespace std;

// Function containing static variables
// memory is retained during execution
int func() {
  
      // Static variable
    static int count = 0;
    count++;
    return count;
}

int main() {
    cout << func() << "\n";
    cout << func();
    
    return 0;
}
4. register Storage Class

The register storage class declares register variables using the register keyword which has the same functionality as that of the auto variables. The only difference is that the compiler tries to store these variables in the register of the microprocessor if a free register is available. This makes the use of register variables to be much faster than that of the variables stored in the memory during the runtime of the program. If a free register is not available, these are then stored in the RAM.

An important and interesting point to be noted here is that we cannot obtain the address of a register variable using pointers.

Properties of register Storage Class Objects

    Scope: Local
    Default Value: Garbage Value
    Memory Location: Register in CPU or RAM
    Lifetime: Till the end of its scope
    
    #include <iostream>
using namespace std;

int main() {

    // Declaring a register variable
    register char b = 'G';

    // Printing the register variable 'b'
    cout << b;
  
    return 0;
}
G

    Note: The register keyword is deprecated in C++17 onwards.

5. mutable Storage Class

Sometimes there is a requirement to modify one or more data members of class/struct through the const function even though you don’t want the function to update other members of class/struct. This task can be easily performed by using the mutable keyword. The keyword mutable is mainly used to allow a particular data member of a const object to be modified. 

When we declare a function as const, this pointer passed to the function becomes const. Adding a mutable to a variable allows a const pointer to change members.
Properties of mutable Storage Class

The mutable specifier does not affect the linkage or lifetime of the object. It will be the same as the normal object declared in that place.

Let’s take a look at an example:
#include <iostream>
using namespace std;

class A {
public:
    int x;

    // Defining mutable variable y
    // now this can be modified
    mutable int y;

    A(): x(4), y(10) {}
};

int main() {
  
    // a is created as constant
    const A a;

    // Trying to change the value
    a.y = 200;
    cout << a.y;

    // Uncommenting below lines
    // will throw error
    /* a.x = 8;
    cout << a.x; */
  
    return 0;
}
200

6. thread_local Storage Class

The thread_local Storage Class is the new storage class that was added in C++11. We can use the thread_local storage class specifier to define the object as thread_local. The thread_local variable can be combined with other storage specifiers like static or extern and the properties of the thread_local object changes accordingly.

Properties of thread_local Storage Class

    Memory Location: RAM
    Lifetime: Till the end of its thread
    #include <iostream>
#include <mutex>
#include <thread>

using namespace std;

// Defining thread-local variable
thread_local int val = 10;

// Mutex for synchronization
mutex mtx;

int main() {
  
    // Created 3 threads
    // Modify value in thread 1
    thread th1([]() {
        val += 18;
        lock_guard<mutex> lock(mtx);
        cout << "Thread 1 value: " << val << '\n';
    });

    thread th2([]() {
      
        // Modify value in thread 2
        val += 7;
        lock_guard<mutex> lock(mtx);
        cout << "Thread 2 value: " << val << '\n';
    });

    thread th3([]() {
      
        // Modify value in thread 3
        val += 13;
        lock_guard<mutex> lock(mtx);
        cout << "Thread 3 value: " << val << '\n';
    });

    // Wait for all threads to finish
    th1.join();
    th2.join();
    th3.join();

    // Print the value of value in the main thread
    cout << "Main thread value: " << val << '\n';

    return 0;
}
Thread 1 value Value: 28
Thread 2 value Value: 17
Thread 3 value Value: 23
Main thread value Value: 10

As we can see, each thread got its own copy of the thread_local variable and was only assigned the value that was specified in its callable.
Summary

The below table summarize the above storage classes:
2. extern Storage Class

The extern storage class simply tells us that the variable is defined elsewhere and not within the same scope (or even source file) where it is used (i.e. external linkage). Basically, the variable is created in a different scope or file and can be used in a different file as well.

A normal global variable can be made extern as well by placing the extern keyword before its declaration/definition in any function/block. The main purpose of using extern variables is that they can be accessed between two different files which are part of a large program.

Properties of extern Storage Class Objects

    Scope: Global
    Default Value: Zero
    Memory Location: RAM
    Lifetime: Till the end of the program.

Let’s take a look at an example:
// Defining a global variable with external linkage
int var = 10;
#include <iostream>
#include >
using namespace std;

// Telling compiler that variable x is extern variable
// and has been defined elsewhere
extern int x;

int main() {
  
      // Printing the value of x
    cout << x;

    return 0;
}


Static Keyword in C++
Last Updated : 11 Jan, 2025

The static keyword in C++ has different meanings when used with different types. In this article, we will learn about the static keyword in C++ along with its various uses.

In C++, a static keyword can be used in the following context:

Table of Content

    Static Variables in a Function
    Static Member Variable in a Class
    Static Member Functions in a Class
    Global Static Variable

Static Variables in a Function

In a function, when a variable is declared as static, space for it gets allocated for the lifetime of the program. Even if the function is called multiple times, space for the static variable is allocated only once and the value of the variable in the previous call gets carried through the next function call.

Let’s take a look at an example:
	
	You can see in the above program that the variable count is declared static. So, its value is carried through the function calls. The variable count is not getting initialized every time the function is called. As a side note, Java doesn’t allow static local variables in functions.

Applications

The static variables in a function have the following applications:

    Return local variable address from the function.
    Useful for implementing coroutines in C++ or any other application where the previous state of function needs to be stored.
    Memoization in recursive calls.
    
    Static Data Member in a Class

As the variables declared as static are initialized only once as they are allocated space in separate static storage so, the static member variables in a class are shared by the objects. There cannot be multiple copies of the same static variables for different objects. Also because of this reason static variables cannot be initialized using constructors.
undefined reference to `GfG::i'
collect2: error: ld returned 1 exit status

Explanation: You can see in the above program that we have tried to create multiple copies of the static variable i for multiple objects. But this didn’t happen.

So, a static variable inside a class should be initialized explicitly by the user using the class name and scope resolution operator outside the class as shown below: 

Let’s take a look at an example:

#include <iostream>
using namespace std;

class GfG {
public:
  
      // Static data member
    static int i;

    GfG(){
        // Do nothing
    };
};

int main() {
    GfG obj1;
    GfG obj2;
    obj1.i = 2;
    obj2.i = 3;

    // Prints value of i
    cout << obj1.i << " " << obj2.i;
}
		
		
		#include <iostream>
using namespace std;

class GfG {
public:
  
      // Static data member
    static int i;

    GfG(){
        // Do nothing
    };
};

// Static member inintialization
int GfG::i = 1;

int main() {
  
    // Prints value of i
    cout << GfG::i;
}
1

Explanation: We were able to access the static variable when is was initialized globally outside the class. Moreover, we can access the static data member without creating the object of the class.

Applications

The static data members can be used to implement the following:

    Counting Objects of a Class
    Store and share configuration or settings globally.
    Tracking Shared Resources
    Regulate or limit operations performed by multiple objects.
    Ensure a class has only one instance by using static members.


Static Member Functions in a Class

Just like the static data members or static variables inside the class, static member functions also do not depend on the object of the class. We are allowed to invoke a static member function using the object and the ‘.’ operator but it is recommended to invoke the static members using the class name and the scope resolution operator. Static member functions are allowed to access only the static data members or other static member functions, they cannot access the non-static data members or member functions of the class. 

Let’s take a look at an example:
1

#include <iostream>

2

using namespace std;

3

​

4

class GfG {

5

public:

6

  

7

    // Static member function

8

    static void printMsg() { cout << "Welcome to GfG!"; }

9

};

10

​

11

int main() {

12

  

13

    // Invoking a static member function

14

    GfG::printMsg();

15

}


Output

Welcome to GfG!
Applications

The static member functions have the following uses in C++:

    Accessing Static Member Variables
    Implement helper functions that do not depend on specific instances.
    Singleton Pattern Implementation
    Factory Methods to create and return objects without requiring an instance of the class.
    Logging and Debugging

Global Static Variable

A global static variable in C++ is a static variable declared outside of any class or function. Unlike regular global variables, a global static variable has internal linkage, meaning it is accessible only within the file where it is defined. This ensures that its scope is limited to the current translation unit, preventing conflicts with variables in other files that may have the same name.

Let’s take a look at an example:
1

#include <iostream>

2

using namespace std;

3

​

4

// Global static variable

5

static int count = 0;

6

​

7

void increment() {

8

    count++;

9

    cout << count << " ";

10

}

11

​

12

int main() {

13

    increment();

14

    increment();

15

    return 0;

16

}


Output

1 2 

Applications

The global static variables have the following uses in C++:

    Limiting variable scope to a file to prevent conflicts by ensuring the variable is accessible only within the file.
    Global counters or flags.
    Store settings or values that are specific to the functionality implemented in a single file.
    Use for shared resources in scenarios where frequent initialization and destruction can be avoided.
    Shared state across functions in a file.
    	
    DAta types
    	
    	
    	n C++, data types are classified into the following types:

S. No.
	Type	Description	Data Types

1
	Basic Data Types	Built-in or primitive data types that are used to store simple values.	int, float, double, char, bool, void

2
	Derived Data Types	Data types derived from basic types.	array, pointer, reference, function

3

	User Defined Data Types	Custom data types created by the programmer according to their need.	class, struct, union, typedef, using
	
	
1. Character Data Type (char)

The character data type is used to store a single character. The keyword used to define a character is char. Its size is 1 byte and it stores characters enclosed in single quotes (‘ ‘). It can generally store upto 256 characters according to their ASCII codes.

Syntax

    char name;



	#include <iostream>
using namespace std;

int main() {
  
      // Character variable
      char c = 'A';  
    cout << c;
  
    return 0;
}

2. Integer Data Type (int)

Integer data type denotes that the given variable can store the integer numbers. The keyword used to define integers is int. Its size is 4-bytes (for 64-bit) systems and can store numbers for binary, octal, decimal and hexadecimal base systems in the range from -2,147,483,648 to 2,147,483,647.

2. Integer Data Type (int)

Integer data type denotes that the given variable can store the integer numbers. The keyword used to define integers is int. Its size is 4-bytes (for 64-bit) systems and can store numbers for binary, octal, decimal and hexadecimal base systems in the range from -2,147,483,648 to 2,147,483,647
    int name;

where, name is the identifier assigned to the variable.
#include <iostream>
using namespace std;

int main() {

      // Creating an integer variable
    int x = 25;
    cout << x << endl;
  
      // Using hexadecimal base value
      x = 0x15;
      cout << x;

    return 0;
}
3. Boolean Data Type (bool)

The boolean data type is used to store logical values: true(1) or false(0). The keyword used to define a boolean variable is bool. Its size is 1 byte.

Syntax

    bool name;

where name is the identifier assigned to the variable.

Example
#include <iostream>
using namespace std;

int main() {
  
      // Creating a boolean variable
    bool isTrue = true;  
    cout << isTrue;
    return 0;
}
1

4. Floating Point Data Type (float)

Floating-point data type is used to store numbers with decimal points. The keyword used to define floating-point numbers is float. Its size is 4 bytes (on 64-bit systems) and can store values in the range from 1.2E-38 to 3.4e+38.

Syntax

    float name;


#include <iostream>
using namespace std;

int main() {
  
      // Floating point variable with a decimal value
      float f = 36.5;
      cout << f;
  
    return 0;
}
5. Double Data Type (double)

The double data type is used to store decimal numbers with higher precision. The keyword used to define double-precision floating-point numbers is double. Its size is 8 bytes (on 64-bit systems) and can store the values in the range from 1.7e-308 to 1.7e+308

Syntax
double name;

#include <iostream>
using namespace std;

int main() {
  
      // double precision floating point variable
      double pi = 3.1415926535;
      cout << pi;
  
    return 0;
}
3.14159

6. Void Data Type (void)

The void data type represents the absence of value. We cannot create a variable of void type. It is used for pointer and functions that do not return any value using the keyword void.
    void functionName();


#include <iostream>
using namespace std;

// Function with void return type
void hello() {
    cout << "Hello, World!" << endl;
}

int main() {
      hello();
    return 0;
}
Hello, World!

Size of Data Types in C++

Earlier, we mentioned that the size of the data types is according to the 64-bit systems. Does it mean that the size of C++ data types is different for different computers?

Actually, it is partially true. The size of C++ data types can vary across different systems, depending on the architecture of the computer (e.g., 32-bit vs. 64-bit systems) and the compiler being used. But if the architecture of the computer is same, then the size across different computers remains same.

We can find the size of the data type using sizeof operator.
#include <iostream>
using namespace std;

int main() {

    // Printing the size of each data type
    cout << "Size of int: " << sizeof(int) << " bytes" << endl;
    cout << "Size of char: " << sizeof(char) << " byte" << endl;
    cout << "Size of float: " << sizeof(float) << " bytes" << endl;
    cout << "Size of double: " << sizeof(double) << " bytes";

    return 0;
}
Size of int: 4 bytes
Size of char: 1 byte
Size of float: 4 bytes
Size of double: 8 bytes

Data Type Modifiers

Data type modifiers are the keywords used to change or give extra meaning to already existing data types. It is added to primitive data types as a prefix to modify their size or range of data they can store. There are 4 type modifiers in C++: short, long, signed and unsigned.

For Example,

Defining an int with long type modifier will change its size to 8 bytes:

    int => 4 bytes
    long int => 8 bytes

Similarly, other type modifiers also affect the size or range of the data type.

    long double, long long int, unsigned int, etc.

Data Types in C++ – FAQs
Is size of data types in C++ is different for different machines?

    Partially yes as the size of data types in C++ can vary across different machines depending on the system architecture (32-bit or 64-bit). But if the architecture is same, then size remains same.

Can I convert one data type value or variable to another?

    Yes, in C++, you can convert one data type to another using type casting. 

How many data types are there in C++?

    There are following number of data types in C++:

        Primitive Data Types: 6
        Derived Data Types: 4
        User Defined Data Types: 5

Why we need int if we can already represent integer values with float?

    int is more efficient for representing whole numbers as it avoids the rounding errors inherent in float allows for fast integer-specific operations like bitwise manipulation
    
Literals in C
Last Updated : 21 Jun, 2024

In C, Literals are the constant values that are assigned to the variables. Literals represent fixed values that cannot be modified. Literals contain memory but they do not have references as variables. Generally, both terms, constants, and literals are used interchangeably. 
For example, “const int = 5;“, is a constant expression and the value 5 is referred to as a constant integer literal.
Types of C Literals

There are 4 types of literal in C:

    Integer Literal
    Float Literal
    Character Literal
    String Literal


C-literals
1. Integer Literals

Integer literals are used to represent and store the integer values only. Integer literals are expressed in two types i.e.

A) Prefixes: The Prefix of the integer literal indicates the base in which it is to be read.
For Example:

    0x10 = 16

    Because 0x prefix represents a HexaDecimal base. So 10 in HexaDecimal is 16 in Decimal. Hence the value 16.

There are basically represented into 4 types:

a. Decimal-literal(base 10): A non-zero decimal digit followed by zero or more decimal digits(0, 1, 2, 3, 4, 5, 6, 7, 8, 9).

Example:

56, 78

b. Octal-literal(base 8): a 0 followed by zero or more octal digits(0, 1, 2, 3, 4, 5, 6, 7).

Example:

045, 076, 06210

c. Hex-literal(base 16): 0x or 0X followed by one or more hexadecimal digits(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, a, A, b, B, c, C, d, D, e, E, f, F).

Example:

0x23A, 0Xb4C, 0xFEA

d. Binary-literal(base 2): 0b or 0B followed by one or more binary digits(0, 1).

Example:

0b101, 0B111

B) Suffixes: The Suffixes of the integer literal indicates the type in which it is to be read.

For example:

    12345678901234LL 

    indicates a long long integer value 12345678901234 because of the suffix LL

These are represented in many ways according to their data types.

    int: No suffix is required because integer constant is by default assigned as an int data type.
    unsigned int: character u or U at the end of an integer constant.
    long int: character l or L at the end of an integer constant.
    unsigned long int: character ul or UL at the end of an integer constant.
    long long int: character ll or LL at the end of an integer constant.
    unsigned long long int: character ull or ULL at the end of an integer constant.

Example:
1

#include <stdio.h>

2

​

3

int main()

4

{

5

​

6

    // constant integer literal

7

    const int intVal = 10;

8

​

9

    printf("Integer Literal:%d \n", intVal);

10

    return 0;

11

}


Output

Integer Literal:10 

2. Floating-Point Literals

These are used to represent and store real numbers. The real number has an integer part, real part, fractional part, and exponential part. The floating-point literals can be stored either in decimal form or exponential form. While representing the floating-point decimals one must keep two things in mind to produce valid literal:

    In the decimal form, one must include the integer part, or fractional part, or both, otherwise, it will lead to an error.
    In the exponential form, one must include both the significand and exponent part, otherwise, it will lead to an error.

A few floating-point literal representations are shown below:

Valid Floating Literals:

10.125
1.215e-10L
10.5E-3

Invalid Floating Literals:

123E
1250f
0.e879

Example:
1

#include <stdio.h>

2

​

3

int main()

4

{

5

    // constant float literal

6

    const float floatVal = 4.14;

7

​

8

    printf("Floating point literal: %.2f\n",

9

        floatVal);

10

    return 0;

11

}


Output

Floating point literal: 4.14

3. Character Literals

This refers to the literal that is used to store a single character within a single quote. To store multiple characters, one needs to use a character array. Storing more than one character within a single quote will throw a warning and display just the last character of the literal. It gives rise to the following two representations:

    char type: This is used to store normal character literal or narrow-character literals. 

Example:

char chr = 'G';

Example:
1

#include <stdio.h>

2

​

3

int main()

4

{

5

    // constant char literal

6

    const char charVal = 'A';

7

​

8

    printf("Character Literal: %c\n",

9

        charVal);

10

    return 0;

11

}


Output

Character Literal: A


Escape Sequences: There are various special characters that one can use to perform various operations.
4. String Literals

String literals are similar to that character literals, except that they can store multiple characters and uses a double quote to store the same. It can also accommodate the special characters and escape sequences mentioned in the table above. We can break a long line into multiple lines using string literal and can separate them with the help of white spaces.
Example:

char stringVal[] = "GeeksforGeeks";

Example:
1

#include <stdio.h>

2

​

3

int main()

4

{

5

    const char str[]

6

        = "Welcome\nTo\nGeeks\tFor\tGeeks";

7

    printf("%s", str);

8

    return 0;

9

}


Output

Welcome
To
Geeks    For    Geeks
Derived Data Types in C++
Last Updated : 18 Dec, 2024

The data types that are derived from the primitive or built-in datatypes are referred to as Derived Data Types. They are generally the data types that are created from the primitive data types and provide some additional functionality.

In C++, there are four different derived data types:

Table of Content

    Functions
    Arrays
    Pointers
    References
    
    
User Defined Data Types in C++
Last Updated : 16 Jan, 2025

User defined data types are those data types that are defined by the user himself. In C++, these data types allow programmers to extend the basic data types provided and create new types that are more suited to their specific needs. C++ supports 5 user-defined data types:

Table of Content

    Class
    Structure
    Union
    Enumeration
    Typedef

Let’s take a look at each of them one by one.
1. Class

A Class is the building block of C++’s Object-Oriented programming paradigm. It is a user-defined data type, which holds its own data members and member functions, which can be accessed and used by creating an instance of that class. A class is like a blueprint for an object.
#include <bits/stdc++.h>
using namespace std;

class GfG {
  
    // Access specifier
public:
  
    // Data Member
    string name;

    // Member Function
    void printname() {
        cout << name;
    }
};

int main() {

    // Declare an object of class geeks
    GfG g;

    // Accessing data member
    g.name = "GeeksForGeeks";

    // Accessing member function
    g.printname();

    return 0;
}
Explanation: The above program defines a class named GfG with a name attribute and a function printname() to print the name. In the main function, it creates an object named g, sets the geekname as “GeeksforGeeks“, and calls the printname() function to display it.
2. Structure

A Structure is a user-defined data type like class. A structure creates a data type that can be used to group items of possibly different types into a single type.

3. Union

Like structures , union is also user-defined data type used to group data of different type into a single type. But in union, all members share the same memory location.
Explanation: The above program demonstrates the use of unions. Union named A with members i and c is defined that shares the same memory space. It is shown that when we only assign c some value, the i also stores the same value.
4. Enumeration

Enumeration (or enum) is a user-defined data type in C++ mainly used to assign names to integral constants, the names make a program easy to read and maintain.
5. Typedef and Using

C++ allows you to define explicitly new data type names by using the keywords typedef or using. They do not create a new data class, rather, defines a name for an existing type. This can increase the portability (the ability of a program to be used across different types of machines; i.e., mini, mainframe, micro, etc; without many changes to the code) of a program as only the typedef statements would have to be changed.

Data Type Ranges and Their Macros in C++
Last Updated : 18 Dec, 2024

Most of the times, in competitive programming, there is a need to assign the variable, the maximum or minimum value that data type can hold but remembering such a large and precise number comes out to be a difficult job. Therefore, C++ has certain macros to represent these numbers, so that these can be directly assigned to the variable without actually typing the whole number.

The <climits> header file in C++ defines macros that represent the upper and lower bounds of integer data types and <cfloat> defines the macros for float and double limits. These macros allow you to easily assign these extreme values to variables without manually typing them out.

Let’s take a look at an example:
#include <iostream>

// for int, char macros
#include <climits>

// for float, double macros
#include <cfloat>

using namespace std;

int main() {
  
    // Displaying ranges with the help of macros
    cout << "char ranges from: " << CHAR_MIN << " to "
         << CHAR_MAX << endl;

    cout << "\nnshort int ranges from: " << SHRT_MIN
         << " to " << SHRT_MAX << endl;
    cout << "\nint ranges from: " << INT_MIN << " to "
         << INT_MAX << endl;
    cout << "\nlong int ranges from: " << LONG_MIN << " to "
         << LONG_MAX << endl;
    cout << "\nfloat ranges from: " << FLT_MIN << " to "
         << FLT_MAX << endl;

    return 0;
}
Output

char ranges from: -128 to 127

nshort int ranges from: -32768 to 32767

int ranges from: -2147483648 to 2147483647

long int ranges from: -9223372036854775808 to 9223372036854775807

float ranges from: 1.17549e-38 to 3.40282e+38
Data Types and Their Range Macros

A list of some of the data type macros is mentioned below:

Data Type
	

Range
	

Macro for min value
	

Macro for max value

char
	

-128 to +127
	

CHAR_MIN
	

CHAR_MAX

short char
	

-128 to +127
	

SCHAR_MIN
	

SCHAR_MAX

unsigned char
	

0 to 255
	

—
	

UCHAR_MAX

short int
	

-32768 to +32767
	

SHRT_MIN
	

SHRT_MAX

unsigned short int
	

0 to 65535
	

—
	

USHRT_MAX

int
	

-2147483648 to +2147483647
	

INT_MIN
	

INT_MAX

unsigned int
	

0 to 4294967295
	

—
	

UINT_MAX

long int
	

-9223372036854775808 to +9223372036854775807
	

LONG_MIN
	

LONG_MAX

unsigned long int
	

0 to 18446744073709551615
	

—
	

ULONG_MAX

long long int
	

-9223372036854775808 to +9223372036854775807
	

LLONG_MIN
	

LLONG_MAX

unsigned long long int
	

0 to 18446744073709551615
	

—
	

ULLONG_MAX

float
	

1.17549e-38 to 3.40282e+38
	

FLT_MIN
	

FLT_MAX

float (negative)
	

-1.17549e-38 to -3.40282e+38
	

-FLT_MIN
	

-FLT_MAX

double
	

2.22507e-308 to 1.79769e+308
	

DBL_MIN
	

DBL_MAX

double (negative)
	

-2.22507e-308 to -1.79769e+308
	

-DBL_MIN
	

-DBL_MAX
Data Type Limits in Modern C++

The above macro approach for the upper and lower limits of the data type is the old C language approach inherited by C++. But C++ also have its own method to provide programmers with the same information.

C++ offers the numeric_limits<> class template as a modern alternative to these macros. This template provides a more object-oriented approach for accessing data type limits. It is defined inside the <limits> header file.

Let’s take a look at an example:
#include <iostream>
#include <limits>
using namespace std;

int main() {
  
    // Displaying ranges with the help of macros
    cout << "short int ranges from: " << numeric_limits<short int>::min()
         << " to " << numeric_limits<short int>::max() << endl;
    cout << "\nint ranges from: " << numeric_limits<int>::min() << " to "
         << numeric_limits<int>::max() << endl;
    cout << "\nlong int ranges from: " << numeric_limits<long>::min() << " to "
         << numeric_limits<long>::max() << endl;
    cout << "\nfloat ranges from: " << numeric_limits<float>::min() << " to "
         << numeric_limits<float>::max() << endl;

    return 0;
}
short int ranges from: -32768 to 32767

int ranges from: -2147483648 to 2147483647

long int ranges from: -9223372036854775808 to 9223372036854775807

float ranges from: 1.17549e-38 to 3.40282e+38
.
Data Types and Their Range Macros

A list of some of the data type macros is mentioned below:

Data Type
	

Range
	

Macro for min value
	

Macro for max value

char
	

-128 to +127
	

CHAR_MIN
	

CHAR_MAX

short char
	

-128 to +127
	

SCHAR_MIN
	

SCHAR_MAX

unsigned char
	

0 to 255
	

—
	

UCHAR_MAX

short int
	

-32768 to +32767
	

SHRT_MIN
	

SHRT_MAX

unsigned short int
	

0 to 65535
	

—
	

USHRT_MAX

int
	

-2147483648 to +2147483647
	

INT_MIN
	

INT_MAX

unsigned int
	

0 to 4294967295
	

—
	

UINT_MAX

long int
	

-9223372036854775808 to +9223372036854775807
	

LONG_MIN
	

LONG_MAX

unsigned long int
	

0 to 18446744073709551615
	

—
	

ULONG_MAX

long long int
	

-9223372036854775808 to +9223372036854775807
	

LLONG_MIN
	

LLONG_MAX

unsigned long long int
	

0 to 18446744073709551615
	

—
	

ULLONG_MAX

float
	

1.17549e-38 to 3.40282e+38
	

FLT_MIN
	

FLT_MAX

float (negative)
	

-1.17549e-38 to -3.40282e+38
	

-FLT_MIN
	

-FLT_MAX

double
	

2.22507e-308 to 1.79769e+308
	

DBL_MIN
	

DBL_MAX

double (negative)
	

-2.22507e-308 to -1.79769e+308
	

-DBL_MIN
	

-DBL_MAX 


Data Type Limits in Modern C++

The above macro approach for the upper and lower limits of the data type is the old C language approach inherited by C++. But C++ also have its own method to provide programmers with the same information.

C++ offers the numeric_limits<> class template as a modern alternative to these macros. This template provides a more object-oriented approach for accessing data type limits. It is defined inside the <limits> header file.

Let’s take a look at an example:
#include <iostream>
#include <limits>
using namespace std;

int main() {
  
    // Displaying ranges with the help of macros
    cout << "short int ranges from: " << numeric_limits<short int>::min()
         << " to " << numeric_limits<short int>::max() << endl;
    cout << "\nint ranges from: " << numeric_limits<int>::min() << " to "
         << numeric_limits<int>::max() << endl;
    cout << "\nlong int ranges from: " << numeric_limits<long>::min() << " to "
         << numeric_limits<long>::max() << endl;
    cout << "\nfloat ranges from: " << numeric_limits<float>::min() << " to "
         << numeric_limits<float>::max() << endl;

    return 0;
}
short int ranges from: -32768 to 32767

int ranges from: -2147483648 to 2147483647

long int ranges from: -9223372036854775808 to 9223372036854775807

float ranges from: 1.17549e-38 to 3.40282e+38

It is recommended to use this approach to find the upper and lower limits of the data type instead of macros as it is more type safe, and readable compared to the macro-based approach.




C++ Type Modifiers
Last Updated : 30 Dec, 2024

In C++, type modifiers are the keywords used to change or give extra meaning to already existing data types. It is added to primitive data types as a prefix to modify their size or range of data they can store.

C++ have 4 type modifiers which are as follows:

Let’s understand at each of them one by one.
1. signed Modifier

The signed modifier indicates that the given variable variables can store both positive and negative values. To specify any variable as signed, just add the keyword signed at the start of the variable declaration.

Syntax

    signed type name;


#include <iostream>
using namespace std;

int main() {
  
      // Printing the size of normal and signed int
      cout << "signed int size: " << sizeof(signed int)
          << " bytes" << endl;
    cout << "int size: " << sizeof(int) << " bytes";

    return 0;
}
signed int's size: 4 bytes
int's size: 4 bytes

    Note: The int datatype is signed by default. So, int can directly be used instead of signed int.


2. unsigned Modifier

The unsigned modifier indicates that the given variables can store only non-negative integer values. Like signed modifier, it is also added at the start of the variable declaration to define the given variable as unsigned.

Syntax

    unsigned type name;

Unsigned modifier can only be used with integer and character data types.

2. unsigned Modifier

The unsigned modifier indicates that the given variables can store only non-negative integer values. Like signed modifier, it is also added at the start of the variable declaration to define the given variable as unsigned.

Syntax

    unsigned type name;

Unsigned modifier can only be used with integer and character data types.
As we can see, when we assigned some negative value to unsigned integer, the value gets converted to its 2’s complement because unsigned types cannot store the negative values.
3. short Modifier

The short keyword decreases the size of the data type in the memory. It leads to the decrease in the range of value that the given data type can store. A variable can be declared as short by adding the short keyword before the variable declaration.

Syntax

    short type name;

#include <iostream>
using namespace std;

int main() {
  
      // Printing the size of short and normal ints
    cout << "short int size: " << sizeof(short int)
          << " bytes" << endl;
      cout << "int size: " << sizeof(int)
          << " bytes";
    return 0;
}
4. long Modifier

The long keyword increases the size of the data type in memory. It leads to increase in the range of value that the given data type can store. A variable can be declared as long by adding the long keyword before the variable declaration.

Syntax

    long type name;

The long modifier can be used with integer and double data type. It can also be used twice on integers.

Example:
1

#include <iostream>

2

using namespace std;

3

​

4

int main() {

5

  

6

      // Printing the size of long and normal ints

7

      // double and long double

8

    cout << "int size: " << sizeof(int)

9

          << " bytes" << endl;

10

      cout << "long int size: " << sizeof(long int)

11

          << " bytes" << endl;

12

      cout << "double size: " << sizeof(double)

13

          << " bytes" << endl;

14

      cout << "long double size: " << sizeof(long double)

15

          << " bytes";

16

    return 0;

17

}
int size: 4 bytes
long int size: 8 bytes
double size: 8 bytes
long double size: 16 bytes

    Note: The long int can be written as long also. They are equivalent.


Size and Range of Data Types with Modifiers

The below table lists the size and the range of data type (in 64-bit compiler) that is changed with the help of modifiers:
Data Type	Modifiers	Size (bytes)	Range
char	signed	1	-128 to 127
unsigned (default)	1	0 to 255
short int	signed (default)	2	-32,768 to 32,767
unsigned	2	0 to 65,535
int	signed (default)	4	-2,147,483,648 to 2,147,483,647
unsigned	4	0 to 4,294,967,295
long int	signed (default)	8	-9,223,372,036,854,775,808 to 9,223,372,036,854,775,807
unsigned	8	0 to 18,446,744,073,709,551,615
long long int	signed (default)	8	-9,223,372,036,854,775,808 to 9,223,372,036,854,775,807
unsigned	8	0 to 18,446,744,073,709,551,615
double	None	8	~1.7E-308 to 1.7E+308
long double	None	16	Higher precision, range varies depending on implementatio

The short keyword can only be used with integer data type.
    Note: The short int can be written as short also. They are equivalent.


Type Conversion in C++
Last Updated : 30 Dec, 2024

Type conversion means converting one type of data to another compatible type such that it doesn’t lose its meaning. It is essential for managing different data types in C++.

Let’s take a look at an example:
#include <iostream>
using namespace std;

int main() {
  
      // Two variables of different type
    int i = 10;
    char c = 'A';
  
      // printing c after manually converting it
      cout << (int)c << endl;
      
      // Adding i and c,
      int sum = i + c;
  
      // Printing sum
      cout << sum;
      
    return 0;
}
65
75

Explanation: The character c = (‘A’) is manually converted to its ASCII integer value using (int)c. The addition of i = 10 and c involves automatic type conversion, where the character c is automatically converted to its ASCII value (65) before the addition. The C++ Course covers the various methods of type conversion, helping you understand how to handle data types correctly.

In C++, there are two types of type conversion:
Implicit Type Conversion

Implicit type conversion (also known as coercion) is the conversion of one type of data to another type automatically by the compiler when needed. It happens automatically when:

    Operations are performed on values of different data types.
    If you pass an argument to a function that expects a different data type.
    Assigning a value of one data type to a variable of another data type.
    
    #include <iostream>
using namespace std;

int main() {
  
    int i = 10;
    char c = 'a';

    // c implicitly converted to int. ASCII
    // value of 'a' is 97
    i = i + c;

    // x is implicitly converted to float
    float f = i + 1.0;

    cout << "i = " << i << endl
         << "c = " << c << endl
         << "f = " << f;

    return 0;
}
i = 107
c = a
f = 108

It is possible for implicit conversions to lose information, signs can be lost (when signed is implicitly converted to unsigned), and overflow can occur (when long long is implicitly converted to float).
Cases of Implicit Type Conversion

1. For Numeric Type

All the data types of the variables are upgraded to the data type of the variable with largest data type. For numeric type,

    bool -> char -> short int -> int ->  unsigned int -> long -> unsigned -> long long -> float -> double -> long double

2. Pointer Conversions

Pointers to derived classes can be converted to pointers to base classes automatically.

3. Boolean Conversion

Any scalar type (integer, floating-point, pointer) is implicitly converted to bool in a context that requires a Boolean value (e.g., if, while, for conditions).
Explicit Type Conversion

Explicit type conversion, also called type casting is the conversion of one type of data to another type manually by a programmer. Here the user can typecast the result to make it of a particular data type. In C++, it can be done by two ways: 
1. C Style Typecasting

This method is inherited by C++ from C. The conversion is done by explicitly defining the required type in front of the expression in parenthesis. This can be also known as forceful casting.

    (type) expression;

where type indicates the data type to which the final result is converted. 
#include <iostream>
using namespace std;

int main() {
    double x = 1.2;

    // Explicit conversion from double to int
    int sum = (int)x + 1;

    cout << sum;

    return 0;
}
2

This typecasting is considered old and unsafe because it performs no checks whatsoever to determine whether the casting is valid or not.
C++ Style Typecasting

C++ introduced its own typecasting method using cast operators. Cast operator is an unary operator which forces one data type to be converted into another data type. C++ supports four types of casting:

    Static Cast: Used for standard compile time type conversions.
    Dynamic Cast: Used for runtime type conversion in polymorphism and inheritance.
    Const Cast: Removes or adds const or volatile qualifiers.
    Reinterpret Cast: Used for low-level reinterpretation of bits (e.g., converting pointers).
    #include <iostream>
using namespace std;

int main() {
    double x = 1.2;

    // Explicit conversion from double to int
    int sum = static_cast<int>(x + 1);

    cout << sum;
    return 0;
}
2

Risks of Type Conversion

Type conversion provides useful functionality to the language but also introduces certain risks:

    Data loss that occurs when converting from a larger type to a smaller type (e.g., int to char).
    Undefined behavior that happens when casting pointers between unrelated types and dereferencing them.
    Violation of const correctness when removing const with const_cast and modifying the variable leads to undefined behavior.
    Memory misalignment casting pointers to types with stricter alignment can cause crashes.
    
    ### **`#include <bits/stdc++.h>` vs. `#include <iostream>` in C++**
Both headers serve different purposes in C++ programming. Let's break it down:

---

## **1️⃣ `#include <bits/stdc++.h>` (All-in-One Header)**
This is a **non-standard header** that includes **almost all** C++ standard libraries at once.  
It is mainly used in **competitive programming** to save time.

### ✅ **Advantages:**
✔ **Includes Everything** – You don’t need to manually `#include` multiple headers like `<vector>`, `<map>`, `<cmath>`, etc.  
✔ **Faster to Write** – Saves time in contests.  
✔ **Reduces Debugging Effort** – No missing header errors.  

### ❌ **Disadvantages:**
❌ **Non-Standard** – It **only works with GCC/Clang**, not in MSVC (Microsoft Visual C++).  
❌ **Increases Compilation Time** – Since it includes **everything**, compiling is slower.  
❌ **Not Recommended for Production Code** – Makes code **less readable** and includes unnecessary libraries.  

### **Example Usage (`bits/stdc++.h`)**
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    vector<int> v = {1, 2, 3};
    cout << "Size: " << v.size() << endl;
    return 0;
}
```
- This works because `<bits/stdc++.h>` automatically includes `<vector>` and `<iostream>`.

---

## **2️⃣ `#include <iostream>` (Standard Library)**
This is a **standard** header file that only includes **input-output functionality**.

### ✅ **Advantages:**
✔ **Standard and Portable** – Works on all compilers.  
✔ **Faster Compilation** – Only includes necessary code.  
✔ **Better for Large Projects** – Keeps dependencies minimal.  

### ❌ **Disadvantages:**
❌ **Requires Manual Inclusion of Other Headers** – If you need vectors, maps, etc., you must include `<vector>`, `<map>`, etc.  

### **Example Usage (`iostream` Only)**
```cpp
#include <iostream>
using namespace std;

int main() {
    cout << "Hello, World!" << endl;
    return 0;
}
```
- This only provides **input/output** (`cin`, `cout`).
- If you need `vector`, `map`, etc., you must manually `#include` them.

---

## **🚀 Which One Should You Use?**
| Feature              | `#include <bits/stdc++.h>` | `#include <iostream>` |
|----------------------|-------------------------|------------------|
| **Compilation Speed** | ❌ Slower | ✅ Faster |
| **Portability**       | ❌ GCC/Clang Only | ✅ Works Everywhere |
| **Readability**      | ❌ Messy | ✅ Clearer |
| **Memory Usage**     | ❌ Higher | ✅ Lower |
| **Use Case**         | ✅ Competitive Programming | ✅ Production & Large Projects |

👉 **Use `#include <bits/stdc++.h>`** in **competitive programming** for speed.  
👉 **Use `#include <iostream>` and proper headers** in **real-world applications** for better performance and maintainability.  

Let me know if you have more questions! 🚀

1. static_cast

The static_cast operator is the most commonly used casting operator in C++. It performs compile-time type conversion and is mainly used for explicit conversions that are considered safe by the compiler. 

Syntax


    static_cast <new_type> (exp);

where,

    exp: Data to be converted.
    new_type: Desired type of expression

The static_cast can be used to convert between related types, such as numeric types or pointers in the same inheritance hierarchy.

Example
#include <bits/stdc++.h>
using namespace std;

int main() {

    int n = 10;

    // converting int to double
    double nd = static_cast<double>(n);

    // printing data type
    cout << typeid(n).name() << endl;

    // typecasting
    cout << typeid(static_cast<double>(n)).name() << endl;

    // Printing double type
    cout << typeid(nd).name();

    return 0;
}

typeid operator in C++ with Examples
Last Updated : 03 Sep, 2021

typeid is an operator in C++. 

    It is used where the dynamic type or runtime type information of an object is needed.
    It is included in the <typeinfo> library. Hence inorder to use typeid, this library should be included in the program.
    The typeid expression is an lvalue expression.

Syntax:  

typeid(type);
OR
typeid(expression);

Parameters: typeid operator accepts a parameter, based on the syntax used in the program:  

    type: This parameter is passed when the runtime type information of a variable or an object is needed. In this, there is no evaluation that needs to be done inside type and simply the type information is to be known.
    expression: This parameter is passed when the runtime type information of an expression is needed. In this, the expression is first evaluated. Then the type information of the final result is then provided.

Return value: This operator provides the runtime type information of the specified parameter and hence that type information is returned, as a reference to an object of class type_info.
Usage: typeid() operator is used in different way according to the operand type. 

    When operand is a variable or an object.
    // C++ program to show the use of typeid operator 

#include <iostream> 
#include <typeinfo> 
using namespace std; 

int main() 
{ 
	int i, j; 
	char c; 

	// Get the type info using typeid operator 
	const type_info& ti1 = typeid(i); 
	const type_info& ti2 = typeid(j); 
	const type_info& ti3 = typeid(c); 

	// Check if both types are same 
	if (ti1 == ti2) 
		cout << "i and j are of"
			<< " similar type" << endl; 
	else
		cout << "i and j are of"
			<< " different type" << endl; 

	// Check if both types are same 
	if (ti2 == ti3) 
		cout << "j and c are of"
			<< " similar type" << endl; 
	else
		cout << "j and c are of"
			<< " different type" << endl; 

	return 0; 
} 

i and j are of similar type
j and c are of different type
// C++ program to show the use of typeid operator 

#include <iostream> 
#include <typeinfo> 
using namespace std; 

int main() 
{ 
	int i = 5; 
	float j = 1.0; 
	char c = 'a'; 

	// Get the type info using typeid operator 
	const type_info& ti1 = typeid(i * j); 
	const type_info& ti2 = typeid(i * c); 
	const type_info& ti3 = typeid(c); 

	// Print the types 
	cout << "ti1 is of type "
		<< ti1.name() << endl; 

	cout << "ti2 is of type "
		<< ti2.name() << endl; 

	cout << "ti3 is of type "
		<< ti3.name() << endl; 

	return 0; 
} 

ti1 is of type f
ti2 is of type i
ti3 is of type c

Explanation: In this example, we have used typeid() operator to check the data type. We have defined an integer variable n and converted it into a double using static_cast. After that, we print the data types of variables and pass static_cast<double>(n) in typeid() to check its data type. we can see the output “i, d, d” is printed where i denotes integer and d denotes double.
1. static_cast

The static_cast operator is the most commonly used casting operator in C++. It performs compile-time type conversion and is mainly used for explicit conversions that are considered safe by the compiler. 

Syntax


    static_cast <new_type> (exp);

where,

    exp: Data to be converted.
    new_type: Desired type of expression

The static_cast can be used to convert between related types, such as numeric types or pointers in the same inheritance hierarchy.
#include <bits/stdc++.h>
using namespace std;

int main() {

    int n = 10;

    // converting int to double
    double nd = static_cast<double>(n);

    // printing data type
    cout << typeid(n).name() << endl;

    // typecasting
    cout << typeid(static_cast<double>(n)).name() << endl;

    // Printing double type
    cout << typeid(nd).name();

    return 0;
}

i
d
d

Explanation: In this example, we have used typeid() operator to check the data type. We have defined an integer variable n and converted it into a double using static_cast. After that, we print the data types of variables and pass static_cast<double>(n) in typeid() to check its data type. we can see the output “i, d, d” is printed where i denotes integer and d denotes double.

2. dynamic_cast - after oops

3. const_cast

The const_cast operator is used to modify the const or volatile qualifier of a variable. It allows programmers to temporarily remove the constancy of an object and make modifications. Caution must be exercised when using const_cast, as modifying a const object can lead to undefined behavior.

Syntax

    const_cast <new_type> (exp);


#include <iostream>
using namespace std;

int main() {

    const int n = 5;
  
    // Pointer to a const int
    const int* ptr = &n;

    // int* nonConstPtr = ptr; if we use this
    // instead of without using const_cast
    // we will get error of invalid conversion
    int* nonConstPtr = const_cast<int*>(ptr);
    *nonConstPtr = 10;

    cout << *nonConstPtr;

    return 0;
}

10

Explanation: In the above example, we have modified the value of the const type pointer by changing its qualifier from const to non-const and then printing the modified value.
4. reinterpret_cast

The reinterpret_cast operator is used to convert the pointer to any other type of pointer. It does not perform any check whether the pointer converted is of the same type or not.

Syntax

    reinterpret_cast <new_type> (exp);


#include <iostream>
using namespace std;

int main() {
    int n = 10;
  
    // Store the address of number in nptr
    int* nptr = &n;

    // Reinterpreting the pointer as a char pointer
    char* charptr = reinterpret_cast<char*>(nptr);

    // Printing the memory addresses and values
    cout << "Integer Address: " << nptr << endl;
    cout << "Char Address: " << charptr;

    return 0;
}
Integer Address: 0x7ffcd595d6fc
Char Address: 0x7ffcd595d6fc

Explanation: In the above example, we have defined an int variable n and then store the address of n in nptr of the int type after that we have converted the nptr of the int type into char pointer and then store it into charptr variable. To verify that we have printed the address of both nptr and charptr. To print the address stored in charptr reinterpret_cast<void*> is used to bypass the type-checking mechanism of C++ and allow the pointer to be printed as a generic memory address without any type-specific interpretation.
    Note: const_cast and reinterpret_cast are generally not recommended as they vulnerable to different kinds of errors.




Operators in C++
Last Updated : 20 Jan, 2025

In C++, an operator is a symbol that operates on a value to perform specific mathematical or logical computations on given values. They are the foundation of any programming language.
#include <iostream>
using namespace std;
int main() {
  
    int a = 10 + 20;
  
    cout << a;
    return 0;
}

. Arithmetic Operators

Arithmetic operators are used to perform arithmetic or mathematical operations on the operands. For example, ‘+’ is used for addition.
Name	Symbol	Description
Addition	+	Adds two operands.
Subtraction	–	Subtracts second operand from the first.
Multiplication	*	Multiplies two operands.
Division	/	Divides first operand by the second operand.
Modulo Operation	%	Returns the remainder an integer division.

Increment
	

++
	

Increase the value of operand by 1.

Decrement
	

—
	

Decrease the value of operand by 1.

2. Relational Operators

Relational operators are used for the comparison of the values of two operands. For example, ‘>’ check right operand is greater.
Name	Symbol	Description
Is Equal To	==	Checks both operands are equal
Greater Than	>	Checks first operand is greater than the second operand
Greater Than or Equal To	>=	Checks first operand is greater than equal to the second operand
Less Than	<	Checks first operand is lesser than the second operand
Less Than or Equal To	<=	Checks first operand is lesser than equal to the second operand
Not Equal To	!=	Checks both operands are not equal

3. Logical Operators

Logical operators are used to combine two or more conditions or constraints or to complement the evaluation of the original condition in consideration. The result returns a Boolean value, i.e., true or false.
Name	Symbol	Description
Logical AND	&&	Returns true only if all the operands are true or non-zero.
Logical OR	||	Returns true if either of the operands is true or non-zero.
Logical NOT	!	Returns true if the operand is false or zero.
4. Bitwise Operators

Bitwise operators are works on bit-level. So, compiler first converted to bit-level and then the calculation is performed on the operands.
Name	Symbol	Description
Binary AND	&	Copies a bit to the evaluated result if it exists in both operands
Binary OR	|	Copies a bit to the evaluated result if it exists in any of the operand
Binary XOR	^	Copies the bit to the evaluated result if it is present in either of the operands but not both
Left Shift	<<	Shifts the value to left by the number of bits specified by the right operand.
Right Shift	>>	Shifts the value to right by the number of bits specified by the right operand.
One’s Complement	~	Changes binary digits 1 to 0 and 0 to 1


Unary Operators in C
Last Updated : 04 Feb, 2025

In C programming, unary operators are operators that operate on a single operand. These operators are used to perform operations such as negation, incrementing or decrementing a variable, or checking the size of a variable. They provide a way to modify or manipulate the value of a single variable in an efficient manner.

C provides 9 unary operators that can be used to perform various operations on a single variable. These include:
1. Increment Operator (++)

The increment operator ( ++ ) is used to increment the value of the variable by 1. The increment can be done in two ways:

A. Prefix Increment

In this method, the operator precedes the operand (e.g., ++a). The value of the operand will be altered before it is used. For example:
B. Postfix Increment

In this method, the operator follows the operand (e.g., a++). The value operand will be altered after it is used. For example:


2. Decrement Operator (–)

The decrement operator ( — ) is used to decrement the value of the variable by 1. The decrement can be done in two ways:

A. Prefix Decrement

In this method, the operator precedes the operand (e.g., – -a). The value of the operand will be altered before it is used. For example:

    int a = 1;
    int b = –a;  // b = 0

B. Postfix Decrement

In this method, the operator follows the operand (e.g., a- -). The value of the operand will be altered after it is used. For example:

    int a = 1;
    int b = a–;   // b = 1
    int c = a;     // c = 0

Below example shows the implementation of decrement (–):
Unary Plus

The unary plus (+) operator does not change the sign of its argument; it simply returns the value as is. It is often used for code clarity rather than functionality.

    int a = -10;  
    int b = +a;  // b = -10 

The unary plus is different from the addition operator, as addition requires two operands.

Below is the implementation of the unary plus (+) operator:
Unary Minus

The minus operator ( – ) changes the sign of its argument. A positive number becomes negative, and a negative number becomes positive.

     int a = 10;
    int b = -a;  // b = -10

Unary minus is different from the subtraction operator, as subtraction requires two operands.

Below is the implementation of the unary minus (-) operator:
Logical NOT ( ! )

The logical NOT operator ( ! ) is used to reverse the logical state of its operand. If a condition is true, then the Logical NOT operator will make it false.

Example:

    If x is true, then !x is false
    If x is false, then !x is true

Below is the implementation of the NOT (!) operator:
Bitwise NOT ( ~ )

The bitwise NOT (~) operator inverts all bits of its operand. Each 0 becomes 1, and each 1 becomes 0. It effectively calculates the two’s complement negative equivalent of a number in signed integers.

    x = 5 (00000101 in binary),
    ~x = ~6 (11111010 in binary, two’s complement representation)

Below is the implementation of the bitwise NOT (~) operator:
Addressof Operator (&)

The addressof operator ( & ) gives an address of a variable. It is used to return the memory address of a variable. These addresses returned by the address-of operator are known as pointers because they “point” to the variable in memory.

Example:

    & gives an address on variable n 
    int a;
    int *ptr;
    ptr = &a; // address of a is copied to the location ptr. 

Below is the implementation of the Addressof operator(&):
Indirection Operator (*)

The indirection operator (*), also known as the dereference operator, is used to access the value stored at a memory address. It is used with pointers to retrieve the value stored at the referenced memory location.


sizeof()

This operator returns the size of its operand, in bytes. The sizeof() operator always precedes its operand. The operand is an expression, or it may be a cast.

    Note: The `sizeof()` operator in C++ is machine dependent. For example, the size of an ‘int’ in C++ may be 4 bytes in a 32-bit machine but it may be 8 bytes in a 64-bit machine.


1. Addition Assignment (+=)

Adds the value of the right operand to the left operand and stores the result in the left operand.
2. Subtraction Assignment (-=)

Subtracts the value of the right operand from the left operand and stores the result in the left operand.
3. Multiplication Assignment (*=)

Multiplies the value of the right operand by the left operand and stores the result in the left operand.
4. Division Assignment (/=)

Divides the left operand by the right operand and stores the result in the left operand
5. Modulus Assignment (%=)

Takes the modulus of the left operand by the right operand and stores the result in the left operand
6. Bitwise AND Assignment (&=)

Performs a bitwise AND operation and assigns the result.
7. Bitwise OR Assignment (|=)

Performs a bitwise OR operation and assigns the result.
8. Bitwise XOR Assignment (^=)

Performs a bitwise XOR operation and assigns the result.
9. Bitwise Left Shift Assignment (<<=)

Shifts the bits of the left operand to the left by the number of positions specified by the right operand and assigns the result.
10. Bitwise Right Shift Assignment (>>=)

Shifts the bits of the left operand to the right by the number of positions specified by the right operand and assigns the result

C++ sizeof Operator
Last Updated : 09 Dec, 2024

The sizeof operator is a unary compile-time operator used to determine the size of variables, data types, and constants in bytes at compile time. It can also determine the size of classes, structures, and unions.
Syntax of sizeof in C++

The sizeof operator can be used to find the size of a type or a variable in C++ as shown:

    sizeof (type)
    sizeof (expression)

Examples of sizeof in C++

The below examples demonstrate the common usage of sizeof in C++:




Scope Resolution Operator in C++
Last Updated : 11 Jan, 2025

In C++, the scope resolution operator (::) is used to access the identifiers such as variable names and function names defined inside some other scope in the current scope. Let’s take a look at an example:

1

#include <iostream>

2

​

3

int main() {

4

​

5

      // Accessing cout from std namespace using scope

6

      // resolution operator

7

    std::cout << "GeeksforGeeks";

8

​

9

    return 0;

10

}


Output

GeeksforGeeks

Explanation: The std namespace contains the declaration of cout. So, to use cout, we first need to tell the compiler that it is declared inside the std namespace which is done using ::. The compiler then resolves the cout from there.
Syntax of Scope Resolution Operator

The scope resolution operator follows this general syntax:

    scope_name :: identifier

where scope_name is the name of the scope where identifier is defined.
Applications of Scope Resolution Operator

Following are the main applications of scope resolution operator illustrated with an example:
Accessing Global Variables

When a local variable shadows a global variable, we can use :: to access the global variable
#include <iostream>
using namespace std;

// Global x
int x = 3;

int main() {
      
      // Local x
    int x = 10;
  
      // Printing the global x
    cout << ::x;
  
    return 0;
}
Refer to Base Class Member in Derived Class

The scope resolution operator can also be used to refer to the members of base class in a derived class especially if they have the same name.
#include <bits/stdc++.h>
using namespace std;

class Base {
public:
    void func() {
        cout << "Base class func()" << endl;
    }
};

class Derived : public Base {
public:
  
      // Overridden function
    void func() {
        cout << "Derived class func()" << endl;
    }
};

int main() {
    Derived obj;
  
      // Calling base class's func() from the object of
      // derived class
    obj.Base::func();
  
    obj.func();
    return 0;
}
Base class func()
Derived class func()




input /output 


Basic Input / Output in C++
Last Updated : 09 Jan, 2025

In C++, input and output are performed in the form of a sequence of bytes or more commonly known as streams.

    Input Stream: If the direction of flow of bytes is from the device (for example, Keyboard) to the main memory then this process is called input.
    Output Stream: If the direction of flow of bytes is opposite, i.e. from main memory to device (display screen) then this process is called output.

All of these streams are defined inside the <iostream> header file which contains all the standard input and output tools of C++. The two instances cout and cin of iostream class are used very often for printing outputs and taking inputs respectively. These two are the most basic methods of taking input and printing output in C++.
Standard Output Stream – cout

The C++ cout is the instance of the ostream class used to produce output on the standard output device which is usually the display screen. The data needed to be displayed on the screen is inserted in the standard output stream (cout) using the insertion operator(<<).

Syntax

    cout << value/variable;

For example, if we want to print text “GeeksforGeeks” on the display, we can use the cout as shown:

#include <iostream>
using namespace std;

int main() {

      // Printing the given text using cout
    cout << "GeeksforGeeks";
    return 0;
}


Explanation: In the above program, cout is used to output the text “GeeksforGeeks” to the standard output stream. It works in conjunction with the insertion operator (<<) to send the specified data to the output stream.

We can also print the variable values using cout.

#include <iostream>
using namespace std;

int main() {
    int a = 22;
  
      // Printing variable 'a' using cout
    cout << a;
    return 0;
}


Output

22

Understanding input and output operations is essential for any C++ programmer. The C++ Course includes comprehensive lessons on basic I/O operations, ensuring you can manage user interaction in your programs.
Standard Input Stream – cin

The C++ cin statement is the instance of the class istream and is used to read input from the standard input device which is usually a keyboard. The extraction operator (>>) is used along with the object cin for extracting the data from the input stream and store it in some variable in the program.

Syntax

    cin >> variable;

For example, if we want to ask user for his/her age, then we can use cin as shown:
#include <iostream>
using namespace std;

int main() {
    int age;

      // Output a label
    cout << "Enter your age:";
  
      // Taking input from user and store
      // it in variable
    cin >> age;
  
      // Output the entered age
    cout << "Age entered: " << age;
    return 0;
}

Enter your age: 18 (18 entered by the user)

Output

Your age is: 18

Explanation: The above program asks the user to input the age. The object cin is connected to the input device (keyboard). The age entered by the user is extracted from cin using the extraction operator(>>) and the extracted data is then stored in the variable age present on the right side of the extraction operator.

    The type of input provided should be same as that of the variable being used to store it. Otherwise, it may lead to undefined error or input failure.

Also, while taking text as input using cin, we need to remember that cin stops reading input as soon as it encounters a whitespace (space, tab, or newline). This means it only captures the first word or characters until the first whitespace. It is shown in the below example:
#include <iostream>
using namespace std;

int main() {
    string name;

      // Output a label
    cout << "Enter your name:";
  
      // Taking input from user and store
      // it in variable
    cin >> name;
  
      // Output the entered age
    cout << "Name entered: " << age;
    return 0;
}


Input

Enter your name: Vishal Kumar (User entered Vishal Kumar)

Output

Name entered: Vishal

Un-buffered Standard Error Stream – cerr

The C++ cerr is the standard error stream that is used to output the errors. This is also an instance of the iostream class. As cerr in C++ is un-buffered so it is used when one needs to display the error message immediately. It does not have any buffer to store the error message and display it later.

The main difference between cerr and cout comes when you would like to redirect output using “cout” that gets redirected to file if you use “cerr” the error doesn’t get stored in file.(This is what un-buffered means ..It cant store the message)
#include <iostream>
using namespace std;

int main() {
    cerr << "An error occurred";
    return 0;
}

Buffered Standard Error Stream – clog

This is also an instance of ostream class and used to display errors but unlike cerr the error is first inserted into a buffer and is stored in the buffer until it is not fully filled. or the buffer is not explicitly flushed (using flush()). The error message will be displayed on the screen too.

#include <iostream>
using namespace std;

int main() {
    clog << "An error occurred";
    return 0;
}


i need reason why if enter two words in name it doesnt ask for age in input
ChatGPT said:

Good question! The reason your program doesn’t ask for age after entering a name with two words is due to how cin >> name; handles input.
What Happens in Your Code?

cin >> name;
cin >> x;

    cin >> name; only reads the first word before a space.
    If you enter "John Doe", only "John" is stored in name, and "Doe" remains in the input buffer.
    When cin >> x; runs, it tries to read an integer but sees "Doe", which is not a number.
    Since "Doe" cannot be converted to an integer, input fails and cin goes into an error state.
    Because of this error, cin >> x; does not execute, and the program skips further input.
    
    🚀 Understanding cerr (Unbuffered Standard Error Stream) in C++

You already know cout, which prints output to the console. Now, let's talk about cerr, which is used for error messages.
🔹 What is cerr?

✔ cerr stands for C++ Error Stream.
✔ It is unbuffered, meaning it immediately prints output without waiting.
✔ Used to display error messages instantly.
🔹 cerr vs. cout (The Key Difference)

The main difference is buffering:
Feature	cout (Buffered)	cerr (Unbuffered)
Buffering	Stores output in a buffer before printing	Prints immediately, no buffer
Speed	Slightly faster because of buffering	Slower due to immediate printing
Redirection (> to file)	Redirects output to a file normally	Doesn’t get redirected like cout
🔹 Example 1: cerr Prints Instantly

#include <iostream>
using namespace std;

int main() {
    cout << "This is normal output." << endl;
    cerr << "This is an error message!" << endl;
    return 0;
}

📌 Output on Console

This is normal output.
This is an error message!

✅ Notice that cerr prints immediately, while cout may wait.
🔹 Example 2: Redirecting Output to a File

If you run this program from a terminal and redirect output:

./a.out > output.txt

📌 What happens?

    cout output goes to output.txt (because it’s buffered).
    cerr still appears on the terminal (because it’s unbuffered and doesn’t get redirected).

✅ To redirect both cout and cerr to a file, use this:

./a.out > output.txt 2>&1

Here, 2>&1 means redirect stderr (cerr) to the same location as stdout (cout).
🔹 When to Use cerr?

✔ When you need immediate error messages (e.g., debugging, warnings, fatal errors).
✔ When errors should always appear on the terminal, even if output is redirected.
✔ When you don’t want errors to get mixed with normal output.

Would you like more examples or real-world scenarios? 😃


Buffered Standard Error Stream – clog

This is also an instance of ostream class and used to display errors but unlike cerr the error is first inserted into a buffer and is stored in the buffer until it is not fully filled. or the buffer is not explicitly flushed (using flush()). The error message will be displayed on the screen too.### 🚀 **Understanding `clog` (Buffered Standard Error Stream) in C++**  

In C++, we have **two** ways to print error messages:  
✔ `cerr` – **Unbuffered** (prints immediately)  
✔ `clog` – **Buffered** (stores errors in a buffer before printing)  

---

## **🔹 What is `clog`?**  
✔ `clog` stands for **C++ Log Stream** (used for logging messages).  
✔ It is **buffered**, meaning it **stores messages in memory first** and then prints them **all at once** when the buffer is full or manually flushed.  
✔ It is useful when **writing logs efficiently** without slowing down the program.

---

## **🔹 `clog` vs. `cerr` (The Key Difference)**  

| Feature   | `cerr` (Unbuffered) | `clog` (Buffered) |
|-----------|--------------------|-------------------|
| **Buffering** | Prints immediately, no buffer | Uses a buffer, prints later |
| **Performance** | Slower (prints each message instantly) | Faster (collects messages before printing) |
| **Use Case** | For urgent errors that must be seen immediately | For logging messages efficiently |

---

## **🔹 Example 1: `cerr` vs. `clog` Output**
```cpp
#include <iostream>
using namespace std;

int main() {
    cerr << "This is an error (cerr)!" << endl;
    clog << "This is a log message (clog)!" << endl;
    return 0;
}
```
📌 **What happens?**  
- `cerr` prints **immediately**.  
- `clog` **might** delay printing until the buffer is full.  

✅ To **force `clog` to print immediately**, you can use `.flush()`:  
```cpp
clog << "This is a log message!" << flush;
```

---

## **🔹 Example 2: `clog` Buffering in Action**
```cpp
#include <iostream>
using namespace std;

int main() {
    clog << "Logging some messages..." << endl;
    clog << "These messages are buffered." << endl;
    
    // Flushing the buffer
    clog.flush();  
    
    cout << "Normal output." << endl;
    return 0;
}
```
📌 **Output Order (May Vary)**
```
Normal output.
Logging some messages...
These messages are buffered.
```
✅ The **order might change** because `clog` messages stay in a buffer **until it’s full or explicitly flushed**.

---

## **🔹 When to Use `clog`?**
✔ **Logging messages** efficiently without slowing down performance.  
✔ **Writing to log files** instead of the console (useful for debugging large programs).  
✔ **When errors are not urgent** and don’t need to be seen immediately.  

Would you like a **real-world example** of `clog` in logging? 😃


cin in C++
Last Updated : 12 Dec, 2024

In C++, cin is an object of istream class that is used to accept the input from the standard input stream i.e. stdin which is by default associated with keyboard. The extraction operator (>>) is used along with cin to extract the data from the object and insert it to the given variable.

Let’s take a look at an example:

#include <iostream>
using namespace std;

int main() {
  
      // Variable to store data given by cin
    int a;

    // Take input using cin
    cin >> a;

    cout << a;
    return 0;
}


Input

10

Output

10

Syntax of cin

    cin >> var_name;

Here,

    >>: It is the extraction operator to extract data from cin.
    var_name: It is a variable that will store the input data provided by the user.

    Note: cin is initialized when the program starts to make sure it is ready for input operations. It is also linked to cout to ensure that any buffered output is flushed before cin reads from the input stream.

Understanding how to use cin for input is fundamental in C++. To master input handling in your programs, consider exploring the C++ Course, which provides detailed explanations and practical examples.
Examples of cin

The following examples demonstrate how to use cin in C++ programs:
Taking a Text from User Input
#include <iostream>
using namespace std;

int main() {
  
      // Variable to store data given by cin
    string s;

    // Take input using cin
    cin >> s;

    // Print output
    cout << s;
    return 0;
}

Welcome to GeeksforGeeks

Output

Welcome

Taking Multiple Inputs Using the Extraction Operator(>>) with cin

#include <iostream>
using namespace std;

int main() {
    string name;
    int age;

    // Take multiple input using cin
    cin >> name >> age;

    cout << "Name : " << name << endl;
    cout << "Age : " << age << endl;

    return 0;
}


ABC 13

Output

Name : ABC
Age : 13

cin Member Functions in C++

The below table lists some commonly used member functions of cin in C++:
Member Function	Description
cin.get()	Reads a single character from the input stream, including whitespace.
cin.getline()	Reads a line of text, including whitespace, and stops when it reaches a newline character.
cin.ignore()	Ignores a specified number of characters or until a specified delimiter is encountered.
cin.peek()	Returns the next character from the input stream without extracting it.
cin.putback()	Puts a character back into the input stream.
cin.eof()	Returns true if the end of the input stream has been reached.
cin.fail()	Returns true if an input operation has failed (e.g., when input doesn’t match the expected type).
cin.clear()	Clears the error flags on the input stream, allowing further operations.
cin.sync()	Discards unread characters from the input buffer.
cin.gcount()	Returns the number of characters extracted by the last unformatted input operation.
cin.rdbuf()	Gets or sets the associated stream buffer object for std::cin.
cin.get()

It reads an input character and stores it in a variable. Below is the C++ program to implement cin.get()
// C++ program to illustrate the use
// of cin.get()
#include <iostream>
using namespace std;

// Driver Code
int main()
{
    char ch[30];
    cin.get(ch, 25);

    // Print ch
    cout << ch;
}

Welcome to GFG

Output

Welcome to GFG

cin.getline()

It reads a stream of characters of given length N into the string buffer. It stops when it has read (N – 1) characters or it finds the end of the file or newline character(\n). Below is the C++ program to implement cin.getline():

// C++ program to illustrate the use of cin.getline
#include <iostream>
using namespace std;

int main() {
    char name[5];

    // Reads stream of 3 characters
    cin.getline(name, 3);

    // Print output
    cout << name << endl;

    return 0;
}


Geeks

Output

Ge

cin.read()

It reads a stream of characters of given length N. Below is the C++ program to implement cin.read():

// C++ program to illustrate the use of cin.read()
#include <iostream>
using namespace std;

int main() {
    char gfg[20];

    // Reads stream of characters
    cin.read(gfg, 10);

    // Print output
    cout << gfg << endl;

    return 0;
}


Welcome to GFG

Output

Welcome to

cin.ignore()
cin.ignore()

It ignores or clears one or more characters from the input buffer. Below is the C++ program to implement cin.ignore():

// C++ program to illustrate the use of cin.ignore()
#include <iostream>
#include <ios>
#include <limits>
using namespace std;

int main() {
    int x;
    char str[80];
    cout << "Enter a number and string:\n";
    cin >> x;

    // clear buffer before taking
    // new line
    cin.ignore(numeric_limits<streamsize>::max(), '\n');

    // Input a string
    cin.getline(str, 80);
    cout << "You have entered:\n";
    cout << x << endl;
    cout << str << endl;

    return 0;
}


Enter a number and string:
8
Welcome to GFG

Output

You have entered:
8
Welcome to GFG

Explanation: In the above program if cin.ignore() has not been used then after entering the number when the user presses the enter to input the string, the output will be only the number entered. The program will not take the string input. To avoid this problem cin.ignore() is used, this will ignore the newline character.

### 🚀 **Understanding `cin.get()` in C++**  

`cin.get()` is a function used for **reading input**, especially when dealing with **characters, whitespace, and newlines**. It gives more control over **how input is taken** compared to `cin >>` (which ignores whitespace).  

---

## **🔹 Why Use `cin.get()`?**
✔ Reads **single characters**, including spaces and newlines.  
✔ Useful when handling **strings with spaces** or **pausing execution**.  
✔ Can be used with **multiple overloads** (different ways to use it).  

---

## **🔹 `cin.get()` vs. `cin >>` (Key Difference)**  
| Feature         | `cin.get()`         | `cin >>` |
|----------------|-------------------|---------|
| **Reads**       | Single character (including spaces/newlines) | Single word (ignores spaces) |
| **Stops at**    | First newline or when full | First whitespace |
| **Best for**    | Reading characters, stopping at newlines | Reading words or numbers |

---

## **🔹 Example 1: Reading a Single Character**  
```cpp
#include <iostream>
using namespace std;

int main() {
    char ch;
    cout << "Enter a character: ";
    ch = cin.get();
    cout << "You entered: " << ch << endl;
    return 0;
}
```
📌 **Input**: `A`  
📌 **Output**: `You entered: A`  

✅ Unlike `cin >> ch;`, this also reads **whitespace characters** like `space` or `\n`.

---

## **🔹 Example 2: Reading a Full Line (Including Spaces)**  
```cpp
#include <iostream>
using namespace std;

int main() {
    char str[50];  
    cout << "Enter a sentence: ";
    cin.get(str, 50);  // Reads full line including spaces
    cout << "You entered: " << str << endl;
    return 0;
}
```
📌 **Input**: `Hello World!`  
📌 **Output**: `You entered: Hello World!`  

✅ `cin >> str;` would only take `Hello` and stop at the first space!  

---

## **🔹 Example 3: Using `cin.get()` to Pause the Program**
```cpp
#include <iostream>
using namespace std;

int main() {
    cout << "Press any key to continue...";
    cin.get();  // Waits for user to press Enter
    return 0;
}
```
📌 This is used to **pause** the program until the user presses Enter.

---

## **🔹 Example 4: Handling `\n` (Newline Issue)**
When you use `cin >>`, it **leaves a `\n` in the buffer**, which can cause problems with `cin.get()`.  
### ❌ **Problem**
```cpp
#include <iostream>
using namespace std;

int main() {
    int age;
    char name[50];

    cout << "Enter your age: ";
    cin >> age;  // Reads number but leaves '\n' in buffer

    cout << "Enter your name: ";
    cin.get(name, 50);  // This will NOT work correctly!

    cout << "You entered: " << name << endl;
    return 0;
}
```
📌 **Problem:** `cin.get()` sees the `\n` left in the buffer and **doesn’t wait for input!**  

### ✅ **Solution: Use `cin.ignore()`**
```cpp
cin.ignore();  // Clears leftover '\n' before calling cin.get()
cin.get(name, 50);
```

---

## **🔹 Summary**
✔ `cin.get()` reads **characters** (including spaces & newlines).  
✔ `cin.get(char[], size)` reads **full lines**, including spaces.  
✔ `cin.ignore()` clears **leftover `\n` from `cin >>`** before using `cin.get()`.  
✔ Used for **pausing execution** or handling **special input cases**.  

Would you like a real-world example where `cin.get()` is **essential**? 😃

🚀 Final Summary

✔ cin.get() → Reads one character at a time
✔ getline(cin, string_var) → Reads a full line into a string
✔ cin.get(char[], size) → Reads a full line into a char array

Want an example where getline() and cin >> cause issues together? 😃
dont use string data type with cin get use array ;


cout Member Functions in C++

Below is a list of some commonly used member functions of cout in C++:
Member Function	Description
cout.put(char)	Writes a single character to the output stream.
cout.write(char*, int)	Writes a block of characters from the array to the output stream.
cout.precision(int)	Sets the decimal precision for displaying floating-point numbers.
cout.setf(ios::fmtflags)	Sets the format flags for the stream.
cout.width(int)	Sets the minimum field width for the next output.
cout.fill(char)	Sets the fill character for padding the field.

Below is the implementation of the member functions of the cout.write() and cout.put():
#include <iostream>
using namespace std;

int main() {
    char s[] = "Welcome at GFG";
    char c = 'e';

    // Print first 6 characters
    cout.write(s, 6);

    // Print the character c
    cout.put(c);
  
    return 0;
}

Below is the C++ program to illustrate the use of cout.precision():

#include <iostream>
using namespace std;

int main() {
    double pi = 3.14159783;

    // Set precision to 5
    cout.precision(5);

    cout << pi << endl;

    // Set precision to 7
    cout.precision(7);

    cout << pi << endl;

    return 0;
}


Output

3.1416
3.141598


Manipulators in C++
Last Updated : 10 Jan, 2025

Manipulators are helping functions that can modify the input or output stream. They can be included in the I/O statement to alter the format parameters of a stream. They are defined inside <iomanip> and some are also defined inside <iostream> header file.

For example, if we want to print the hexadecimal value of 100 then we can print it as:

    cout << setbase(16) << 100

Types of Manipulators

There are various types of manipulators classified on the basis type of entity they manipulate:

Table of Content

    Output Stream Manipulators
    Input Stream Manipulators
    Boolean Manipulators
    Alignment and Sign Manipulators
    Base Manipulators

1. Output Stream Manipulators

Output stream manipulators are used to control and format the output stream, such as setting the width, precision, or alignment of printed data. They allow for a better presentation of output.

Following table lists some common output stream manipulators:
Manipulator	Description	Header File
endl	Inserts a newline and flushes the output stream.	iostream
flush	Flushes the output stream manually.	iostream
setw(x)	Sets the width of the next output field to x.	iomanip
setprecision(x)	Sets the precision for floating-point numbers to x.	iomanip
fixed	Displays numbers in fixed-point notation.	iomanip
scientific	Displays numbers in scientific notation.	iomanip
showpoint	Forces the display of the decimal point.	iomanip
noshowpoint	Hides the decimal point unless necessary.	iomanip
Example
C++

#include <iostream>
#include <iomanip>
using namespace std;

int main() {
  
    // Output a new line and flush the stream
    cout << "Hello" << endl;

    // Set width to 10 for the next output
    cout << setw(10) << 42 << endl;

    // Set precision to 3 for floating-point numbers
    cout << setprecision(3) << 3.14159 << endl;

    // Use fixed-point notation
    cout << fixed << 3.14159 << endl;

    // Use scientific notation
    cout << scientific << 3.14159 << endl;

    // Show the decimal point even for whole numbers
    cout << showpoint << 42.0;

    return 0;
}


Output

Hello
        42
3.14
3.142
3.142e+00
4.200e+01

2. Input Stream Manipulators

Input stream manipulators are used to modify the behaviour of the input stream. They help in processing input efficiently, such as skipping unnecessary whitespaces with ws.

Following table lists some common input stream manipulators:
Manipulator	Description	Header File
ws	Skips leading whitespaces in the input stream.	iostream
noskipws	Disables skipping of leading whitespaces.	iostream
Example
C++

#include <iostream>
using namespace std;

int main() {
    char c1, c2;

    // Input skips whitespace by default
    cin >> c1;  

    // Input the next character without skipping whitespace
    cin >> noskipws >> c2;  

    cout << "c1: " << c1 << ", c2: " << c2;
    return 0;
}


Input

    s    x

Output

c1: s, c2:  

3. Boolean Manipulators

Boolean manipulators are used to format boolean values in output. They allow displaying boolean values as true or false or as 1 and 0, depending on the requirement.

Following table lists some common boolean manipulators:
Manipulator	Description	Header File
boolalpha	Displays true or false for boolean values.	iostream
noboolalpha	Displays 1 or 0 for boolean values.	iostream
Example
C++

#include <iostream>
using namespace std;

int main() {
    bool value = true;

    // Display boolean as true/false
    cout << boolalpha << value << endl;

    // Display boolean as 1/0
    cout << noboolalpha << value;

    return 0;
}


Output

true
1

4. Alignment and Sign Manipulators

These manipulators control how text and numbers are aligned or how their signs are displayed in the output.

Following table lists some common alignment and sign manipulators:
Manipulator	Description	Header File
left	Aligns output to the left.	iomanip
right	Aligns output to the right.	iomanip
internal	Aligns signs and base prefixes to the left.	iomanip
showpos	Displays a + sign for positive numbers.	iostream
noshowpos	Hides the + sign for positive numbers.	iostream
Example
C++

#include <iostream>
#include <iomanip>
using namespace std;

int main() {
    int n = 42;

    // Align output to the left
    cout << left << setw(10) << n << endl;

    // Align output to the right
    cout << right << setw(10) << n << endl;

    // Show positive sign for numbers
    cout << showpos << n << endl;

    // Don't show positive sign for numbers
    cout << noshowpos << n;

    return 0;
}


Output

42        
        42
+42
42

5. Base Manipulators

Base manipulators are used to format numbers in different bases, such as decimal, hexadecimal, or octal. They help in representing numbers in a way suited to specific applications.

Following table lists some common base manipulators:
Manipulator	Description	Header File
hex	Formats output in hexadecimal base.	iostream
dec	Formats output in decimal base.	iostream
oct	Formats output in octal base.	iostream
Example
C++

#include <iostream>
using namespace std;

int main() {
    int n = 42;

    // Output in hexadecimal base
    cout << hex << n << endl;

    // Output in decimal base
    cout << dec << n << endl;

    // Output in octal base
    cout << oct << n;

    return 0;
}


Output

2a
42
52

C++ Manipulators – FAQs
What is the difference between endl and \n?

    endl inserts a newline and flushes the stream, while \n only inserts a newline without flushing the stream.

Can manipulators be used without arguments?

    Yes, manipulators like endl, flush, and hex do not require arguments, while others like setw(x) and setprecision(x) need arguments.

What happens if setw() is used with text shorter than the specified width?

    The text is aligned, and the remaining width is filled with spaces by default.




### **📌 `setprecision(x)` vs. `fixed` in C++ (`iomanip`)**  

Both `setprecision(x)` and `fixed` are used for **formatting floating-point numbers**, but they work **differently**. Here’s a clear breakdown:  

---

## **🔹 `setprecision(x)`**
📌 **Sets the total number of significant digits (not just decimals!)**  
📌 Works for both **fixed-point** and **scientific notation**  
📌 **Used with `#include <iomanip>`**  

### **Example 1: `setprecision(x)` (Default Behavior)**
```cpp
#include <iostream>
#include <iomanip>
using namespace std;

int main() {
    double num = 123.456789;

    cout << setprecision(5) << num << endl;
    cout << setprecision(3) << num << endl;  // Only 3 significant digits!

    return 0;
}
```
📌 **Output:**  
```
123.46
123
```
✔ **It counts total significant digits, not just decimal places!**  
✔ In the second case, `setprecision(3)` **rounds it to `123`** because it counts **total digits**, not just decimals.

---

## **🔹 `fixed`**
📌 **Forces `setprecision(x)` to apply only to decimal places**  
📌 Without `fixed`, `setprecision(x)` affects **total digits**  
📌 **Used with `#include <iomanip>`**  

### **Example 2: `fixed` + `setprecision(x)`**
```cpp
#include <iostream>
#include <iomanip>
using namespace std;

int main() {
    double num = 123.456789;

    cout << fixed << setprecision(5) << num << endl;
    cout << fixed << setprecision(3) << num << endl;  // 3 decimal places!

    return 0;
}
```
📌 **Output:**  
```
123.45679
123.457
```
✔ `fixed` makes `setprecision(x)` **only affect decimal places**, not total digits.  
✔ `setprecision(3)` now **keeps 3 decimal places (`.457`)**, instead of limiting significant digits.

---

## **🔹 Key Difference**
| Feature            | `setprecision(x)` (without `fixed`) | `fixed` + `setprecision(x)` |
|--------------------|---------------------------------|---------------------------|
| Affects           | **Total significant digits**    | **Decimal places only**    |
| Works with        | **Both scientific and normal notation** | **Fixed-point notation only** |
| Example (`123.456789`) | `setprecision(5) → 123.46`  | `setprecision(5) → 123.45679` |
| Example (`setprecision(3)`) | `123` (rounds total digits) | `123.457` (3 decimal places) |

---

## **🔹 Summary**
✔ **Use `setprecision(x)` alone for total significant digits.**  
✔ **Use `fixed` with `setprecision(x)` for decimal places.**  
✔ **If you need scientific notation, use `scientific` instead of `fixed`.**  

Would you like a comparison with `scientific` formatting as well? 🚀 


3. Boolean Manipulators

Boolean manipulators are used to format boolean values in output. They allow displaying boolean values as true or false or as 1 and 0, depending on the requirement.

Following table lists some common boolean manipulators:
Manipulator	Description	Header File
boolalpha	Displays true or false for boolean values.	iostream
noboolalpha	Displays 1 or 0 for boolean values.	iostream
Example

#include <iostream>
using namespace std;

int main() {
    bool value = true;

    // Display boolean as true/false
    cout << boolalpha << value << endl;

    // Display boolean as 1/0
    cout << noboolalpha << value;

    return 0;
}


Output

true
1
Decision Making in C++


C++ if Statement
Last Updated : 12 Dec, 2024

The C++ if statement is the most simple decision-making statement. It is used to decide whether a certain statement or block of statements will be executed or not executed based on a certain condition. Let’s take a look at an example: 
#include <iostream> 
using namespace std; 
  
int main()  { 
    int i = 10; 
  
      // If statement
    if (i < 15) { 
        cout << "10 is less than 15"; 
    } 
  
    return 0;
} 


C++ if else Statement
Last Updated : 12 Dec, 2024

The if statement alone tells us that if a condition is true it will execute a block of statements and if the condition is false, it won’t. But what if we want to do something else if the condition is false. Here comes the C++ if else statement. We can use the else statement with if statement to execute a block of code when the condition is false.
#include <iostream> 
using namespace std; 
  
int main()  { 
    int i = 10; 
  
    // If statement
    if (i < 15) { 
        cout << "10 is less than 15"; 
    }
  
      // Else statement with the above if
      else {
          cout << "10 is not less than 15";
    }
  
    return 0;
}


C++ if else if Ladder
Last Updated : 02 Jan, 2025

In C++, the if-else-if ladder helps the user decide from among multiple options. The C++ if statements are executed from the top down. As soon as one of the conditions controlling the if is true, the statement associated with that if is executed, and the rest of the C++ else-if ladder is bypassed. If none of the conditions is true, then the final statement will be executed.

#include <iostream> 
using namespace std; 
  
int main()  { 
    int i = 20;
  
    // If - else ladder
    if (i == 10) 
        cout << "i is 10"; 
    else if (i == 15) 
        cout << "i is 15"; 
    else if (i == 20) 
        cout << "i is 20"; 
    else
        cout << "i is not present"; 
  
    return 0; 
} 


C++ Nested if-else Statement
Last Updated : 12 Dec, 2024

Nested if-else statements are those statements in which there is an if statement inside another if else. We use nested if-else statements when we want to implement multilayer conditions (condition inside the condition inside the condition and so on). C++ allows any number of nesting levels.
#include <iostream>
using namespace std;

int main() {
      int n = 6;
      
      // Outer if statement
      if (n % 2 == 0) {
      
          // Inner if statement
          if (n % 3 == 0) {
              cout << "Divisible by 2 and 3";
        }
          else {
              cout << "Divisible by 2 but not 3";
        }
      }
      else {
          cout << "Not Divisible by 2";
    }

    return 0;
}
Switch Statement in C++
In C++, the switch statement is a flow control statement that is used to execute the different blocks of statements based on the value of the given expression. It is an alternative to the long if-else-if ladder which provides an easy way to execute different parts of code based on the value of the expression. 
#include <iostream>
using namespace std;

int main() {
      
    // Variable to the used as switch expression
    char x = 'A';

    // Switch statement with three cases
    switch (x) {
    case 'A':
        cout << "A";
        break;
    case 'B':
        cout << "B";
        break;
    default:
        cout << "Other than A and B";
        break;
    }
    return 0;
}

A

Explanation: In the above program, the switch statement evaluates the value of x and executes the matching case. If x is ‘A’, it prints “A”; if ‘B’, it prints “B”. The default case handles other values.
Syntax of switch Statement in C++

    switch (expression) {
        case value_1:
            // statements_break.
            break;
        case value_2:
            // statements_2;
            break;
        …..
        …..
        default:
            // default_statements;
            break;
    }


Here,

    The default case is executed if none of the cases are matched.
    The break keyword in each case is used to break out of the switch statement after the matching case is found. Otherwise, all the statements after the matching case will be executed.

Rules of the switch Statement in C++

There are some rules that we need to follow when using switch statements in C++. They are as follows:

    The case value must be either int or char type.
    There can be any number of cases.
    No duplicate case values are allowed.
    Each statement of the case can have a break statement. It is optional.
    The default Statement is also optional.
    
    Working of switch Statement in C++

The working of the switch statement in C is as follows:

    Step 1: The switch expression is evaluated.
    Step 2: The evaluated value is then matched against the present case values.
    Step 3A: If the matching case value is found, that case block is executed.
    Step 3B: If the matching code is not found, then the default case block is executed if present.
    Step 4A: If the break keyword is present in the block, then program control comes out of the switch statement.
    Step 4B: If the break keyword is not present, then all the cases after the matching case are executed.
    Step 5: Statements after the switch statement is executed.
    
    Important Points About switch Statement
1. Switch expression should result in a constant value

If the expression provided in the switch statement does not result in a constant value, it would not be valid. Some valid expressions for switch case will be,

// Constant expressions allowed
switch(1 + 2 + 23);
switch(1 * 2 + 3 % 4);
 
// Variable expression are allowed provided
// they are assigned with fixed values
switch(a * b + c * d);
switch(a + b + c);


2. Expression must evaluate only int or char type values.

The switch statement can only evaluate the integer or character value. So, the switch expression should return the values of type int or char only.
3. Break in switch case

The break keyword is used in the switch case to break out of the switch when encountered. It is used at the end of every case block so that when the matching case is executed, the program control comes out of the loop.

The break statement is optional. If omitted, all the cases after the matching case will also be executed.
4. Default in switch case

The default keyword is used to define a default case which will be executed when no case value is matched. It is also an optional statement, and the switch case statement runs without problem if it is omitted.
5. No duplicate Case Values

In the C switch statement, duplicate case values are not allowed. All the case values must be unique.
6. Nested Switch Statements

In C++, we can nest one switch inside another switch statement without any problem. Though it is avoided most of the time as it makes the program more complex and unreadable.
7. Position of Default Case Does Not Matters

Regardless of its placement, the default case only gets executed if none of the other case conditions are met. So, putting it at the beginning, middle, or end doesn’t change the core logic (unless you’re using a less common technique called fall-through).
8. Differences between switch and if else if ladder in C?

Following are the main differences between switch and if else if ladder in C++:

switch
	

if else if
It executes the different cases on the basis of the value of the switch variable.	It executes the different blocks based on the condition specified.
It can only evaluate the int or char type expressions.	It can evaluate any type of expression.
Faster and easier to read for a large number of conditions.	It can get messy when there are lots of conditions.

continue Statement

The C++ continue statement is used to execute other parts of the loop while skipping some parts declared inside the condition, rather than terminating the loop, it continues to execute the next iteration of the same loop. It is used with a decision-making statement which must be present inside the loop.

This statement can be used inside for loop or while or do-while loop. Let’s take a look at an example:
#include <iostream>
using namespace std;

int main() {
    for (int i = 1; i < 10; i++) {

          // Skip the execution for i = 5
        if (i == 5)
            continue;
        cout << i << " ";
    }
    return 0;
}

break Statement

The C++ break statement is used to terminate the whole loop if the condition is met. It is used with decision-making statements such as if, if-else, or switch statement to break out of the block. It forces the loop to stop the execution of the further iteration.
#include <iostream>
using namespace std;

int main() {
  
      // Loop to print digits from 1 to 4
    for (int i = 1; i < 10; i++) {

        // Breaking Condition
        if (i == 5)
            break;
        cout << i << " ";
    }
  
    return 0;
}

return Statement

The return statement takes control out of the function itself. It is stronger than a break. It is used to terminate the entire function after the execution of the function or after some condition. Every function has a return statement with some returning value except the void() function. Although void() function can also have the return statement to end the execution of the function.
#include <iostream>
using namespace std;

void findNum (int n) {
      for (int i = 0; i <= 100; i++) {
          if (i == n) {
              cout << "Number in Range [0, 100]";
              
              // This will stop the function here
              return;
        }
    }
      cout << "Number not in Range [0, 100]";
      
      // Final return if the above one is not reached.
      return;
}

int main() {
    int n = 10;

      // Caaling the function
    findNum(n);

    return 0;
}

goto Statement

The C++ goto statement is used to jump directly to that part of the program to which it is being called.  Every goto statement is associated with the label which takes them to part of the program for which they are called. The label statements can be written anywhere in the program it is not necessary to use them before or after the goto statement.

Let’s take a look at an example:
#include <iostream>
using namespace std;

int main() {
    int n = 4;

    if (n % 2 == 0) {
      
          // Skipping to label1
        goto label1;
    }
    else {
      
          // Skipping to label2
        goto label2;
    }

label1:
    cout << "Even" << endl;
    return 0;

label2:
    cout << "Odd" << endl;
    return 0;
label3:
    cout << "Unspecified";
    return 0;
}


for Loop in C++
Last Updated : 12 Dec, 2024

In C++, for loop is an entry-controlled loop that is used to execute a block of code repeatedly for the given number of times. It is generally preferred over while and do-while loops in case the number of iterations is known beforehand.

Let’s take a look at an example:
#include <bits/stdc++.h>
using namespace std;

int main() {

      // for loop to print "Hi" 5 times
    for (int i = 5; i < 10; i++) {
          cout << "Hi" << endl;
    }
  
    return 0;
}
Hi
Hi
Hi
Hi
Hi

Syntax of for Loop

The syntax of for loop in C++ is shown below:

    for ( initialization; test condition; updation) { 
         // body of for loop
    }

The various parts of the for loop are:

    Initialization: Initialize the loop variable to some initial value.
    Test Condition: This specifies the test condition. If the condition evaluates to true, then body of the loop is executed, and loop variable is updated according to update expression. If evaluated false, loop is terminated.
    Update Expression: After executing the loop body, this expression increments/decrements the loop variable by some value.
    
    Note: The loop variable can also be declared in the initialization section but the scope of the loop variables that are declared in the initialization section is limited to the for loop block.
    
    Working of a for Loop in C++

The flowchart works as shown below:

    Control falls into the for loop. Initialization is done.
    The flow jumps to Condition.
    Condition is tested.
        If the Condition yields true, the flow goes into the Body.
        If the Condition yields false, the flow goes outside the loop.
    The statements inside the body of the loop get executed.
    The flow goes to the update.
    Updating takes place and the flow goes to Step 3 again.
    The for loop has ended and the flow has gone outside.
    

C++ While Loop
Last Updated : 12 Dec, 2024

In C++, the while loop is an entry-controlled loop that repeatedly executes a block of code as long as the given condition remains true. Unlike the for loop, while loop is used in situations where we do not know the exact number of iterations of the loop beforehand as the loop execution is terminated on the basis of the test condition.

Let’s take a look at an example:
#include <iostream>
using namespace std;

int main() {
  
      // while loop to print numbers from 1 to 5
    int i = 0;
    while (i < 5) {
        cout << "Hi" << endl;
        i++;
    }

    return 0;
}
Hi
Hi
Hi
Hi
Hi

Explanation: The above loop prints the text “Hi” till the given condition is true i.e. i is less than 5. In each execution of the loop’s statement, it increments i till i is less than 5.
Syntax of while Loop

    while (condition) {
        // Body of the loop
        update expression
    }

Though the above is the formal syntax of the while loop, we need to declare the loop variable beforehand and update it in the body of the loop. The various parts of the While loop are:

    Condition: The loop executes its body till this condition remains true.
    Update Expression: Update the value of loop variable to make it closer to the termination condition.
    Body: It is a group of statement that will be executed till the condition remains true.
    Working of while Loop
    The working of the while loop can be understood using the above image:

    Control falls into the while loop.
    The flow jumps to Condition
    Condition is tested.
        If the Condition yields true, the flow goes into the Body.
        If the Condition yields false, the flow goes outside the loop
    The statements inside the body of the loop get executed.
    Updation takes place.
    Control flows back to Step 2.
    The while loop has ended, and the flow has gone outside.
    
C++ do while Loop
Last Updated : 12 Dec, 2024

In C++, the do-while loop is an exit-controlled loop that repeatedly executes a block of code at least once and continues executing as long as a given condition remains true. Unlike the while loop, the do-while loop guarantees that the loop body will execute at least once, regardless of whether the condition is true or false.
Syntax of do-while Loop

    do {
        // Body of the loop
        // Update expression
    } while (condition);

We have to define the loop variable beforehand and update it manually in the body of the loop. Notice the semicolon (“;”) in the end of loop. It is compulsory to terminate the do while loop after the semicolon.

The various parts of the do-while loop are: 

    Condition: The condition is checked after the loop body executes. If the condition evaluates to true, the loop continues. If false, the loop exits.
    Update Expression: Update the loop variable bringing it closer to termination condition.
    Body: Body: It is a group of statement that will be executed surely for the first time and then till the condition remains true.
    Working of do while Loop in C++

Let’s understand the working of the do while loop using the given image:

    Control falls into the do-while loop.
    The statements inside the body of the loop get executed.
    Updation takes place.
    The flow jumps to Condition
    Condition is tested. 
        If the Condition yields true, go to Step 6.
        If the Condition yields false, the flow goes outside the loop
    The flow goes back to Step 2.
    The do-while loop has been ended and flow has gone outside the loop.
    


Range-Based for Loop in C++
Last Updated : 11 Jan, 2025

In C++, the range-based for loop introduced in C++ 11 is a version of for loop that is able to iterate over a range. This range can be anything that is iteratable, such as arrays, strings and STL containers. It provides a more readable and concise syntax compared to traditional for loops.
#include <bits/stdc++.h>
using namespace std;

int main() {
    vector<int> v = {1, 2, 3, 4, 5};

    // Iterating through vector
    for (int i : v) {
        cout << i << " ";
    }
  
    return 0;
}
1 2 3 4 5 

Explanation: In this program, the vector is iterated using range based for loop. As we can see, we don’t need to pass any size information or any iterator to iterate the vector. We just use the name of the vector.

Syntax of Range Based for Loop

    for (declaration: range) {
        // statements
    }

where,

    declaration: Declaration of the variable that will be used to represent each element of the rage.
    range: Name of the range.

The range-based for loop simplifies iteration over containers in C++.
Examples of Range Based for Loop

The below example demonstrates the use of range based for loop in our C++ programs:
Iterate over an Array using Range Based for Loop

Iterate over a Map using Range Based for Loop do map first


Each element of the map is a pair of the same type as that of a map. We have to specify that in declaration, or we can use auto keyword.
#include <bits/stdc++.h>
using namespace std;

int main() {
    map<int, char> m = {{1, 'A'}, {2, 'B'}, {3, 'C'},
                  {4, 'D'}, {5, 'E'}};
      
      // Range based for loop to iterate over array
      // and i is used to represent each element 
    for (auto p: m) {
        cout << p.first << ": " << p.second << endl;
    }

    return 0;
}
 
C++ Arrays

In C++, an array is a data structure that is used to store multiple values of similar data types in a contiguous memory location.

For example, if we have to store the marks of 4 or 5 students then we can easily store them by creating 5 different variables but what if we want to store marks of 100 students or say 500 students then it becomes very challenging to create that numbers of variable and manage them. Now, arrays come into the picture that can do it easily by just creating an array of the required size.
Properties of Arrays in C++

    An Array is a collection of data of the same data type, stored at a contiguous memory location.
    Indexing of an array starts from 0. It means the first element is stored at the 0th index, the second at 1st, and so on.
    Elements of an array can be accessed using their indices.
    Once an array is declared its size remains constant throughout the program.
    An array can have multiple dimensions.
    The size of the array in bytes can be determined by the sizeof operator using which we can also find the number of elements in the array.
    We can find the size of the type of elements stored in an array by subtracting adjacent addresses.

Array Declaration in C++

In C++, we can declare an array by simply specifying the data type first and then the name of an array with its size.
data_type array_name[Size_of_array];

Example

int arr[5];

Here,

    int: It is the type of data to be stored in the array. We can also use other data types such as char, float, and double.
    arr: It is the name of the array.
    5: It is the size of the array which means only 5 elements can be stored in the array.
    Initialization of Array in C++

In C++, we can initialize an array in many ways but we will discuss some most common ways to initialize an array. We can initialize an array at the time of declaration or after declaration.
1. Initialize Array with Values in C++

We have initialized the array with values. The values enclosed in curly braces ‘{}’ are assigned to the array. Here, 1 is stored in arr[0], 2 in arr[1], and so on. Here the size of the array is 5.
int arr[5] = {1, 2, 3, 4, 5};
2. Initialize Array with Values and without Size in C++

We have initialized the array with values but we have not declared the length of the array, therefore, the length of an array is equal to the number of elements inside curly braces.
int arr[] = {1, 2, 3, 4, 5};

3. Initialize Array after Declaration (Using Loops)

We have initialized the array using a loop after declaring the array. This method is generally used when we want to take input from the user or we cant to assign elements one by one to each index of the array. We can modify the loop conditions or change the initialization values according to requirements.

for (int i = 0; i < N; i++) {
    arr[i] = value;
}

4. Initialize an array partially in C++

Here, we have declared an array ‘partialArray’ with size ‘5’ and with values ‘1’ and ‘2’ only. So, these values are stored at the first two indices, and at the rest of the indices ‘0’ is stored.

int partialArray[5] = {1, 2};

5. Initialize the array with zero in C++

We can initialize the array with all elements as ‘0’ by specifying ‘0’ inside the curly braces. This will happen in case of zero only if we try to initialize the array with a different value say ‘2’ using this method then ‘2’ is stored at the 0th index only.
5. Initialize the array with zero in C++

We can initialize the array with all elements as ‘0’ by specifying ‘0’ inside the curly braces. This will happen in case of zero only if we try to initialize the array with a different value say ‘2’ using this method then ‘2’ is stored at the 0th index only.

int zero_array[5] = {0};
Accessing an Element of an Array in C++

Elements of an array can be accessed by specifying the name of the array, then the index of the element enclosed in the array subscript operator []. For example, arr[i].
//  C++ Program to Illustrate How to Access Array Elements
#include <iostream>
using namespace std;

int main()
{

    int arr[3];

    // Inserting elements in an array
    arr[0] = 10;
    arr[1] = 20;
    arr[2] = 30;

    // Accessing and printing elements of the array
    cout << "arr[0]: " << arr[0] << endl;
    cout << "arr[1]: " << arr[1] << endl;
    cout << "arr[2]: " << arr[2] << endl;

    return 0;
}

arr[0]: 10
arr[1]: 20
arr[2]: 30

Update Array Element

To update an element in an array, we can use the index which we want to update enclosed within the array subscript operator and assign the new value.
arr[i] = new_value;
Traverse an Array in C++

We can traverse over the array with the help of a loop using indexing in C++. First, we have initialized an array ‘table_of_two’ with a multiple of 2. After that, we run a for loop from 0 to 9 because in an array indexing starts from zero. Therefore, using the indices we print all values stored in an array.
Example 2: The C++ Program to Illustrate How to Traverse an Array
// C++ Program to Illustrate How to Traverse an Array
#include <iostream>
using namespace std;

int main()
{

    // Initialize the array
    int table_of_two[10]
        = { 2, 4, 6, 8, 10, 12, 14, 16, 18, 20 };

    // Traverse the array using for loop
    for (int i = 0; i < 10; i++) {
        // Print the array elements using indexing
        cout << table_of_two[i] << " ";
    }

    return 0;
}

2 4 6 8 10 12 14 16 18 20 

Size of an Array in C++

In C++, we do not have the length function as in Java to find array size but we can calculate the size of an array using sizeof() operator trick. First, we find the size occupied by the whole array in the memory and then divide it by the size of the type of element stored in the array. This will give us the number of elements stored in the array.
data_type size = sizeof(Array_name) / sizeof(Array_name[index]);
// C++ Program to Illustrate How to Find the Size of an
// Array
#include <iostream>
using namespace std;

int main()
{
    int arr[] = { 1, 2, 3, 4, 5 };

    // Size of one element of an array
    cout << "Size of arr[0]: " << sizeof(arr[0]) << endl;

    // Size of array 'arr'
    cout << "Size of arr: " << sizeof(arr) << endl;

    // Length of an array
    int n = sizeof(arr) / sizeof(arr[0]);

    cout << "Length of an array: " << n << endl;

    return 0;
    Size of arr[0]: 4
Size of arr: 20
Length of an array: 5
Relation between Arrays and Pointers in C++

In C++, arrays and pointers are closely related to each other. The array name is treated as a pointer that stored the memory address of the first element of the array. As we have discussed earlier, In array elements are stored at contiguous memory locations that’s why we can access all the elements of an array using the array name.
Example 4: Illustrating the Relationship between Array and Pointers
// C++ Program to Illustrate that Array Name is a Pointer
// that Points to First Element of the Array
#include <iostream>
using namespace std;

int main()
{
    // Defining an array
    int arr[] = { 1, 2, 3, 4 };

    // Define a pointer
    int* ptr = arr;

    // Printing address of the arrary using array name
    cout << "Memory address of arr: " << &arr << endl;

    // Printing address of the array using ptr
    cout << "Memory address of arr: " << ptr << endl;

    return 0;
}
Memory address of arr: 0x7fff2f2cabb0
Memory address of arr: 0x7fff2f2cabb0

Explanation:

In the above code, we first define an array “arr” and then declare a pointer “ptr” and assign the array “arr” to it. We are able to assign arr to ptr because arr is also a pointer. After that, we print the memory address of arr using reference operator (&) and also print the address stored in pointer ptr and we can see arr and ptr, both stores the same memory address. But &arr is gives the memory address of the entire array arr and arr(ptr) gives the address of the first element of array.
Example 5: Printing Array Elements without Indexing in C++

We generally access and print the array elements using indexing. For example to access the first element we use array_name[0]. We have discussed above that the array name is a pointer that stored the address of the first element and array elements are stored at contiguous locations. Now, we are going to access the elements of an array using the array name only.
// C++ Program to Print Array Elements without Indexing
#include <iostream>
using namespace std;

int main()
{

    // Define an array
    int arr[] = { 11, 22, 33, 44 };

    // Print elements of an array
    cout << "first element: " << *arr << endl;
    cout << "Second element: " << *(arr + 1) << endl;
    cout << "Third element: " << *(arr + 2) << endl;
    cout << "fourth element: " << *(arr + 3) << endl;

    return 0;
}

Explanation

In the above code, we first declared an array “arr” with four elements. After that, we are printing the array elements. Let’s discuss how we do it. We discussed that the array name is a pointer that stores the address of the first element of an array so, to print the first element we have dereferenced that pointer (*arr) using dereferencing operator (*) which prints the data stored at that address.

To print the second element of an array we first add 1 to arr which is equivalent to (address of arr + size_of_one_element *1) that takes the pointer to the address just after the first one and after that, we dereference that pointer to print the second element. Similarly, we print rest of the elements of an array without using indexing.

Passing Array to Function in C++

To use arrays efficiently we should know how to pass arrays to function. We can pass arrays to functions as an argument same as we pass variables to functions but we know that the array name is treated as a pointer using this concept we can pass the array to functions as an argument and then access all elements of that array using pointer.

So ultimately, arrays are always passed as pointers to the function. Let’s see 3 ways to pass an array to a function that are majorly used.
1. Passing Array as a Pointer

In this method, we simply pass the array name in function call which means we pass the address to the first element of the array. In this method, we can modify the array elements within the function
Syntax

return_type function_name ( data_type *array_name ) {
        // set of statements
}
2. Passing Array as an Unsized Array

In this method, the function accepts the array using a simple array declaration with no size as an argument.

Syntax

return_type function_name ( data_type array_name[] ) {
        // set of statements
}

3. Passing Array as a Sized Array
In this method, the function accepts the array using a simple array declaration with size as an argument. We use this method by sizing an array just to indicate the size of an array.

Syntax

return_type function_name(data_type array_name[size_of_array]){
        // set of statements
}

    Note: Array will be treated as a pointer in the passed function no matter what method we use. As the array are passed as pointers, they will loose the information about its size leading to a phenomenon named as Array Decay.

#include <iostream>
using namespace std;

// passing array as a sized array argument
void printArraySized(int arr[3], int n)
{
    cout << "Array as Sized Array Argument: ";
    for (int i = 0; i < n; i++) {
        cout << arr[i] << " ";
    }
    cout << endl;
}

// passing array as an unsized array argument
void printArrayUnsized(int arr[], int n)
{
    cout << "Array as Unsized Array Argument: ";
    for (int i = 0; i < n; i++) {
        cout << *(arr + i) << " ";
    }
    cout << endl;
}

// Passing array as a pointer argument
void printArrayPointer(int* ptr, int n)
{
    // Print array elements using pointer ptr
    // that store the address of array passed
    cout << "Array as Pointer Argument: ";
    for (int i = 0; i < n; i++) {
        cout << ptr[i] << " ";
    }
}

// driver code
int main()
{

    int arr[] = { 10, 20, 30 };

    // Call function printArray and pass
    // array and its size to it.
    printArraySized(arr, 3);
    printArrayUnsized(arr, 3);
    printArrayPointer(arr, 3);

    return 0;
}

Array as Sized Array Argument: 10 20 30 
Array as Unsized Array Argument: 10 20 30 
Array as Pointer Argument: 10 20 30 

Multidimensional Arrays in C++

Arrays declared with more than one dimension are called multidimensional arrays. The most widely used multidimensional arrays are 2D arrays and 3D arrays. These arrays are generally represented in the form of rows and columns.

Multidimensional Array Declaration

Data_Type Array_Name[Size1][Size2]...[SizeN];

where,

    Data_Type: Type of data to be stored in the array.
    Array_Name: Name of the array.
    Size1, Size2,…, SizeN: Size of each dimension.

Two Dimensional Array in C++

In C++, a two-dimensional array is a grouping of elements arranged in rows and columns. Each element is accessed using two indices: one for the row and one for the column, which makes it easy to visualize as a table or grid.
Syntax of 2D array

data_Type array_name[n][m];

Where,

    n: Number of rows.
    m: Number of columns.
    two dimensional array in c++

Example: The C++ Program to Illustrate the Two-Dimensional Array
// c++ program to illustrate the two dimensional array
#include <iostream>
using namespace std;

int main()
{
    // Declaring 2D array
    int arr[4][4];

    // Initialize 2D array using loop
    for (int i = 0; i < 4; i++) {
        for (int j = 0; j < 4; j++) {
            arr[i][j] = i + j;
        }
    }

    // Printing the element of 2D array
    for (int i = 0; i < 4; i++) {
        for (int j = 0; j < 4; j++) {
            cout << arr[i][j] << " ";
        }
        cout << endl;
    }

    return 0;
}
Three-Dimensional Array in C++

The 3D array uses three dimensions. A collection of various two-dimensional arrays piled on top of one another can be used to represent it. Three indices—the row index, column index, and depth index are used to uniquely identify each element in a 3D array.

Declaration of Three-Dimensional Array in C++

To declare a 3D array in C++, we need to specify its third dimension along with 2D dimensions.

Data_Type Array_Name[D][R][C];

Where,

    Data_Type: Type of data to be stored in each element.
    Array_Name: Name of the array
    D: Number of 2D arrays or Depth of array.
    R: Number of rows in each 2D array.
    C: Number of columns in each 2D array.

Example

int array[3][3][3];

three dimensional array in c++
Example: The C++ Program to Illustrate the 3d Array

// C++ program to illustrate the 3d array
#include <iostream>
using namespace std;

int main()
{

    // declaring 3d array
    int arr[3][3][3];
    // initializing the array
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++) {
            for (int k = 0; k < 3; k++) {
                arr[i][j][k] = i + j + k;
            }
        }
    }

    // printing the array
    for (int i = 0; i < 3; i++) {
        cout << i << "st layer:" << endl;
        for (int j = 0; j < 3; j++) {
            for (int k = 0; k < 3; k++) {
                cout << arr[i][j][k] << " ";
            }
            cout << endl;
        }
        cout << endl;
    }

       return 0;
}


Output

0st layer:
0 1 2 
1 2 3 
2 3 4 

1st layer:
1 2 3 
2 3 4 
3 4 5 

2st layer:
2 3 4 
3 4 5 
4 5 6 

Explanation

In the above code, we have declared a 3D array and then initialized it using three nested for loops. After that, we printed all layers of the 3D array again using three nested for loops as seen in the output.

Variable Length Arrays (VLAs) in C
In C, variable length arrays (VLAs) are also known as runtime-sized or variable-sized arrays. The size of such arrays is defined at run-time.

Variably modified types include variable-length arrays and pointers to variable-length arrays. Variably changed types must be declared at either block scope or function prototype scope.

Variable length arrays are a feature where we can allocate an auto array (on stack) of variable size. It can be used in a typedef statement. C supports variable-sized arrays from the C99 standard. For example, the below program compiles and runs fine in C.

// C program to demonstrate variable length array
#include <stdio.h>

// function to initialize array
void initialize(int* arr, int size)
{
    for (int i = 0; i < size; i++) {
        arr[i] = i + 1;
    }
}

// function to print an array
void printArray(int size)
{
    // variable length array
    int arr[size];
    initialize(arr, size);

    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
}

// driver code
int main()
{
    int n;
    printf("Enter the Size: ");
    scanf("%d", &n);
    printArray(n);

    return 0;
}
Enter the Size: 5
1 2 3 4 5 

Explanation: The above program illustrate how to create a variable size array in a function in C program. This size is passed as parameter and the variable array is created on the stack memory.


How to print size of array parameter in C++?

// A C++ program to show that it is wrong to
// compute size of an array parameter in a function
#include <iostream>
using namespace std;

void findSize(int arr[]) 
{ 
cout << sizeof(arr) << endl; 
}

int main()
{
	int a[10];
	cout << sizeof(a) << " ";
	findSize(a);
	return 0;
}

40 8

Time Complexity: O(1)  
Auxiliary Space: O(n) where n is the size of the array.

The above output is for a machine where the size of an integer is 4 bytes and the size of a pointer is 8 bytes.
The cout statement inside main() prints 40, and cout in findSize() prints 8. The reason for different outputs is that the arrays always pass pointers in functions. Therefore, findSize(int arr[]) and findSize(int *arr) mean exact same thing. Therefore the cout statement inside findSize() prints the size of a pointer.

For details, refer to the following articles:

    Do Not Use sizeof For Array Parameters in C
    Why Does C Treat Array Parameters as Pointers?

How to find the size of an array in function?

We can pass a ‘reference to the array’.

// A C++ program to show that we can use reference to
// find size of array
#include <iostream>
using namespace std;

void findSize(int (&arr)[10])
{
	cout << sizeof(arr) << endl;
}

int main()
{
	int a[10];
	cout << sizeof(a) << " ";
	findSize(a);
	return 0;
}

40 40

Time Complexity: O(1)
Space Complexity: O(n) where n is the size of the array.

The above program isn’t appealing as we have used the hardcoded size of the array parameter. 
We can do it better using templates in C++

We can use templates to define the function instead of using the hardcoded size.


// A C++ program to show that we use template and
// reference to find size of integer array parameter
#include <iostream>
using namespace std;

template <size_t n>
void findSize(int (&arr)[n])
{
	cout << sizeof(int) * n << endl;
}

int main()
{
	int a[10];
	cout << sizeof(a) << " ";
	findSize(a);
	return 0;
}

40 40

Time Complexity: O(1)
Space Complexity: O(n) where n is the size of the array.
We can make a generic function as well

// A C++ program to show that we use template and
// reference to find size of any type array parameter
#include <iostream>
using namespace std;

template <typename T, size_t n>
void findSize(T (&arr)[n])
{
	cout << sizeof(T) * n << endl;
}

int main()
{
	int a[10];
	cout << sizeof(a) << " ";
	findSize(a);

	float f[20];
	cout << sizeof(f) << " ";
	findSize(f);
	return 0;
}

40 40
80 80

Time Complexity: O(1)
Space Complexity: O(n) where n is the size of array.
Now the next step is to print the size of a dynamically allocated array. 

It’s your task man! I’m giving you a hint.

#include <iostream>
#include <cstdlib>
using namespace std;
 
int main()
{
    int *arr = (int*)malloc(sizeof(int) * 20);
    return 0;
    
    What is Array Decay in C++? How can it be prevented?
    What is Array Decay? 
The loss of type and dimensions of an array is known as decay of an array. This generally occurs when we pass the array into function by value or pointer. What it does is, it sends first address to the array which is a pointer, hence the size of array is not the original one, but the one occupied by the pointer in the memory.

// C++ code to demonstrate array decay
#include <iostream>
using namespace std;

// Driver function to show Array decay
// Passing array by value
void aDecay(int* p)
{
    // Printing size of pointer
    cout << "Modified size of array is by "
            " passing by value: ";
    cout << sizeof(p) << endl;
}

int main()
{
    int a[7] = {
        1, 2, 3, 4, 5, 6, 7,
    };

    // Printing original size of array
    cout << "Actual size of array is: ";
    cout << sizeof(a) << endl;

    // Passing a pointer to array
    aDecay(a);

    return 0;
}
Actual size of array is: 28
Modified size of array is by  passing by value: 8

In the above code, the actual array has 7 int elements and hence has 28 size. But by calling by value and pointer, array decays into pointer and prints the size of 1 pointer i.e. 8 (4 in 32 bit).

Another way to prevent array decay is to send the array into functions by reference. This prevents conversion of array into a pointer, hence prevents the decay.
// C++ code to demonstrate prevention of
// decay of array
#include<iostream>
using namespace std;

// A function that prevents Array decay
// by passing array by reference
void fun(int (&p)[7])
{
    // Printing size of array
    cout << "Modified size of array by "
            "passing by reference: ";
    cout << sizeof(p) << endl;
}

int main()
{
    int a[7] = {1, 2, 3, 4, 5, 6, 7,};

    // Printing original size of array
    cout << "Actual size of array is: ";
    cout << sizeof(a) <<endl;

    // Calling function by reference
    fun(a);

    return 0;
}

Actual size of array is: 28
Modified size of array by passing by reference: 28


In the above code, passing array by reference solves the problem of decay of array. Sizes in both cases is 28. 

We can also preserve the size of the array by passing it as a pointer to the array which have one more dimension as compared to our array
// C++ code to demonstrate array decay
#include <iostream>
using namespace std;

// Function to show that array decay happens
// even if we use pointer
void pDecay(int (*p)[7])
{
    // Printing size of array
    cout << "Modified size of array by "
            "passing by pointer: ";
    cout << sizeof(p) << endl;
}

int main()
{
    int a[7] = { 1, 2, 3, 4, 5, 6, 7 };

    // Printing original size of array
    cout << "Actual size of array is: ";
    cout << sizeof(a) << endl;

    // Passing a pointer to array
    pDecay(&a);

    return 0;
}

Actual size of array is: 28
Modified size of array by passing by pointer: 8

But in this case, we will have to treat the array in the function as 2d array and to access the value stored in the array, we have to access it like this: arr[0][1], arr[0][3], .. and so on.

### **📌 Concise Notes on `vector<int>` in C++**  

---

### **🔹 What is a `vector<int>`?**  
A **vector** is a **dynamic array** in C++ that can resize itself automatically when needed. It is part of the **Standard Template Library (STL)** and provides various built-in functions for easier manipulation of elements.

---

### **🔹 Why Use `vector<int>` Over Arrays?**  

| Feature            | `vector<int>` | `int arr[n]` (Array) |
|--------------------|--------------|----------------------|
| **Size**          | Dynamic (Auto-expanding) | Fixed at compile-time |
| **Memory Management** | Automatic | Manual |
| **Ease of Use**   | Built-in functions (push, pop, etc.) | No built-in functions |
| **Safety**        | Checks for out-of-bounds access (via `.at()`) | No safety checks |
| **Resizing**      | Can grow/shrink dynamically | Cannot resize |

---

### **🔹 Declaration & Initialization**
```cpp
vector<int> v;        // Empty vector  
vector<int> v(5);     // Vector of size 5 (default 0)  
vector<int> v(5, 10); // Vector of size 5, all elements = 10  
vector<int> v = {1, 2, 3, 4, 5}; // Initialize with values  
```

---

### **🔹 Input & Output**
```cpp
int n;
cin >> n;
vector<int> v(n);  // Declare vector of size n
for (int i = 0; i < n; i++) cin >> v[i];  // Input
for (int x : v) cout << x << " ";  // Print using range-based loop
```

---

### **🔹 Adding & Removing Elements**
```cpp
v.push_back(10);   // Add 10 to the end  
v.pop_back();      // Remove last element  
v.clear();         // Remove all elements  
```

---

### **🔹 Checking Size & Accessing Elements**
```cpp
cout << v.size();  // Get number of elements  
cout << v[2];      // Access 3rd element  
cout << v.at(2);   // Safe access (checks bounds)  
```

---

### **🔹 Looping Over a Vector**
```cpp
for (int i = 0; i < v.size(); i++) cout << v[i] << " ";  
for (int x : v) cout << x << " ";  // For-each loop  
```

---

### **🔹 When to Use `vector<int>`?**
✅ When you **don’t know the size** beforehand.  
✅ When you **need dynamic resizing**.  
✅ When you **want built-in functions** for efficiency.  

**✨ `vector<int>` is a powerful, flexible, and safer alternative to arrays!** 🚀

 Strings in C++
 In C++, strings are sequences of characters that are used to store words and text. They are also used to store data, such as numbers and other types of information in the form of text. Strings are provided by <string> header file in the form of std::string class.

Creating a String

Creating a string means creating an instance of std::string class as shown:
string str_name;

where str_name is the name of the string.
Initializing a String

Initializing means assigning some initial value to the string. This can be done by using assignment operator and the text enclosed inside “” double quotes.
Initializing a String

Initializing means assigning some initial value to the string. This can be done by using assignment operator and the text enclosed inside “” double quotes.
string str = "Some Text here";

The text inside “” is called string literal and it is the value that is assigned to the string variables. It doesn’t need to have any meaning. It can be any text that is the sequence of characters from the ASCII charset.
Accessing String

A string can be referred using its name anywhere in the scope once it is declared. For example, the below example prints string using cout:
#include <iostream>
using namespace std;

int main() {
    
    // Creating a string
    string greeting = "Welcome to GfG!";
    
    // Accessing string
    cout << greeting;

    return 0;
}

Welcome to GfG!

The individual characters of the strings can also be accessed using their position (or index) like arrays with [] square brackets. The index in C++ starts from 0 and goes till size – 1, so be careful not go outside this limit.
The individual characters of the strings can also be accessed using their position (or index) like arrays with [] square brackets. The index in C++ starts from 0 and goes till size – 1, so be careful not go outside this limit.
#include <iostream>
using namespace std;

int main() {
    string str = "Sonu";
    
    // Accessing 3rd character
    cout << str[2] << endl;
    
    // Accessing first character
    cout << str[0];

    return 0;
}

n
S
Updating String

The string variable can be updated store a new string literal in a similar way it is initialized.
#include <iostream>
using namespace std;

int main() {
    string str = "Tara";
    cout << str << endl;
    
    // Updating string
    str = "Singh";
    cout << str;

    return 0;
}

#include <iostream>
using namespace std;

int main() {
    string str = "Tara";
    
    // Updating second character
    str[1] = 'o';
    cout << str;

    return 0;
}

	Pass Strings to Functions

The string can be passed to a function in the same was as any other type of variable.
#include <iostream>
using namespace std;

// Taking string as argument
void print(string s) {
    cout << s;
    return;
}

int main() {
    string s = "GeeksforGeeks";
    
    // Passing string
    print(s);
    return 0;
}

C Style Strings

C++ is a superset of C language, so it also inherits the way in which we used to create strings in C. In C, strings were nothing, but an array of characters terminated by a NULL character ‘\0’. They were created as:
char str[] = "Hello";

Due to being array, there were limitations on C strings:

    Fixed Size: Once declared, the size of the C string cannot be changed.
    Lack of Easy String Operations: No high-level operations like concatenation or substring extraction. Moreover, updating was also complex.

C++ strings resolve this issue by providing a lot of operations that are easy to perform. Internally, these strings are still implemented as dynamic array of characters (or more precisely vectors) Thats why we can access a single character by its index. But the std::string class act as a wrapper and provides lot of built-in functionality for easier and more efficient handling of strings.

C++ String vs C Strings

The main difference between a string and a character array is that strings are immutable, while character arrays are not.

String
	

Character Array
Strings define objects that can be represented as string streams.	The null character terminates a character array of characters.
No Array decay occurs in strings as strings are represented as objects.	

The threat of array decay is present in the case of the character array.
A string class provides numerous functions for manipulating strings.	Character arrays do not offer inbuilt functions to manipulate strings.
Memory is allocated dynamically.	The size of the character array has to be allocated statically. 
C++ String Functions

C++ provides some inbuilt functions which are used for string manipulation, such as the strcpy() and strcat() functions for copying and concatenating strings. Some of them are:
Function
	

Description
length()	This function returns the length of the string.
swap() 	This function is used to swap the values of 2 strings.
size() 	Used to find the size of string
resize()	This function is used to resize the length of the string up to the given number of characters.
find()	Used to find the string which is passed in parameters
push_back()	This function is used to push the passed character at the end of the string
pop_back() 	This function is used to pop the last character from the string
clear() 	This function is used to remove all the elements of the string.
strncmp()	This function compares at most the first num bytes of both passed strings.
strncpy()	This function is similar to strcpy() function, except that at most n bytes of src are copied
strrchr()	This function locates the last occurrence of a character in the string.
strcat()	This function appends a copy of the source string to the end of the destination string
find()	This function is used to search for a certain substring inside a string and returns the position of the first character of the substring. 
replace()	This function is used to replace each element in the range [first, last) that is equal to old value with new value.
substr()	This function is used to create a substring from a given string. 
compare()	This function is used to compare two strings and returns the result in the form of an integer.
erase()	This function is used to remove a certain part of a string.

rfind()
	

This function is used to find the string’s last occurrence.
 A string is a class that defines objects that be represented as a stream of characters.	A character array is simply an array of characters that can be terminated by a null character.
In the case of strings, memory is allocated dynamically. More memory can be allocated at run time on demand. As no memory is preallocated, no memory is wasted.	The size of the character array has to be allocated statically, more memory cannot be allocated at run time if required. Unused allocated memory is also wasted
As strings are represented as objects, no array decay occurs.	There is a threat of array decay in the case of the character array. 
Strings are slower when compared to implementation than character array.	Implementation of character array is faster than std:: string. 
String class defines a number of functionalities that allow manifold operations on strings.	Character arrays do not offer many inbuilt functions to manipulate strings.
getline()	This function is used to store a stream of characters as entered by the user in the object memory.
push_back()	This function is used to input a character at the end of the string.
pop_back()	Introduced from C++11(for strings), this function is used to delete the last character from the string. 

// C++ Program to demonstrate the working of
// getline(), push_back() and pop_back()
#include <iostream>
#include <string> // for string class
using namespace std;

// Driver Code
int main()
{
    // Declaring string
    string str;

    // Taking string input using getline()
    getline(cin, str);

    // Displaying string
    cout << "The initial string is : ";
    cout << str << endl;

    // Inserting a character
    str.push_back('s');

    // Displaying string
    cout << "The string after push_back operation is : ";
    cout << str << endl;

    // Deleting a character
    str.pop_back();

    // Displaying string
    cout << "The string after pop_back operation is : ";
    cout << str << endl;

    return 0;
}

The initial string is : 
The string after push_back operation is : s
The string after pop_back operation is : 
Time Complexity: O(1)

Space Complexity: O(n) where n is the size of the string
2) Capacity Functions
Function	Definition
capacity()	This function returns the capacity allocated to the string, which can be equal to or more than the size of the string. Additional space is allocated so that when the new characters are added to the string, the operations can be done efficiently.
resize()	This function changes the size of the string, the size can be increased or decreased.
length()	This function finds the length of the string.
shrink_to_fit()	This function decreases the capacity of the string and makes it equal to the minimum capacity of the string. This operation is useful to save additional memory if we are sure that no further addition of characters has to be made.
// C++ Program to demonstrate the working of
// capacity(), resize() and shrink_to_fit()
#include <iostream>
#include <string> // for string class
using namespace std;

// Driver Code
int main()
{
    // Initializing string
    string str = "geeksforgeeks is for geeks";

    // Displaying string
    cout << "The initial string is : ";
    cout << str << endl;

    // Resizing string using resize()
    str.resize(13);

    // Displaying string
    cout << "The string after resize operation is : ";
    cout << str << endl;

    // Displaying capacity of string
    cout << "The capacity of string is : ";
    cout << str.capacity() << endl;

    // Displaying length of the string
    cout << "The length of the string is :" << str.length()
         << endl;

    // Decreasing the capacity of string
    // using shrink_to_fit()
    str.shrink_to_fit();

    // Displaying string
    cout << "The new capacity after shrinking is : ";
    cout << str.capacity() << endl;

    return 0;
}

3) Iterator Functions
Function	Definition
begin()	This function returns an iterator to the beginning of the string.
end()	This function returns an iterator to the next to the end of the string.
rbegin()	This function returns a reverse iterator pointing at the end of the string.
rend()	This function returns a reverse iterator pointing to the previous of beginning of the string.
cbegin()	This function returns a constant iterator pointing to the beginning of the string, it cannot be used to modify the contents it points-to.
cend()	This function returns a constant iterator pointing to the next of end of the string, it cannot be used to modify the contents it points-to.
crbegin()	This function returns a constant reverse iterator pointing to the end of the string, it cannot be used to modify the contents it points-to.
crend()	This function returns a constant reverse iterator pointing to the previous of beginning of the string, it cannot be used to modify the contents it points-to.

    Algorithm:

        Declare a string
        Try to iterate the string using all types of iterators
        Try modification of the element of the string.
        Display all the iterations.
        // C++ Program to demonstrate the working of
// begin(), end(), rbegin(), rend(), cbegin(), cend(), crbegin(), crend()
#include <iostream>
#include <string> // for string class
using namespace std;

// Driver Code
int main()
{
    // Initializing string`
    string str = "geeksforgeeks";

    // Declaring iterator
    std::string::iterator it;

    // Declaring reverse iterator
    std::string::reverse_iterator it1;
    cout<<"Str:"<<str<<"\n";
    // Displaying string
    cout << "The string using forward iterators is : ";
    for (it = str.begin(); it != str.end(); it++){
        if(it == str.begin()) *it='G';
        cout << *it;
    }
    cout << endl;

      str = "geeksforgeeks";
    // Displaying reverse string
    cout << "The reverse string using reverse iterators is "
            ": ";
    for (it1 = str.rbegin(); it1 != str.rend(); it1++){
        if(it1 == str.rbegin()) *it1='S';
        cout << *it1;
    }
    cout << endl;
  
  str = "geeksforgeeks";
  //Displaying String
  cout<<"The string using constant forward iterator is :";
  for(auto it2 = str.cbegin(); it2!=str.cend(); it2++){
        //if(it2 == str.cbegin()) *it2='G';
        //here modification is NOT Possible
        //error: assignment of read-only location 
        //As it is a pointer to the const content, but we can inc/dec-rement the iterator
        cout<<*it2;
  }
  cout<<"\n";
  
  str = "geeksforgeeks";
  //Displaying String in reverse
  cout<<"The reverse string using constant reverse iterator is :";
  for(auto it3 = str.crbegin(); it3!=str.crend(); it3++){
        //if(it2 == str.cbegin()) *it2='S';
        //here modification is NOT Possible
        //error: assignment of read-only location 
        //As it is a pointer to the const content, but we can inc/dec-rement the iterator
        cout<<*it3;
  }
  cout<<"\n";

    return 0;
}

//Code modified by Balakrishnan R (rbkraj000)

Str:geeksforgeeks
The string using forward iterators is : Geeksforgeeks
The reverse string using reverse iterators is : Skeegrofskeeg
The string using constant forward iterator is :geeksforgeeks
The reverse string using constant reverse iterator is :skeegrofskeeg

Time Complexity: O(1)

Space Complexity: O(n) where n is the size of the string

4) Manipulating Functions:
Function	Definition
copy(“char array”, len, pos) 	This function copies the substring in the target character array mentioned in its arguments. It takes 3 arguments, target char array, length to be copied, and starting position in the string to start copying.
swap()	This function swaps one string with another
// C++ Program to demonstrate the working of
// copy() and swap()
#include <iostream>
#include <string> // for string class
using namespace std;

// Driver Code
int main()
{
    // Initializing 1st string
    string str1 = "geeksforgeeks is for geeks";

    // Declaring 2nd string
    string str2 = "geeksforgeeks rocks";

    // Declaring character array
    char ch[80];

    // using copy() to copy elements into char array
    // copies "geeksforgeeks"
    str1.copy(ch, 13, 0);

    // Displaying char array
    cout << "The new copied character array is : ";
    cout << ch << endl;

    // Displaying strings before swapping
    cout << "The 1st string before swapping is : ";
    cout << str1 << endl;
    cout << "The 2nd string before swapping is : ";
    cout << str2 << endl;

    // using swap() to swap string content
    str1.swap(str2);

    // Displaying strings after swapping
    cout << "The 1st string after swapping is : ";
    cout << str1 << endl;
    cout << "The 2nd string after swapping is : ";
    cout << str2 << endl;

    return 0;
}

The new copied character array is : geeksforgeeks
The 1st string before swapping is : geeksforgeeks is for geeks
The 2nd string before swapping is : geeksforgeeks rocks
The 1st string after swapping is : geeksforgeeks rocks
The 2nd string after swapping is : geeksforgeeks is for geeks

Array of Strings in C++
In C++, a string is sequence of characters that is used to store textual information. Internally, it is implemented as a dynamic array of characters. Array of strings is the array in which each element is a string.

We can easily create an array of string in C++ as shown in the below example:
#include <iostream>
using namespace std;

int main() {
  
      // Array of C++ style strings
    string arr[3] = {"This", "is", "array"};
  
      for (int i = 0; i < 3; i++)
          cout << arr[i] << " ";
    return 0;
}

This is array 

In the above program, we have created an array of strings arr. It is initialized with 3 strings which are then printed using loops.
Syntax

The general syntax of array of strings is:

    string arr_name[size]

where arr_name is the name assigned to the array and size is the desired size.

Understanding how to create and manage arrays of strings is essential in C++. The C++ Course covers five different methods for creating arrays of strings, helping you choose the right approach for your needs.
Problem with C Style Strings

The C style strings are nothing but the fixed size array of characters terminated by null characters. Due to this, following limitations arise:

    Cannot assign new string to any element. Have to use strcpy().
    If 2D array is used, it results in unused extra space.

This issue is discussed in this article – Array of Strings in C

But as C++ strings are dynamic, there is no space wastage issue as each string only occupies the requires space and these can be updated anytime without worrying about the allocated size. For example, we can modify and update the elements of the array arr simply by using the assignment operator:
#include <iostream>
using namespace std;

int main() {
    string arr[3] = {"This", "is", "array"};
  
      // Modifying strings
      arr[2] = "sparta";
      for (int i = 0; i < 3; i++)
          cout << arr[i] << " ";
    return 0;
}

This is sparta 
Problem with C Style Strings

The C style strings are nothing but the fixed size array of characters terminated by null characters. Due to this, following limitations arise:

    Cannot assign new string to any element. Have to use strcpy().
    If 2D array is used, it results in unused extra space.

This issue is discussed in this article – Array of Strings in C

But as C++ strings are dynamic, there is no space wastage issue as each string only occupies the requires space and these can be updated anytime without worrying about the allocated size. For example, we can modify and update the elements of the array arr simply by using the assignment operator:
#include <iostream>
using namespace std;

int main() {
    string arr[3] = {"This", "is", "array"};
  
      // Modifying strings
      arr[2] = "sparta";
      for (int i = 0; i < 3; i++)
          cout << arr[i] << " ";
    return 0;
}

Vector of Strings

There is also some problem with this array. The number of strings to be stored will remain same once it is declared i.e. the size of the array remains same. One thing we can do is to create a dynamic array change the size every time we want to insert or delete. But a better way to avoid this manual operation is just using vector container.
#include <bits/stdc++.h>
using namespace std;

int main() {
  
      // Create a vector of strings
    vector<string> v{ "This", "is", "vector" };

    // Add one more string
    v.push_back("container");

    for (int i = 0; i < v.size(); i++)
        cout << v[i] << " ";
    return 0;
}

This is vector container 

In this program, a vector of strings named v is created and initialized with three strings: “This”, “is”, and “vector”. The push_back() function is then used to add another string, “container“, to the vector. This shows the example of automatically resizable container for holding multiple strings.
Different Ways to Create Array of Strings

Above shown are the most preferred technique to create array of string but there are also some other ways as shown:
1. Using Array of Pointers

Pointers are the symbolic representation of an address. In simple words, a pointer is something that stores the address of a variable in it. In this method, an array of string literals is created by an array of pointers in which each pointer points to a particular string.
#include <iostream>
using namespace std;

int main() {
    
    // Initialize array of pointer
    const char* colour[4]
        = { "Blue", "Red", "Orange", "Yellow" };

    for (int i = 0; i < 4; i++)
        cout << colour[i] << "\n";
    return 0;
}

lue
Red
Orange
Yellow
A 2-D array is the simplest form of a multidimensional array in which it stores the data in a tabular form. This method is useful when the length of all strings is known, and a particular memory footprint is desired. Space for strings will be allocated in a single block.

#include <iostream>
using namespace std;

int main() {
    
    // Initialize 2D array
    char colour[4][10]
        = { "Blue", "Red", "Orange", "Yellow" };

    // Printing Strings stored in 2D array
    for (int i = 0; i < 4; i++)
        cout << colour[i] << "\n";
    return 0;
}
Blue
Red
Orange
Yellow


String Concatenation in C++



String concatenation refers to the process of combining two or more strings into a single string. Generally, one string is appended at the end of the other string. In this article, we will learn how to concatenate two strings in C++.

The simplest method to concatenate two strings in C++ is by using + operator. Let’s take a look at an example:

String concatenation refers to the process of combining two or more strings into a single string. Generally, one string is appended at the end of the other string. In this article, we will learn how to concatenate two strings in C++.

The simplest method to concatenate two strings in C++ is by using + operator. Let’s take a look at an example:
Hello World

Explanation: The ‘+’ operator combines two string objects and returns the resulting concatenated string. However, this method only works for C++ style strings (std::string) and is not applicable to C-style character arrays.

There are also many other different ways to concatenate two strings in C++:

Table of Content

    Using String append()
    Using strcat()
    Using for Loop

Using String append()

The string append() function is a member of the string class that is used to concatenate two string objects in C++. It provides an efficient way to concatenate two strings.
Hello World

Explanation: The ‘+’ operator combines two string objects and returns the resulting concatenated string. However, this method only works for C++ style strings (std::string) and is not applicable to C-style character arrays.

There are also many other different ways to concatenate two strings in C++:

Table of Content

    Using String append()
    Using strcat()
    Using for Loop

Using String append()

The string append() function is a member of the string class that is used to concatenate two string objects in C++. It provides an efficient way to concatenate two strings.
Hello World

When to use?

Use this method when you need an efficient, in-place concatenation of std::string objects.
Using strcat()

The strcat() function is a standard library function in C that is also available in C++. It is used to concatenate (append) one C-style string (character array) to another and adds a null terminator at the end. It is defined inside the <cstring> header file.

#include <bits/stdc++.h>
using namespace std;

int main() {
    char s1[] = "Hello";
    char s2[] = " World";

    // Concatenating s1 and s2
    strcat(s1, s2);

    cout << s1;
    return 0;
}


Output

Hello World

When to use?

Use this method when concatenating C-style strings (character arrays). Also suitable for legacy code that may run in C compilers.
Using for Loop

In this method, characters from one string are appended manually one by one to another while iterating through both strings using loops. The final result is a concatenated string that combines both original string.
When to use?

Use this method when concatenating C-style strings (character arrays). Also suitable for legacy code that may run in C compilers.
Using for Loop

In this method, characters from one string are appended manually one by one to another while iterating through both strings using loops. The final result is a concatenated string that combines both original string.
Hello World

When to use?

Use this method when concatenating C-style strings (character arrays). Also suitable for legacy code that may run in C compilers.
	Using for Loop

In this method, characters from one string are appended manually one by one to another while iterating through both strings using loops. The final result is a concatenated string that combines both original string
#include <bits/stdc++.h>
using namespace std;

int main() {
    string s1("Hello");
    string s2(" World");

    // Adding characters of s2 at the end of s1
    for (auto i : s2)
        s1 += i;

    cout << s1;
    return 0;
}

Hello World

When to use?

Use this method for manual control over concatenation, such as with custom string structures or some processing before concatenation. It is also suitable when direct library functions aren’t available or for specific logic during concatenation.

Tokenizing a string in C++
Tokenizing a string denotes splitting a string with respect to some delimiter(s). There are many ways to tokenize a string.

In this article four of them are explained:

Using stringstream
A stringstream associates a string object with a stream allowing you to read from the string as if it were a stream.

Below is the C++ implementation 
// Tokenizing a string using stringstream
#include <bits/stdc++.h>

using namespace std;

int main()
{
    
    string line = "GeeksForGeeks is a must try";
    
    // Vector of string to save tokens
    vector <string> tokens;
    
    // stringstream class check1
    stringstream check1(line);
    
    string intermediate;
    
    // Tokenizing w.r.t. space ' '
    while(getline(check1, intermediate, ' '))
    {
        tokens.push_back(intermediate);
    }
    
    // Printing the token vector
    for(int i = 0; i < tokens.size(); i++)
        cout << tokens[i] << '\n';
}

GeeksForGeeks
is
a
must
try

Time Complexity: O(n ) where n is the length of string.
Auxiliary Space: O(n-d) where n is the length of string and d is the number of delimiters.
// Splits str[] according to given delimiters.
// and returns next token. It needs to be called
// in a loop to get all tokens. It returns NULL
// when there are no more tokens.
char * strtok(char str[], const char *delims);
// C/C++ program for splitting a string
// using strtok()
#include <stdio.h>
#include <string.h>

int main()
{
    char str[] = "Geeks-for-Geeks";

    // Returns first token 
    char *token = strtok(str, "-");

    // Keep printing tokens while one of the
    // delimiters present in str[].
    while (token != NULL)
    {
        printf("%s\n", token);
        token = strtok(NULL, "-");
    }

    return 0;
}

Geeks
for
Geeks

Time Complexity: O(n ) where n is the length of string.
Auxiliary Space: O(1)
// C code to demonstrate working of
// strtok
#include <string.h>
#include <stdio.h>

// Driver function
int main()
{
 // Declaration of string
    char gfg[100] = " Geeks - for - geeks - Contribute";

    // Declaration of delimiter
    const char s[4] = "-";
    char* tok;

    // Use of strtok
    // get first token
    tok = strtok(gfg, s);

    // Checks for delimiter
    while (tok != 0) {
        printf(" %s\n", tok);

        // Use of strtok
        // go through other tokens
        tok = strtok(0, s);
    }

    return (0);
}

  Geeks 
  for 
  geeks 
  Contribute

Time Complexity: O(n ) where n is the length of string.
Auxiliary Space: O(1).
Using strtok_r()

Just like strtok() function in C, strtok_r() does the same task of parsing a string into a sequence of tokens. strtok_r() is a reentrant version of strtok().

There are two ways we can call strtok_r() 

// The third argument saveptr is a pointer to a char * 
// variable that is used internally by strtok_r() in 
// order to maintain context between successive calls
// that parse the same string.
char *strtok_r(char *str, const char *delim, char **saveptr)
Below is a simple C++ program to show the use of strtok_r() : 

// C/C++ program to demonstrate working of strtok_r()
// by splitting string based on space character.
#include<stdio.h>
#include<string.h>

int main()
{
    char str[] = "Geeks for Geeks";
    char *token;
    char *rest = str;

    while ((token = strtok_r(rest, " ", &rest)))
        printf("%s\n", token);

    return(0);
}


Geeks
for
Geeks

Time Complexity: O(n ) where n is the length of string.
Auxiliary Space: O(1).
Using std::sregex_token_iterator

In this method the tokenization is done on the basis of regex matches. Better for use cases when multiple delimiters are needed.

Below is a simple C++ program to show the use of std::sregex_token_iterator:
// CPP program for above approach
#include <iostream>
#include <regex>
#include <string>
#include <vector>

/**
 * @brief Tokenize the given vector 
   according to the regex
 * and remove the empty tokens.
 *
 * @param str
 * @param re
 * @return std::vector<std::string>
 */
std::vector<std::string> tokenize(
                     const std::string str,
                          const std::regex re)
{
    std::sregex_token_iterator it{ str.begin(), 
                             str.end(), re, -1 };
    std::vector<std::string> tokenized{ it, {} };

    // Additional check to remove empty strings
    tokenized.erase(
        std::remove_if(tokenized.begin(), 
                            tokenized.end(),
                       [](std::string const& s) {
                           return s.size() == 0;
                       }),
        tokenized.end());

    return tokenized;
}

// Driver Code
int main()
{
    const std::string str = "Break string 
                   a,spaces,and,commas";
    const std::regex re(R"([\s|,]+)");
  
    // Function Call
    const std::vector<std::string> tokenized = 
                           tokenize(str, re);
  
    for (std::string token : tokenized)
        std::cout << token << std::endl;
    return 0;
}

Break
string
a
spaces
and
commas

Time Complexity: O(n * d) where n is the length of string and d is the number of delimiters.
Auxiliary Space: O(n
Substring in C++
The substring function is used for handling string operations like strcat(), append(), etc. It generates a new string with its value initialized to a copy of a sub-string of this object. In C++, the header file which is required for  std::substr(), string functions is <string>. 

The substring function takes two values pos and len as an argument and returns a newly constructed string object with its value initialized to a copy of a sub-string of this object. Copying of string starts from pos and is done till pos+len means [pos, pos+len).
string substr (size_t pos, size_t len) const;
Parameters:

    pos: Index of the first character to be copied.
    len: Length of the sub-string.
    size_t: It is an unsigned integral type.

Return Value: It returns a string object.

Example:
// C++ program to demonstrate functioning of substr()
#include <iostream>
#include <string>
using namespace std;

int main()
{
    // Take any string
    string s1 = "Geeks";

    // Copy two characters of s1 (starting
    // from index 3)
    string r = s1.substr(3, 2);

    // prints the result
    cout << "String is: " << r;

    return 0;
}

String is: ks

    Time complexity: O(N)
    Auxiliary Space: O(N)

More examples:

string: "h  e  l  l  o   w  o  r  l  d"
index:   0 1 2 3 4  5  6  7 8  9 10  

if we write: –

    s.substr(s.begin(),3)  => compilation error 🙂  (because cannnot convert a iterator to a int datatype )
    s.substr(2,3) =>  llo   (three letter from 2nd index)
    s.substr(*s.begin()-s[0],3)  => hel   (*s.begin() is ‘h’ then ‘h’-s[0]=> ‘h’-‘h’=0 means substr(0,3) —– three letter from zeroth index
    s.substr(5,1)  => ‘ ‘  (prints blank space , that is at 5th index)
    s.substr(2,0)  => (not output)  (selects zero letters from second index)
    Important Points to Remember

    The index of the first character is 0 (not 1).
    If pos is equal to the string length, the function returns an empty string.
    If pos is greater than the string length, it throws out_of_range. If this happens, there are no changes in the string.
    If the requested sub-string len is greater than the size of a string, then returned sub-string is [pos, size()).
    If len is not passed as a parameter, then returned sub-string is [pos, size()).

Applications of Substring

    Get a Sub-String after a character
    Get a Sub-String before a character
    Print all Sub-Strings of a given String
    Sum of all Substrings of a string representing a number
    Print the maximum value of all substrings of a string representing a number
    Print the minimum value of all substrings of a string representing a number

Get a Sub-String after a Character

In this, a string and a character are given and you have to print the sub-string followed by the given character. 
Extract everything after the “:” in the string “dog:cat“.
// C++ program to demonstrate functioning of substr()
#include <iostream>
#include <string>
using namespace std;

int main()
{
    // Take any string
    string s = "dog:cat";

    // Find position of ':' using find()
    int pos = s.find(":");

    // Copy substring after pos
    string sub = s.substr(pos + 1);

    // prints the result
    cout << "String is: " << sub;

    return 0;
}

Time complexity: O(N)

Auxiliary Space: O(N)                    
How to Get a SubString Before a Character?

In this, a string and a character are given and you have to print the sub-string followed by the given character. 

Example:
// C++ program to demonstrate functioning of substr()
#include <iostream>
#include <string>
using namespace std;

int main()
{
    // Take any string
    string s = "dog:cat";

    // Find position of ':' using find()
    int pos = s.find(":");

    // Copy substring before pos
    // Extract everything before the ":" in the string
    // "dog:cat".
    string sub = s.substr(0, pos);

    // prints the result
    cout << "String is: " << sub;

    return 0;
}

String is: dog

Time complexity: O(N)

Auxiliary Space: O(N)
How to Print all Sub-Strings of a Given String?

Given a string as an input. We need to write a program that will print all non-empty substrings of that given string.


// C++ program to demonstrate all possible
// substrings of a given string
#include <bits/stdc++.h>
using namespace std;

// Function to print all sub strings
void subString(string s, int n)
{
    // Pick starting point in outer loop
    // and lengths of different strings for
    // a given starting point
    for (int i = 0; i < n; i++)
        for (int len = 1; len <= n - i; len++)
            cout << s.substr(i, len) << endl;
}

// Driver program to test above function
int main()
{
    string s = "abcd";
    subString(s, s.length());
    return 0;
}

a
ab
abc
abcd
b
bc
bcd
c
cd
d

Time complexity: O( N3 )

Auxiliary Space: O(1)
Print Sum of all Substrings of a String Representing a Number

Given an integer represented as a string, we need to get the sum of all possible substrings of this string.
// C++ program to print sum of all possible substring of
// a number represented as a string
#include <bits/stdc++.h>
using namespace std;

// Utility method to convert character digit to
// integer digit
int toDigit(char ch) { return (ch - '0'); }

// Returns sum of all substring of num
int sumOfSubstrings(string s)
{
    vector<int> v;
    int n = s.length();
    for (int i = 0; i < n; i++) {
        for (int len = 1; len <= n - i; len++) {
            string sub = (s.substr(i, len));
            int x = stoi(sub);
            v.push_back(x);
        }
    }
    int res = accumulate(v.begin(), v.end(), 0);

    return res;
}

// Driver code to test above methods
int main()
{
    string num = "1234";
    cout << sumOfSubstrings(num) << endl;
    return 0;
}

1670

Time Complexity: O(N3)
Auxiliary Space: O(N)
Print the Maximum Value of all Substrings of a String Representing a Number

Given an integer represented as a string, we need to get the maximum of all possible substrings of the given string which represents a number.

Example:
// C++ program to demonstrate max. of all possible
// substrings of a given string
#include <bits/stdc++.h>
using namespace std;

void subString(string s, int n)
{
    vector<int> v;
    for (int i = 0; i < n; i++) {
        for (int len = 1; len <= n - i; len++) {
            string sub = (s.substr(i, len));
            int x = stoi(sub);
            v.push_back(x);
        }
    }
    cout << *max_element(v.begin(), v.end()) << endl;
}

// Driver program to test above function
int main()
{
    string s = "823";
    subString(s, s.length());
    return 0;
}

Explanation: All substrings are { 8, 82, 823, 2, 23, 3 } and the maximum value substring is 823.

Time complexity: O(N3)

Auxiliary space: O(N!)
Print the Minimum Value of all Substrings of a String Representing a Number

Given an integer represented as a string, we need to get the minimum of all possible substrings of the given string which represents a number.

Example:
// C++ program to demonstrate minimum of all possible
// substrings of a given string
#include <bits/stdc++.h>
using namespace std;

void subString(string s, int n)
{
    vector<int> v;
    for (int i = 0; i < n; i++) {
        for (int len = 1; len <= n - i; len++) {
            string sub = (s.substr(i, len));
            int x = stoi(sub);
            v.push_back(x);
        }
    }
    cout << *min_element(v.begin(), v.end()) << endl;
}

// Driver program to test above function
int main()
{
    string s = "4572";
    subString(s, s.length());
    return 0;
}

Time complexity: O(N3)
Auxiliary space: O(N!)
Other Applications of Substring

    Text Searching: Substrings are used to search for words or phrases in larger bodies of text. This is commonly used in search engines, where a user might type in a phrase or keyword and the engine will search for any matches containing that substring.
    Text Parsing: Substrings are used in text parsing algorithms to break down larger strings into smaller chunks. For example, a parser might be used to extract individual words from a sentence and store them in a data structure.
    Text Manipulation: Substrings are used in text manipulation applications to find and replace certain words or phrases in larger bodies of text. This can be used to perform search and replace tasks, or to update information in a document.
    Natural Language Processing: Substrings are used in natural language processing algorithms to identify words and phrases. This is used in applications such as speech recognition, where the algorithm must identify words spoken by a user.
    Pattern Recognition: Substrings are used in pattern recognition algorithms to identify patterns in data. This can be used to identify trends in financial data, or to detect anomalies in images.
    Password Security: Substrings are used to verify passwords. This is done by comparing the entered password against a stored substring of the original password. If the two match, then the password is verified. This technique is used in many applications to increase security
    
    Functions in C++
    
    A function is a set of statements that takes input, does some specific computation, and produces output. The idea is to put some commonly or repeatedly done tasks together to make a function so that instead of writing the same code again and again for different inputs, we can call this function.
In simple terms, a function is a block of code that runs only when it is called.

// C++ Program to demonstrate working of a function
#include <iostream>
using namespace std;

// Following function that takes two parameters 'x' and 'y'
// as input and returns max of two input numbers
int max(int x, int y)
{
    if (x > y)
        return x;
    else
        return y;
}

// main function that doesn't receive any parameter and
// returns integer
int main()
{
    int a = 10, b = 20;

    // Calling above function to find max of 'a' and 'b'
    int m = max(a, b);

    cout << "m is " << m;
    return 0;
}

m is 20
Time complexity: O(1)

Space complexity: O(1)
Why Do We Need Functions?

    Functions help us in reducing code redundancy. If functionality is performed at multiple places in software, then rather than writing the same code, again and again, we create a function and call it everywhere. This also helps in maintenance as we have to make changes in only one place if we make changes to the functionality in future.
    Functions make code modular. Consider a big file having many lines of code. It becomes really simple to read and use the code,  if the code is divided into functions.
    Functions provide abstraction. For example, we can use library functions without worrying about their internal work
    Function Declaration

A function declaration tells the compiler about the number of parameters, data types of parameters, and returns type of function. Writing parameter names in the function declaration is optional but it is necessary to put them in the definition. Below is an example of function declarations. (parameter names are not present in the below declarations) 

// C++ Program to show function that takes
// two integers as parameters and returns
// an integer
int max(int, int);

// A function that takes an int
// pointer and an int variable
// as parameters and returns
// a pointer of type int
int* swap(int*, int);

// A function that takes
// a char as parameter and
// returns a reference variable
char* call(char b);

// A function that takes a
// char and an int as parameters
// and returns an integer
int fun(char, int);

User-defined functions are user/customer-defined blocks of code specially customized to reduce the complexity of big programs. They are also commonly known as “tailor-made functions” which are built only to satisfy the condition in which the user is facing issues meanwhile reducing the complexity of the whole program
Library Function 

Library functions are also called “built-in Functions“. These functions are part of a compiler package that is already defined and consists of a special function with special and different meanings. Built-in Function gives us an edge as we can directly use them without defining them whereas in the user-defined function we have to declare and define a function before using them. 
For Example: sqrt(), setw(), strcat(), etc.
Parameter Passing to Functions

The parameters passed to the function are called actual parameters. For example, in the program below, 5 and 10 are actual parameters. 
The parameters received by the function are called formal parameters. For example, in the above program x and y are formal parameters.
There are two most popular ways to pass parameters:

    Pass by Value: In this parameter passing method, values of actual parameters are copied to the function’s formal parameters. The actual and formal parameters are stored in different memory locations so any changes made in the functions are not reflected in the actual parameters of the caller. 
     
    Pass by Reference: Both actual and formal parameters refer to the same locations, so any changes made inside the function are reflected in the actual parameters of the caller.
    
    Function Definition

Pass by value is used where the value of x is not modified using the function fun()

// C++ Program to demonstrate function definition
#include <iostream>
using namespace std;

void fun(int x)
{
    // definition of
    // function
    x = 30;
}

int main()
{
    int x = 20;
    fun(x);
    cout << "x = " << x;
    return 0;
}

x = 20

Time complexity: O(1)

Space complexity: O(1)

Functions Using Pointers

The function fun() expects a pointer ptr to an integer (or an address of an integer). It modifies the value at the address ptr. The dereference operator * is used to access the value at an address. In the statement ‘*ptr = 30’, the value at address ptr is changed to 30. The address operator & is used to get the address of a variable of any data type. In the function call statement ‘fun(&x)’, the address of x is passed so that x can be modified using its address.
	 
	 // C++ Program to demonstrate working of
// function using pointers
#include <iostream>
using namespace std;

void fun(int* ptr) { *ptr = 30; }

int main()
{
    int x = 20;
    fun(&x);
    cout << "x = " << x;

    return 0;
}

x = 30

Time complexity: O(1)

Space complexity: O(1)
passing string as an argument:

In c++ we can pass string as as argument in various way

    Pass by Value
    Pass by Reference
    Pass by Pointer
    1. Pass by Value

In this when you are passing a values as string it will make a copy of a string values.
#include <iostream>
#include <string>

void printString(std::string str) {
    std::cout << str << std::endl;
}

int main() {
    std::string myString = "Hello, GFG!";
    printString(myString);
    return 0;
}

Hello, GFG!

2. Pass by Reference

#include <iostream>
#include <string>

void printString(const std::string& str) { // Note the 'const' to prevent modification
    std::cout << str << std::endl;
}

int main() {
    std::string myString = "welcome to gfg";
    printString(myString);
    return 0;
}

welcome to gfg
#include <iostream>
#include <string>

void printString(const std::string* str) { // Note the 'const' to prevent modification
    std::cout << *str << std::endl;
}

int main() {
    std::string myString = "This is Pss by pointer";
    printString(&myString);
    return 0;
}

#include <iostream>
#include <string>

void printString(const std::string* str) { // Note the 'const' to prevent modification
    std::cout << *str << std::endl;
}
2. Pass by Reference

This can be done by using ‘&’ operator
int main() {
    std::string myString = "This is Pss by pointer";
    printString(&myString);
    return 0;
}
3. Pass by Pointer

This can be done by using * operator
Returning string from a function:

This can be done by using the function “std::string”

#include <iostream>
#include <string>

std::string getGreeting() {
    return "This is  C++";
}

int main() {
    std::string greeting = getGreeting();
    std::cout << greeting << std::endl;
    return 0;
}

#include <iostream>
#include <string>

std::string getGreeting() {
    return "This is  C++";
}

int main() {
    std::string greeting = getGreeting();
    std::cout << greeting << std::endl;
    return 0;
}

Callback function (function passed as an argument in other function)

A callback function is a function that is passed as an argument to another function 

#include <iostream>

// Define a callback function type
typedef void (*CallbackFunction)();

// Function that takes a callback function as an argument
void performAction(CallbackFunction callback) {
    std::cout << "Performing some action...\n";
    // Call the callback function
    callback();
}

// Example callback function
void myCallback() {
    std::cout << "Callback function \n";
}

int main() {
    // Pass the callback function to performAction
    performAction(myCallback);
    return 0;
}

Performing some action...
Callback function 

An array of function pointer and how the elements are accessed

Here, we have c++ example, for accessing elements from array

#include <iostream>

// Function declarations
int add(int a, int b) {
    return a + b;
}

int subtract(int a, int b) {
    return a - b;
}

int multiply(int a, int b) {
    return a * b;
}

int main() {
    // Declare and initialize an array of function pointers
    int (*funcArray[3])(int, int) = { add, subtract, multiply };

    // Variables to use as function parameters
    int x = 2, y = 3;

    // Access and call the functions using the array of function pointers
    std::cout << "Add: " << funcArray[0](x, y) << std::endl;       // Calls add(10, 5)
    std::cout << "Subtract: " << funcArray[1](x, y) << std::endl;  // Calls subtract(10, 5)
    std::cout << "Multiply: " << funcArray[2](x, y) << std::endl;  // Calls multiply(10, 5)

    return 0;
}

Add: 5
Subtract: -1
Multiply: 6

Difference between call by value and call by reference in C++ 
Call by value	Call by reference
A copy of the value is passed to the function	An address of value is passed to the function
Changes made inside the function are not 
reflected on other functions	Changes made inside the function are reflected 
outside the function as well
Actual and formal arguments will be created at 
different memory location	Actual and formal arguments will be created at 
same memory location.
Points to Remember About Functions in C++

1. Most C++ program has a function called main() that is called by the operating system when a user runs the program. 

2. Every function has a return type. If a function doesn’t return any value, then void is used as a return type. Moreover, if the return type of the function is void, we still can use the return statement in the body of the function definition by not specifying any constant, variable, etc. with it, by only mentioning the ‘return;’ statement which would symbolize the termination of the function as shown below: 

void function name(int a)
{
    ....... // Function Body
        return; // Function execution would get terminated
}


3. To declare a function that can only be called without any parameter, we should use “void fun(void)“. As a side note, in C++, an empty list means a function can only be called without any parameter. In C++, both void fun() and void fun(void) are same.

Main Function 

The main function is a special function. Every C++ program must contain a function named main. It serves as the entry point for the program. The computer will start running the code from the beginning of the main function. 
Types of Main Functions
1. Without parameters:

// Without Parameters
int main() { ... return 0; }

2. With parameters:

// With Parameters
int main(int argc, char* const argv[]) { ... return 0; }


The reason for having the parameter option for the main function is to allow input from the command line. When you use the main function with parameters, it saves every group of characters (separated by a space) after the program name as elements in an array named argv. 
Since the main function has the return type of int, the programmer must always have a return statement in the code. The number that is returned is used to inform the calling program what the result of the program’s execution was. Returning 0 signals that there were no problems.

### **🔹 Why is `main()` the Entry Point in C++?**  

Good question! Instead of just running from **line 1**, why does C++ always start execution from `main()`?  

---

### **🔹 Reason 1: Standardization Across Platforms**  
C++ (like C) follows the **ISO C++ standard**, which **defines `main()` as the starting point**.  
🔹 **If there were no `main()`, how would the compiler know where to start?**  

---

### **🔹 Reason 2: Operating System Needs an Entry Point**  
When you **run a C++ program**, the **OS looks for a function named `main()`** to start execution.  
- OS **doesn’t care about line numbers**.  
- Instead, it looks for **a fixed, standard entry point** = `main()`.  

---

### **🔹 Reason 3: Helps in Function Calling & Modularity**  
Imagine writing a **large program** with 1000+ lines. If execution just started at **line 1**, how would you control flow?  

- `main()` acts as a **central hub** where you can **call other functions**.  
- Without `main()`, every program would be a **single long script**—no modularity!  

---

### **🔹 Reason 4: Allows Command-Line Arguments**  
Using `int main(int argc, char* argv[])`, you can take command-line inputs.  
🔹 **If execution started at line 1, how would you pass arguments to the program?**  

---

### **🔹 What Happens If You Don't Write `main()`?**
💥 **Compilation Error!**  
```cpp
#include <iostream>
using namespace std;

void hello() {
    cout << "Hello, World!";
}

// No main() function → ERROR!
```
🔹 **The OS won’t know where to start execution** → Compiler throws an error.  

---

### **🔹 TL;DR: `main()` is the "Home Base" of Your Program**
✔️ **OS looks for `main()` to start execution.**  
✔️ **Standardized across C/C++ for portability.**  
✔️ **Enables modular programming & function calls.**  
✔️ **Allows command-line inputs.**  

💡 **Key Takeaway** → Without `main()`, C++ has no idea where to begin! 🚀

Types of Main Functions
1. Without parameters:

// Without Parameters
int main() { ... return 0; }

2. With parameters:

// With Parameters
int main(int argc, char* const argv[]) { ... return 0; }


The reason for having the parameter option for the main function is to allow input from the command line. When you use the main function with parameters, it saves every group of characters (separated by a space) after the program name as elements in an array named argv. 
Since the main function has the return type of int, the programmer must always have a return statement in the code. The number that is returned is used to inform the calling program what the result of the program’s execution was. Returning 0 signals that there were no problems.

C++ Recursion

When function is called within the same function, it is known as recursion in C++. The function which calls the same function, is known as recursive function.
A function that calls itself, and doesn’t perform any task after function call, is known as tail recursion. In tail recursion, we generally call the same function with return statement.
Syntax:

We have Direct recursion and in direct recursion
1. Direct Recursion:

it can be done when the function calls itself
#include <iostream>
using namespace std;

void directRecursion(int n) {
    if (n > 0) {
        cout << n << " ";
        directRecursion(n - 1); // Function calls itself
    }
}

int main() {
    directRecursion(10);
    return 0;
}

5 4 3 2 1 

2. Indirect Recursion

In this One function calls another function .

#include <iostream>
using namespace std;

void indirectRecursionB(int n); // Forward declaration

void indirectRecursionA(int n) {
    if (n > 0) {
        cout << n << " ";
        indirectRecursionB(n - 1); // Function A calls Function B
    }
}

void indirectRecursionB(int n) {
    if (n > 1) {
        cout << n << " ";
        indirectRecursionA(n / 2); // Function B calls Function A
    }
}

int main() {
    indirectRecursionA(10);
    return 0;
}


Tail Recursion and Non-Tail Recursion:
1. Tail Recursion:

Tail recursion occurs when a function makes a recursive call as its last operation,

#include <iostream>
using namespace std;

void tailRecursion(int n) {
    if (n > 0) {
        cout << n << " ";
        tailRecursion(n - 1); // Recursive call is the last operation
    }
}

int main() {
    tailRecursion(15);
    return 0;
}


15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 

2. Non-Tail Recursion

Non-tail recursion occurs when a function performs some operations after the recursive call.

#include <iostream>
using namespace std;

int nonTailRecursion(int n) {
    if (n > 0) {
        return n + nonTailRecursion(n - 1); // Recursive call is not the last operation
    } else {
        return 0;
    }
}

int main() {
    int result = nonTailRecursion(20);
    cout << "Result: " << result << endl;
    return 0;
}

	Result: 210
	
	C++ Passing Array to Function

In C++, to reuse the array logic, we can create a function. To pass an array to a function in C++,  we need to provide only the array name.


function_name(array_name[]); //passing array to function

Example: Print the minimum number in the given array.
#include <iostream>
using namespace std;
void printMin(int arr[5]);
int main()
{
    int ar[5] = { 30, 10, 20, 40, 50 };
    printMin(ar); // passing array to function
}
void printMin(int arr[5])
{
    int min = arr[0];
    for (int i = 0; i < 5; i++) {
        if (min > arr[i]) {
            min = arr[i];
        }
    }
    cout << "Minimum element is: " << min << "\n";
}

// Code submitted by Susobhan Akhuli

Minimum element is: 10
Time complexity: O(n) where n is the size of the array
Space complexity: O(n) where n is the size of the array.
C++ Overloading (Function)

If we create two or more members having the same name but different in number or type of parameters, it is known as C++ overloading. In C++, we can overload:

    methods,
    constructors and
    indexed properties

Types of overloading in C++ are:

    Function overloading
    Operator overloading

C++ Function Overloading

Function Overloading is defined as the process of having two or more functions with the same name, but different parameters. In function overloading, the function is redefined by using either different types or number of arguments. It is only through these differences a compiler can differentiate between the functions.
The advantage of Function overloading is that it increases the readability of the program because you don’t need to use different names for the same action.
Time complexity: O(n) where n is the size of the array
Space complexity: O(n) where n is the size of the array.
C++ Overloading (Function)

If we create two or more members having the same name but different in number or type of parameters, it is known as C++ overloading. In C++, we can overload:

    methods,
    constructors and
    indexed properties

Types of overloading in C++ are:

    Function overloading
    Operator overloading

C++ Function Overloading

Function Overloading is defined as the process of having two or more functions with the same name, but different parameters. In function overloading, the function is redefined by using either different types or number of arguments. It is only through these differences a compiler can differentiate between the functions.
The advantage of Function overloading is that it increases the readability of the program because you don’t need to use different names for the same action.
30
55

Time complexity: O(1)
Space complexity: O(1)

Example: when the type of the arguments vary
// Program of function overloading with different types of
// arguments.
#include <iostream>
using namespace std;
int mul(int, int);
float mul(float, int);

int mul(int a, int b) { return a * b; }
float mul(double x, int y) { return x * y; }
int main()
{
    int r1 = mul(6, 7);
    float r2 = mul(0.2, 3);
    cout << "r1 is : " << r1 << endl;
    cout << "r2 is : " << r2 << endl;
    return 0;
}

// Code Submitted By Susobhan Akhuli

r1 is : 42
r2 is : 0.6

Time Complexity: O(1)
Space Complexity: O(1
Function Overloading and Ambiguity

When the compiler is unable to decide which function is to be invoked among the overloaded function, this situation is known as function overloading ambiguity.
When the compiler shows the ambiguity error, the compiler does not run the program.

Causes of Ambiguity:

    Type Conversion.
    Function with default arguments.
    Function with pass-by-reference.
    Function Overloading and Ambiguity

When the compiler is unable to decide which function is to be invoked among the overloaded function, this situation is known as function overloading ambiguity.
When the compiler shows the ambiguity error, the compiler does not run the program.

Causes of Ambiguity:

    Type Conversion.
    Function with default arguments.
    Function with pass-by-reference.
    The above example shows an error “call of overloaded ‘fun(double)’ is ambiguous“. The fun(10) will call the first function. The fun(1.2) calls the second function according to our prediction. But, this does not refer to any function as in C++, all the floating point constants are treated as double not as a float. If we replace float to double, the program works. Therefore, this is a type conversion from float to double.

Function with Default Arguments:-

	#include <iostream>
using namespace std;
void fun(int);
void fun(int, int);
void fun(int i) { cout << "Value of i is : " << i << endl; }
void fun(int a, int b = 9)
{
    cout << "Value of a is : " << a << endl;
    cout << "Value of b is : " << b << endl;
}
int main()
{
    fun(12);

    return 0;
}

// Code Submitted By Susobhan Akhuli


The above example shows an error “call of overloaded ‘fun(int)’ is ambiguous“. The fun(int a, int b=9) can be called in two ways: first is by calling the function with one argument, i.e., fun(12) and another way is calling the function with two arguments, i.e., fun(4,5). The fun(int i) function is invoked with one argument. Therefore, the compiler could not be able to select among fun(int i) and fun(int a,int b=9).

Function with Pass By Reference:-

The above example shows an error “call of overloaded ‘fun(int)’ is ambiguous“. The fun(int a, int b=9) can be called in two ways: first is by calling the function with one argument, i.e., fun(12) and another way is calling the function with two arguments, i.e., fun(4,5). The fun(int i) function is invoked with one argument. Therefore, the compiler could not be able to select among fun(int i) and fun(int a,int b=9).

Function with Pass By Reference:-

The above example shows an error “call of overloaded ‘fun(int&)’ is ambiguous“. The first function takes one integer argument and the second function takes a reference parameter as an argument. In this case, the compiler does not know which function is needed by the user as there is no syntactical difference between the fun(int) and fun(int &).
Friend Function

    A friend function is a special function in C++ which in spite of not being a member function of a class has the privilege to access private and protected data of a class.
     A friend function is a non-member function or an ordinary function of a class, which is declared by using the keyword “friend” inside the class. By declaring a function as a friend, all the access permissions are given to the function.
    The keyword “friend” is placed only in the function declaration but not in the function definition.
    When the friend function is called neither the name of the object nor the dot operator is used. However, it may accept the object as an argument whose value it wants to access.
    A friend function can be declared in any section of the class i.e. public, private, or protected.

Declaration of friend function in C++


The above example shows an error “call of overloaded ‘fun(int&)’ is ambiguous“. The first function takes one integer argument and the second function takes a reference parameter as an argument. In this case, the compiler does not know which function is needed by the user as there is no syntactical difference between the fun(int) and fun(int &).
Friend Function

    A friend function is a special function in C++ which in spite of not being a member function of a class has the privilege to access private and protected data of a class.
     A friend function is a non-member function or an ordinary function of a class, which is declared by using the keyword “friend” inside the class. By declaring a function as a friend, all the access permissions are given to the function.
    The keyword “friend” is placed only in the function declaration but not in the function definition.
    When the friend function is called neither the name of the object nor the dot operator is used. However, it may accept the object as an argument whose value it wants to access.
    A friend function can be declared in any section of the class i.e. public, private, or protected.

Declaration of friend function in C++

#include <iostream>
using namespace std;
class Largest {
    int a, b, m;

public:
    void set_data();
    friend void find_max(Largest);
};

void Largest::set_data()
{
    cout << "Enter the first number : ";
    cin >> a;
    cout << "\nEnter the second number : ";
    cin >> b;
}

void find_max(Largest t)
{
    if (t.a > t.b)
        t.m = t.a;
    else
        t.m = t.b;

    cout << "\nLargest number is " << t.m;
}

int main()
{
    Largest l;
    l.set_data();
    find_max(l);
    return 0;
}


return Statement in C++

n C++, the return statement returns the flow of the execution to the function from where it is called. This statement does not mandatorily need any conditional statements. As soon as the statement is executed, the flow of the program stops immediately and returns the control from where it was called. The return statement may or may not return anything for a void function, but for a non-void function, a return value must be returned. 
#include <iostream>
using namespace std;

int add(int a, int b) {
      
      // Return the sum and terminate the function
    return a + b; 
}

int main() {
  
      // Call the function and store the result
    int res = add(5, 7);
    cout << res;
    return 0;
}

12

Explanation: In this example, in add() function, the return a + b returns the sum to the calling function and terminate the execution of the function. In the main function, return 0 indicates that the program executed successfully.

Syntax:

    return expression[];

There are various ways to use return statements. A few are mentioned below:
    return expression[];

There are various ways to use return statements. A few are mentioned below:
1. Methods not returning a value

In C++ one cannot skip the return statement when the methods are of the return type. The return statement can be skipped only for void types.

Not using a return statement in void return type function

When a function does not return anything, the void return type is used. So if there is a void return type in the function definition, then there will be no return statement inside that function (generally).

Example:
    return expression[];

There are various ways to use return statements. A few are mentioned below:
1. Methods not returning a value

In C++ one cannot skip the return statement when the methods are of the return type. The return statement can be skipped only for void types.

Not using a return statement in void return type function

When a function does not return anything, the void return type is used. So if there is a void return type in the function definition, then there will be no return statement inside that function (generally).

Example:
// C++ code to show not using return
// statement in void return type function
#include <iostream>
using namespace std;

// void method
void Print()
{
    cout << "Welcome to GeeksforGeeks";
}

// Driver method
int main()
{

    // Calling print
    Print();

    return 0;
}

Welcome to GeeksforGeeks

Using the return statement in void return type function

Now the question arises, what if there is a return statement inside a void return type function? Since we know that, if there is a void return type in the function definition, then there will be no return statement inside that function. But if there is a return statement inside it, then also there will be no problem if the syntax of it will be: 

This syntax is used in function just as a jump statement in order to break the flow of the function and jump out of it. One can think of it as an alternative to “break statement” to use in functions.

 Example: 
 Welcome to GeeksforGeeks

Using the return statement in void return type function

Now the question arises, what if there is a return statement inside a void return type function? Since we know that, if there is a void return type in the function definition, then there will be no return statement inside that function. But if there is a return statement inside it, then also there will be no problem if the syntax of it will be: 

This syntax is used in function just as a jump statement in order to break the flow of the function and jump out of it. One can think of it as an alternative to “break statement” to use in functions.

 Example: 
 Welcome to GeekforGeeks

But if the return statement tries to return a value in a void return type function, that will lead to errors. 

Incorrect Syntax:

    void func() {
        return value;
    }


// C++ code to show using return statement
// with a value in void return type function
#include <iostream>
using namespace std;

// void method
void Print()
{
    cout << "Welcome to GeeksforGeeks";

    // void method using the return
    // statement to return a value
    return 10;
}

// Driver method
int main()
{

    // Calling print
    Print();

    return 0;
}

warning: 'return' with a value, in function returning void

2. Methods returning a value: 

For methods that define a return type, the return statement must be immediately followed by the return value of that specified return type. 

Syntax:

    return-type func() {
        return value;
    }


// C++ code to illustrate Methods returning
// a value using return statement
#include <iostream>
using namespace std;

// non-void return type
// function to calculate sum
int SUM(int a, int b)
{
    int s1 = a + b;

    // method using the return
    // statement to return a value
    return s1;
}

// Driver method
int main()
{
    int num1 = 10;
    int num2 = 10;
    int sum_of = SUM(num1, num2);
    cout << "The sum is " << sum_of;
    return 0;
}

Default Arguments in C++

#include <iostream>
using namespace std;

// Function with an argument with default value
void f(int a = 10) {
    cout << a << endl;
}

int main() {
      
      // Uses default argument
      f();
  
      // Uses passed value
      f(221);
  
    return 0;
}


10
221

Explanation: In this program, the function f has a default argument a = 10, so when no argument is provided, a defaults to 10, which is printed. When 221 is passed, a becomes 221 which is then printed.

Syntax

A default argument is defined by assigning a value to a function parameter in its declaration.
return_type name (p1= v1, p2= v2, ...);

where v1, v2, … are the default values for the parameters p1, p2, … respectively.
Rules to Follow

There are some important rules and best practices to keep in mind when using default arguments in C++:

1. Default Values Must Be Specified in Function Declarations

The default values for parameters must be specified in the function declaration (or prototype). If a function is declared and defined separately, the default values must be in the declaration, not in definition.
// Declaration with default argument
void func(int x = 10);

// Definition without default argument
void func(int x) {
    cout << "Value: " << x << endl;
}

2. Default Arguments Cannot Be Modified

Once default arguments are defined in the declaration, they cannot be modified in the function definition. If you try to change the default value in the definition, it will result in a compilation error.
// Declaration
void f(int a = 10);

// This definintion will throw and error
void f(int a = 222) {
      // statements
}

3. Default Arguments Must Be Provided from Right to Left

In a function with multiple parameters, default values must be provided from the rightmost parameter to the left. It means that if a parameter has a default argument, all parameters to its right must also have default values.

// Valid
void func(int x, int y = 20);

// Invalid, as `y` does not have a default value
void func(int x = 10, int y);

4. Ambiguity in Function Overloading

If a function containing default arguments is overloaded, then we need to make sure it is not ambiguous to the compiler, otherwise it will throw an error. For example,
// Valid
void f(int a = 10, int b = 20);
  
// Will throw error as the signature is same
void f(int a = 22, int b = 2);

// Will also throw error
void f(int a);

// Will also throw an error
void f(int a, b)

Examples

The following examples demonstrate the use of default arguments in different cases:
Find Area of Rectangle with Optional Length

We want to keep the rectangle height optional in case it is not provided to the area calculator function. One approach could be to create two overloaded functions, one that takes two parameters and one that takes one. However, this can be simplified by using default arguments instead of function overloading by specifying optional values.
Examples

The following examples demonstrate the use of default arguments in different cases:
Find Area of Rectangle with Optional Length

We want to keep the rectangle height optional in case it is not provided to the area calculator function. One approach could be to create two overloaded functions, one that takes two parameters and one that takes one. However, this can be simplified by using default arguments instead of function overloading by specifying optional values.
Area 1:  50
Area 2: 45

Combine Default and Parameterized Constructor

Just like normal functions, we can also define default values for the arguments of parameterized constructors. All the rules of the default arguments will be applied to these parameters.
Area 1:  50
Area 2: 45

Combine Default and Parameterized Constructor

Just like normal functions, we can also define default values for the arguments of parameterized constructors. All the rules of the default arguments will be applied to these parameters.
5
25

Explanation: In the above program, we create a class with a parameterized constructor that has a default argument. When we create an object without passing any argument, the constructor uses its default value of x = 5. However, when we pass an argument, the constructor uses the passed value of x = 25.
Advantages

    Default arguments are useful when we want to increase the capabilities of an existing function.
    It helps in reducing the size of a program.
    It provides a simple and effective programming approach.
    Default arguments improve the consistency of a program.

Disadvantages

    If the default values are not well-documented or understood, it can lead to confusion about what arguments are being used.
    Overloading functions with default arguments can sometimes lead to ambiguities.
    It increases the execution time as the compiler needs to replace the omitted arguments by their default values in the function call.
    
    
Inline Functions in C++


In C++, a function can be specified as inline to reduce the function call overhead. The whole code of the inline function is inserted or substituted at the point of its call during the compilation instead of using normal function call mechanism.
### **🔹 What is Function Overhead in C++? (Easy Terms)**  

**Overhead** means **extra cost** in terms of **time and memory** when executing a function. Every time you **call** a function, the CPU does extra work instead of just executing the code directly.  

---

### **🔹 What Happens When You Call a Function?**
When you call a function in C++, the system needs to:  

1️⃣ **Save the current execution state** (store register values).  
2️⃣ **Jump to the function’s location in memory**.  
3️⃣ **Pass function arguments** (copy values to stack or registers).  
4️⃣ **Execute function code**.  
5️⃣ **Return back to the caller function**.  
6️⃣ **Restore previous execution state**.  

Each step **takes extra CPU cycles** → This is **function call overhead**.  

---

### **🔹 Example of Function Overhead**
```cpp
#include <iostream>
using namespace std;

void add(int a, int b) {  // Function call → Adds overhead
    cout << "Sum: " << a + b << endl;
}

int main() {
    add(5, 10);  // Function call (has overhead)
    return 0;
}
```
👉 Even though `add()` just prints the sum, calling it still has **overhead** due to function jumps and stack operations.  

---

### **🔹 How Much Overhead?**
✅ **A function call takes ~5-20 CPU cycles extra.**  
✅ **A direct operation (without a function) takes 0 extra cycles.**  

---

### **🔹 Reducing Overhead Using Inline Functions**
```cpp
#include <iostream>
using namespace std;

inline void add(int a, int b) {  // 👈 No function call, directly replaced
    cout << "Sum: " << a + b << endl;
}

int main() {
    add(5, 10);  // No overhead (code is replaced)
    return 0;
}
```
✔️ **No jump, no extra stack usage** → **Faster execution**.  

---

### **🔹 When Does Overhead Matter?**
🚀 In **Competitive Programming (CP)** or **Performance-Critical Code**, calling small functions **millions of times** inside a loop can slow things down.  
📌 Function call overhead can cause a **5-10% performance loss** in extreme cases.  

---

### **🔹 TL;DR**
✔️ **Function overhead** = Extra CPU work for calling a function.  
✔️ **Takes extra CPU cycles (~5-20 cycles per call)**.  
✔️ **Inline functions** reduce overhead by replacing calls with actual code. 🚀
### **🔹 What is Function Overhead in C++? (Easy Terms)**  

**Overhead** means **extra cost** in terms of **time and memory** when executing a function. Every time you **call** a function, the CPU does extra work instead of just executing the code directly.  

---

### **🔹 What Happens When You Call a Function?**
When you call a function in C++, the system needs to:  

1️⃣ **Save the current execution state** (store register values).  
2️⃣ **Jump to the function’s location in memory**.  
3️⃣ **Pass function arguments** (copy values to stack or registers).  
4️⃣ **Execute function code**.  
5️⃣ **Return back to the caller function**.  
6️⃣ **Restore previous execution state**.  

Each step **takes extra CPU cycles** → This is **function call overhead**.  

---

### **🔹 Example of Function Overhead**
```cpp
#include <iostream>
using namespace std;

void add(int a, int b) {  // Function call → Adds overhead
    cout << "Sum: " << a + b << endl;
}

int main() {
    add(5, 10);  // Function call (has overhead)
    return 0;
}
```
👉 Even though `add()` just prints the sum, calling it still has **overhead** due to function jumps and stack operations.  

---

### **🔹 How Much Overhead?**
✅ **A function call takes ~5-20 CPU cycles extra.**  
✅ **A direct operation (without a function) takes 0 extra cycles.**  

---

### **🔹 Reducing Overhead Using Inline Functions**
```cpp
#include <iostream>
using namespace std;

inline void add(int a, int b) {  // 👈 No function call, directly replaced
    cout << "Sum: " << a + b << endl;
}

int main() {
    add(5, 10);  // No overhead (code is replaced)
    return 0;
}
```
✔️ **No jump, no extra stack usage** → **Faster execution**.  

---

### **🔹 When Does Overhead Matter?**
🚀 In **Competitive Programming (CP)** or **Performance-Critical Code**, calling small functions **millions of times** inside a loop can slow things down.  
📌 Function call overhead can cause a **5-10% performance loss** in extreme cases.  

---

### **🔹 TL;DR**
✔️ **Function overhead** = Extra CPU work for calling a function.  
✔️ **Takes extra CPU cycles (~5-20 cycles per call)**.  
✔️ **Inline functions** reduce overhead by replacing calls with actual code. 🚀


#include <iostream>
using namespace std;

// Inline function
inline int square(int x) {
    return x * x;
}

int main() {
    int num = 5;
    
    // Calling inline function
    int res = square(num);
    cout << res;
    return 0;
}

 	25
 	
 	Syntax

We just need to add the “inline” keyword before the function prototype:

inline return_type function_name(params)...

Inlining is only a request to the compiler, not a command. The compiler may not perform inlining in such circumstances as: 

    If a function contains a loop.
    If a function contains static variables. 
    If a function is recursive. 
    If a function return type is other than void, and the return statement doesn’t exist in a function body. 
    If a function contains a switch or goto statement. 

To learn more about performance optimization and inline functions, check out our Complete C++ Course, which covers inline functions, optimization strategies, and high-performance programming techniques.
Need of Inline Functions

When a function is called, the CPU stores the return address, copies arguments to the stack, and transfers control to the function. After execution, the return value is stored, and control is returned to the caller. This overhead can be significant for small, frequently used functions, as their execution time is less than the time spent on the call and return process.

This is where the inline functions shine. They remove this overhead by substituting the code of the function in place of function call.
One other thing to remember is that it is only useful to make the function inline if the time spent during a function call is more compared to the function body execution time.

An example where the inline function has no effect at all: 

    inline void show() 
    { 
        cout << “value of S = ” << S << endl; 
    }

The above function relatively takes a long time to execute. In general, a function that performs an input-output (I/O) operation shouldn’t be defined as inline because it spends a considerable amount of time.

Appropriate use of inline functions can provide performance enhancement but if inline functions are used arbitrarily then they can’t provide better results. In other words, don’t make every function inline. It is better to keep inline functions as small as possible.
Inline Functions in Class

All the functions defined inside the class are implicitly inline. Thus, all the restrictions of inline functions are also applied here. If you need to explicitly declare an inline function in the class, then just declare the function inside the class and define it outside the class using the inline keyword.

One other thing to remember is that it is only useful to make the function inline if the time spent during a function call is more compared to the function body execution time.

An example where the inline function has no effect at all: 

    inline void show() 
    { 
        cout << “value of S = ” << S << endl; 
    }

The above function relatively takes a long time to execute. In general, a function that performs an input-output (I/O) operation shouldn’t be defined as inline because it spends a considerable amount of time.

Appropriate use of inline functions can provide performance enhancement but if inline functions are used arbitrarily then they can’t provide better results. In other words, don’t make every function inline. It is better to keep inline functions as small as possible.
Inline Functions in Class

All the functions defined inside the class are implicitly inline. Thus, all the restrictions of inline functions are also applied here. If you need to explicitly declare an inline function in the class, then just declare the function inside the class and define it outside the class using the inline keyword.


#include <iostream>
using namespace std;

class A {
public:

    // declare inline
    inline int square(int x);
};

// Define the function
inline int A::square(int x) {
    return x*x;
}

int main() {
    A obj;
    cout << obj.square(3);
    return 0;
}

Virtual Functions Inlining

C++ compiler cannot inline the virtual function. The reason is that the calls to a virtual function is resolved at runtime instead of compile-time. Virtual means waiting until runtime and inline means during compilation, if the compiler doesn’t know which function will be called, how it can perform inlining?
Inline vs Macros

Readers familiar with the C language know that the C language uses macro. The preprocessor replaces all macro calls directly within the macro code. However, it is recommended to always use the inline function instead of the macro. According to Dr. Bjarne Stroustrup, the creator of C++ macros are almost never necessary in C++ and they are error prone.

The below table lists the primary differences between inline functions and macros:
Aspect	Inline Functions	Macros
Definition	Inline functions are functions defined with the inline keyword.	Macros are preprocessor directives defined using #define.
Scope	Inline functions have scope and type checking, like regular functions.	Macros have no scope or type checking. They are replaced by the preprocessor.
Evaluation of Arguments	Arguments are evaluated once.	Arguments may be evaluated multiple times (e.g., in expressions).
Handling	Inline functions are handled by compiler.	Macros are handled by preprocessor.

Private Members
	

Can access private members of a class.
	

Cannot access private members of a class.
Execution Overhead	Compiler may ignore the inline request if the function is too large.	Macros are always substituted into code.
Recursion	Inline functions can call themselves recursively.	Macros cannot be recursive.

Advantages

    Function call overhead doesn’t occur.
    When you inline a function, you may enable the compiler to perform context-specific optimization on the body of the function. Such optimizations are not possible for normal function calls. Other optimizations can be obtained by considering the flows of the calling context and the called context.
    An inline function may be useful (if it is small) for embedded systems because inline can yield less code than the function called preamble and return.

Disadvantages

    When inline function body is substituted at the point of the function call, the total number of variables used by the function also gets inserted. So, the number of registers going to be used for the variables will also get increased.
    Inline functions might cause thrashing because inlining might increase the size of the binary executable file.
    Too much inlining can reduce your instruction cache hit rate, thus reducing the speed of instruction fetch from that of cache memory to that of primary memory. 
    If someone changes the code inside the inline function, then all the calling location has to be recompiled because the compiler would be required to replace all the code once again to reflect the changes.
    Inline functions may not be useful for many embedded systems. Because in embedded systems code size is more important than speed.
    	
Lambda Expression in C++
C++ 11 introduced lambda expressions to allow inline functions which can be used for short snippets of code that are not going to be reused. Therefore, they do not require a name. They are mostly used in STL algorithms as callback functions.
#include <bits/stdc++.h>
using namespace std;

int main() {
    
    // Defining a lambda
    auto res = [](int x) {
        return x + x;
    };
    cout << res(5);
    
    return 0;
}

10

The lambda expression in the above program takes an integer x as input and returns the sum of x with itself. The result of res(5) prints 10, as the lambda doubles the value of 5.
Syntax
[capture-clause] (parameters) -> return-type { 
    // definition
}

To learn how to use lambda expressions effectively in your C++ programs, the C++ Course provides detailed explanations and examples.

Return Type

Generally, the return-type in lambda expressions is evaluated by the compiler itself and we don’t need to specify it explicitly. However, in some complex cases e.g. conditional statements, the compiler can’t determine the return type and explicit specification is require
d.

Parameters

These parameters are similar to the function parameters in every way.

Capture Clause

A lambda expression can have more power than an ordinary function by having access to variables from the enclosing scope. We can capture external variables from the enclosing scope in three ways using capture clause:

    [&]: capture all external variables by reference.
    [=]: capture all external variables by value.
    [a, &b]: capture ‘a’ by value and ‘b’ by reference.

A lambda with an empty capture clause [] can only access variables which are local to it
d.

Parameters

These parameters are similar to the function parameters in every way.

Capture Clause

A lambda expression can have more power than an ordinary function by having access to variables from the enclosing scope. We can capture external variables from the enclosing scope in three ways using capture clause:

    [&]: capture all external variables by reference.
    [=]: capture all external variables by value.
    [a, &b]: capture ‘a’ by value and ‘b’ by reference.

A lambda with an empty capture clause [] can only access variables which are local to it
#include <bits/stdc++.h>
using namespace std;

void print(vector<int> v) {
    for (auto x : v) cout << x << " ";
    cout << endl;
}

int main() {
    vector<int> v1, v2;

    // Capture v1 and v2 by reference
    auto byRef = [&] (int m) {
        v1.push_back(m);
        v2.push_back(m);
    };
    
    // Capture v1 and v2 by value
    auto byVal = [=] (int m) mutable {
        v1.push_back(m);
        v2.push_back(m);
    };
    
    // Capture v1 by reference and v2 by value
    auto mixed = [=, &v1] (int m) mutable {
        v1.push_back(m);
        v2.push_back(m);
    };

    // Push 20 in both v1 and v2
    byRef(20);
    
    // Push 234 in both v1 and v2
    byVal(234);
    
    // Push 10 in both v1 and v2
    mixed(10);
    
    print(v1);
    print(v2);
    
    return 0;
}


20 10 
20 

Let’s understand what happened in this program:

    byRef captures all by reference. So pushing 20 will push it into original v1 and v2.
    byVal captures all by value. So pushing 234 will not do anything to original vectors.
    mixed captures v1 by reference and v2 by value. So pushing 10 will only push it into v1.

The mutable keyword here is used in capture by value lambdas only because, by default, value captured objects are const.
Examples

Lamda expressions are extensively used in STL in place of callback i.e. functions passed as arguments. The below examples demonstrate that:
Sort Vector in Descending Order

#include <bits/stdc++.h>
using namespace std;

int main() {
    vector<int> v = {5, 1, 8, 3, 9, 2};

    // Sort in descending order
    sort(v.begin(), v.end(), [] (const int& a, const int&b) {
        return a > b;
    });

    for (int x : v)
        cout << x << " ";
    return 0;
}

	9 8 5 3 2 1 

Find First Number Divisible by 3

#include <bits/stdc++.h>
using namespace std;

int main() {
    vector<int> v = {5, 1, 8, 3, 9, 2};

    // Sort in descending order
    auto it = find_if(v.begin(), v.end(), [] (const int& a) {
        return a % 3 == 0;
    });

    if (it != v.end()) cout << *it;
    else cout << "No such element";
    return 0;
}


3

Applications

Lambda expressions’ main purpose was to replace the functions in callbacks by providing inline definitions. Following are the common applications of lambda expressions in C++

    Inline, Anonymous Functions: Write small functions directly where needed without naming them.
    STL Algorithms: Pass custom comparison or transformation logic to algorithms like sort, for_each, etc.
    Callbacks and Event Handling: Use lambdas as callbacks for asynchronous operations or event handlers.
    Threading and Concurrency: Pass lambdas to threads for quick, inline tasks without defining separate functions.
    Custom Comparators in Containers: Use lambdas as comparators for containers like priority_queue, set, etc.


Pointers and References in C++

In C++ pointers and references both are mechanisms used to deal with memory, memory address, and data in a program. Pointers are used to store the memory address of another variable whereas references are used to create an alias for an already existing variable.
Pointers in C++

Pointers in C++ are a symbolic representation of addresses. They enable programs to simulate call-by-reference and create and manipulate dynamic data structures. Pointers store the address of variables or a memory location. 

// C++ program to demonstrate use of pointers in C++;

#include <iostream>
using namespace std;

int main()
{
	int x = 10; // variable declared
	int* myptr; // pointer variable

	// storing address of x in pointer myptr
	myptr = &x;

	cout << "Value of x is: ";
	cout << x << endl;

	// print the address stored in myptr pointer variable
	cout << "Address stored in myptr is: ";
	cout << myptr << endl;

	// printing value of x using pointer myptr
	cout << "Value of x using *myptr is: ";
	cout << *myptr << endl;

	return 0;
}

Value of x is: 10
Address stored in myptr is: 0x7ffd2b32c7f4
Value of x using *myptr is: 10

Explanation: The above program declares an integer variable ‘x’ initialized with value 10 and a pointer variable named ‘myptr’. The memory address of x is assigned to myptr. Then it prints the value of x, the address stored in myptr, and the value of x obtained by dereferencing the pointer myptr.

In C++ pointers and references both are mechanisms used to deal with memory, memory address, and data in a program. Pointers are used to store the memory address of another variable whereas references are used to create an alias for an already existing variable.
Pointers in C++

Pointers in C++ are a symbolic representation of addresses. They enable programs to simulate call-by-reference and create and manipulate dynamic data structures. Pointers store the address of variables or a memory location. 

Application of Pointers in C++

Following are the Applications of Pointers in C++:

    To pass arguments by reference: Passing by reference serves two purposes
    For accessing array elements: The Compiler internally uses pointers to access array elements.
    To return multiple values: For example in returning square and the square root of numbers.
    Dynamic memory allocation: We can use pointers to dynamically allocate memory. The advantage of dynamically allocated memory is, that it is not deleted until we explicitly delete it.
    To implement data structures.
    To do system-level programming where memory addresses are useful.

Features and Use of Pointers in C++

The Pointers have a few important features and uses like it saves memory space, they are used to allocate memory dynamically, it is used for file handling, etc. Pointers store the address of variables or a memory location. 
Example: pointer “ptr” holds the address of an integer variable or holds the address of memory whose value(s) can be accessed as integer values through “ptr”.

‘this’ Pointer in C++

The ‘this’ pointer is passed as a hidden argument to all nonstatic member function calls and is available as a local variable within the body of all nonstatic functions. ‘this’ pointer is not available in static member functions as static member functions can be called without any object (with class name). Even if only one member of each function exists which is used by multiple objects, the compiler supplies an implicit pointer along with the names of the functions as ‘this’. 
Declaration: 

this->x = x; 

References in C++

When a variable is declared as a reference, it becomes an alternative name for an existing variable. A variable can be declared as a reference by putting ‘&’ in the declaration. There are 3 ways to pass C++ arguments to a function: 

    call-by-value
    call-by-reference with a pointer argument
    call-by-reference with a reference argument

Example of References in C++

The below program demonstrates the use of references in C++.


Pointers are symbolic representations of addresses. They enable programs to simulate call-by-reference as well as to create and manipulate dynamic data structures. Iterating over elements in arrays or other data structures is one of the main use of pointers. 

The address of the variable you’re working with is assigned to the pointer variable that points to the same data type (such as an int or string)'
How to use a pointer?

    Define a pointer variable
    Assigning the address of a variable to a pointer using the unary operator (&) which returns the address of that variable.
    Accessing the value stored in the address using unary operator (*) which returns the value of the variable located at the address specified by its operand.
    	
    	The reason we associate data type with a pointer is that it knows how many bytes the data is stored in. When we increment a pointer, we increase the pointer by the size of the data type to which it points. To master the use of pointers and their applications, explore the C++ Course for comprehensive lessons and hands-on examples.
    	
    	// C++ program to illustrate Pointers

#include <bits/stdc++.h>
using namespace std;
void geeks()
{
    int var = 20;

    // declare pointer variable
    int* ptr;

    // note that data type of ptr and var must be same
    ptr = &var;

    // assign the address of a variable to a pointer
    cout << "Value at ptr = " << ptr << "\n";
    cout << "Value at var = " << var << "\n";
    cout << "Value at *ptr = " << *ptr << "\n";
}
// Driver program
int main() 
{ 
  geeks(); 
  return 0;
}

Value at ptr = 0x7ffe454c08cc
Value at var = 20
Value at *ptr = 20

References and Pointers

There are 3 ways to pass C++ arguments to a function:

    Call-By-Value
    Call-By-Reference with a Pointer Argument
    Call-By-Reference with a Reference Argument
    
    References and Pointers

There are 3 ways to pass C++ arguments to a function:

    Call-By-Value
    Call-By-Reference with a Pointer Argument
    Call-By-Reference with a Reference Argument
    
    
    // C++ program to illustrate call-by-methods

#include <bits/stdc++.h>
using namespace std;

// Pass-by-Value
int square1(int n)
{
    // Address of n in square1() is not the same as n1 in
    // main()
    cout << "address of n1 in square1(): " << &n << "\n";

    // clone modified inside the function
    n *= n;
    return n;
}
// Pass-by-Reference with Pointer Arguments
void square2(int* n)
{
    // Address of n in square2() is the same as n2 in main()
    cout << "address of n2 in square2(): " << n << "\n";

    // Explicit de-referencing to get the value pointed-to
    *n *= *n;
}
// Pass-by-Reference with Reference Arguments
void square3(int& n)
{
    // Address of n in square3() is the same as n3 in main()
    cout << "address of n3 in square3(): " << &n << "\n";

    // Implicit de-referencing (without '*')
    n *= n;
}
void geeks()
{
    // Call-by-Value
    int n1 = 8;
    cout << "address of n1 in main(): " << &n1 << "\n";
    cout << "Square of n1: " << square1(n1) << "\n";
    cout << "No change in n1: " << n1 << "\n";

    // Call-by-Reference with Pointer Arguments
    int n2 = 8;
    cout << "address of n2 in main(): " << &n2 << "\n";
    square2(&n2);
    cout << "Square of n2: " << n2 << "\n";
    cout << "Change reflected in n2: " << n2 << "\n";

    // Call-by-Reference with Reference Arguments
    int n3 = 8;
    cout << "address of n3 in main(): " << &n3 << "\n";
    square3(n3);
    cout << "Square of n3: " << n3 << "\n";
    cout << "Change reflected in n3: " << n3 << "\n";
}
// Driver program
int main() { geeks(); }


In C++, by default arguments are passed by value and the changes made in the called function will not reflect in the passed variable. The changes are made into a clone made by the called function. If wish to modify the original copy directly (especially in passing huge object or array) and/or avoid the overhead of cloning, we use pass-by-reference. Pass-by-Reference with Reference Arguments does not require any clumsy syntax for referencing and dereferencing.

Array Name as Pointers

An array name contains the address of the first element of the array which acts like a constant pointer. It means, the address stored in the array name can’t be changed. For example, if we have an array named val then val and &val[0] can be used interchangeably.

Pointer Expressions and Pointer Arithmetic

A limited set of arithmetic operations can be performed on pointers which are:

    incremented ( ++ )
    decremented ( — )
    an integer may be added to a pointer ( + or += )
    an integer may be subtracted from a pointer ( – or -= )
    difference between two pointers (p1-p2)

(Note: Pointer arithmetic is meaningless unless performed on an array.) 
// C++ program to illustrate Pointer Arithmetic
#include <bits/stdc++.h>
using namespace std;
void geeks()
{
    // Declare an array
    int v[3] = { 10, 100, 200 };

    // declare pointer variable
    int* ptr;

    // Assign the address of v[0] to ptr
    ptr = v;

    for (int i = 0; i < 3; i++) {
        cout << "Value at ptr = " << ptr << "\n";
        cout << "Value at *ptr = " << *ptr << "\n";

        // Increment pointer ptr by 1
        ptr++;
    }
}

// Driver program
int main() { geeks(); }

Value at ptr = 0x7ffe5a2d8060
Value at *ptr = 10
Value at ptr = 0x7ffe5a2d8064
Value at *ptr = 100
Value at ptr = 0x7ffe5a2d8068
Value at *ptr = 200

Advanced Pointer Notation
Consider pointer notation for the two-dimensional numeric arrays. consider the following declaration

int nums[2][3]  =  { { 16, 18, 20 }, { 25, 26, 27 } };
Pointers and String literals

String literals are arrays containing null-terminated character sequences. String literals are arrays of type character plus terminating null-character, with each of the elements being of type const char (as characters of string can’t be modified).


 This declares an array with the literal representation for “geek”, and then a pointer to its first element is assigned to ptr. If we imagine that “geek” is stored at the memory locations that start at address 1800, we can represent the previous declaration as: 
 
 As pointers and arrays behave in the same way in expressions, ptr can be used to access the characters of a string literal. For example:

char ptr = 0;
char x = *(ptr+3);
char y = ptr[3];

Here, both x and y contain k stored at 1803 (1800+3).
Pointers to pointers

In C++, we can create a pointer to a pointer that in turn may point to data or another pointer. The syntax simply requires the unary operator (*) for each level of indirection while declaring the pointer.

char a;
char *b;
char ** c;
a = ’g’;
b = &a;
c = &b;

Here b points to a char that stores ‘g’ and c points to the pointer b.
Void Pointers

This is a special type of pointer available in C++ which represents the absence of type. Void pointers are pointers that point to a value that has no type (and thus also an undetermined length and undetermined dereferencing properties). This means that void pointers have great flexibility as they can point to any data type. There is a payoff for this flexibility. These pointers cannot be directly dereferenced. They have to be first transformed into some other pointer type that points to a concrete data type before being dereferenced

// C++ program to illustrate Void Pointer
#include <bits/stdc++.h>
using namespace std;
void increase(void* data, int ptrsize)
{
    if (ptrsize == sizeof(char)) {
        char* ptrchar;

        // Typecast data to a char pointer
        ptrchar = (char*)data;

        // Increase the char stored at *ptrchar by 1
        (*ptrchar)++;
        cout << "*data points to a char"
             << "\n";
    }
    else if (ptrsize == sizeof(int)) {
        int* ptrint;

        // Typecast data to a int pointer
        ptrint = (int*)data;

        // Increase the int stored at *ptrchar by 1
        (*ptrint)++;
        cout << "*data points to an int"
             << "\n";
    }
}
void geek()
{
    // Declare a character
    char c = 'x';

    // Declare an integer
    int i = 10;

    // Call increase function using a char and int address
    // respectively
    increase(&c, sizeof(c));
    cout << "The new value of c is: " << c << "\n";
    increase(&i, sizeof(i));
    cout << "The new value of i is: " << i << "\n";
}
// Driver program
int main() { geek(); }

data points to a char
The new value of c is: y
*data points to an int
The new value of i is: 11

Invalid pointers

A pointer should point to a valid address but not necessarily to valid elements (like for arrays). These are called invalid pointers. Uninitialized pointers are also invalid pointers.

int *ptr1;
int arr[10];
int *ptr2 = arr+20;

Here, ptr1 is uninitialized so it becomes an invalid pointer and ptr2 is out of bounds of arr so it also becomes an invalid pointer. (Note: invalid pointers do not necessarily raise compile errors)
NULL Pointers

A null pointer is a pointer that point nowhere and not just an invalid address. Following are 2 methods to assign a pointer as NULL;

int *ptr1 = 0;
int *ptr2 = NULL;

Advantages of Pointers

    Pointers reduce the code and improve performance. They are used to retrieve strings, trees, arrays, structures, and functions.
    Pointers allow us to return multiple values from functions.
    In addition to this, pointers allow us to access a memory location in the computer’s memory.
    
    
    
Understanding nullptr in C++

// C++ program to demonstrate problem with NULL
#include <bits/stdc++.h>
using namespace std;

// function with integer argument
void fun(int N)   { cout << "fun(int)"; return;}

// Overloaded function with char pointer argument
void fun(char* s)  { cout << "fun(char *)"; return;}

int main() 
{
    // Ideally, it should have called fun(char *),
    // but it causes compiler error.
    fun(NULL);  
}

16:13: error: call of overloaded 'fun(NULL)' is ambiguous
     fun(NULL);


 
What is the problem with above program? 
NULL is typically defined as (void *)0 and conversion of NULL to integral types is allowed. So the function call fun(NULL) becomes ambiguous. 
 
 What is the problem with above program? 
NULL is typically defined as (void *)0 and conversion of NULL to integral types is allowed. So the function call fun(NULL) becomes ambiguous. 

// This program compiles (may produce warning)
#include<stdio.h>
int main() 
{
   int x = NULL;
}

// This program compiles (may produce warning)
#include<stdio.h>
int main() 
{
   int x = NULL;
}

How does nullptr solve the problem? 
In the above program, if we replace NULL with nullptr, we get the output as “fun(char *)”.
nullptr is a keyword that can be used at all places where NULL is expected. Like NULL, nullptr is implicitly convertible and comparable to any pointer type. Unlike NULL, it is not implicitly convertible or comparable to integral types.
// This program does NOT compile
#include<stdio.h>
int main() 
{
   int x = nullptr;
}

Compiler Error


As a side note, nullptr is convertible to bool. 
 

// This program compiles
#include<iostream>
using namespace std;

int main() 
{
   int *ptr = nullptr;

   // Below line compiles
   if (ptr) { cout << "true"; }    
   else { cout << "false"; }    
}

Output: 

false


       There are some unspecified things when we compare two simple pointers but comparison between two values of type nullptr_t is specified as, comparison by <= and >= return true and comparison by < and > returns false and comparing any pointer type with nullptr by == and != returns true or false if it is null or non-null respectively.
       
       // C++ program to show comparisons with nullptr
#include <bits/stdc++.h>
using namespace std;

// Driver program to test behavior of nullptr
int main()
{
    // creating two variables of nullptr_t type 
    // i.e., with value equal to nullptr
    nullptr_t np1, np2;

    // <= and >= comparison always return true
    if (np1 >= np2)
        cout << "can compare" << endl;
    else
        cout << "can not compare" << endl;

    // Initialize a pointer with value equal to np1
    char *x = np1;  // same as x = nullptr (or x = NULL
                    // will also work) 
    if (x == nullptr)
        cout << "x is null" << endl;
    else
        cout << "x is not null" << endl;

    return 0;
}

References in C++


In C++, a reference works as an alias for an existing variable, providing an alternative name for it and allowing you to work with the original data directly.


#include <iostream>
using namespace std;

int main() {
    int x = 10;

    // ref is a reference to x.
    int& ref = x;

    // printing value using ref
    cout << ref << endl;
    
    // Changing the value and printing again
    ref = 22;
    cout << ref;

    return 0;
}

10
22

Explanation: In this program, ref is a reference to the variable x, meaning ref is just another name for x. When the value of ref is modified, it directly changes the value of x, since both ref and x refer to the same memory location.

Syntax

& is used to create a reference to a variable as shown:

    T &ref = var;

Here, ref refers to the variable named var which is of type T.

It is important to keep in mind the following things about reference.

    It is necessary to initialize the reference at the time of creation.
    A reference cannot refer to another variable once it is declared.


Applications

There are multiple applications for references in C++, a few of them are mentioned below:
1. Passing Arguments by Reference

References are commonly used in function arguments to allow modification of the original variable passed to the function. They are also more efficient for large data structures since no copies are made.

#include <iostream>
using namespace std;

void modifyValue(int &x) {
  
    // Modifies the original variable
    x = 20;  
}

int main() {
    int a = 10;
  
    // Pass a by reference
    modifyValue(a);
    
    cout << a;
    return 0;
}
20

Explanation: In this example, the function modifyValue() modifies the value of a directly by using a reference to it. No copy of a is made, and the original variable is modified.
2. Returning Reference from Functions

In C++, functions can return references to variables. This is especially useful when you need to return large data structures or want to allow direct modifications to a variable inside a function.

#include <iostream>
using namespace std;

int& getMax(int &a, int &b) {
  
    // Return the larger of the two numbers
    return (a > b) ? a : b;  
}

int main() {
    int x = 10, y = 20;
    int &maxVal = getMax(x, y);
  
    // Modify the value of the larger number
    maxVal = 30;  
    cout << "x = " << x << ", y = " << y;
    return 0;
}

x = 10, y = 30

Explanation: Here, the function getMax() returns a reference to the larger of two integers. Since maxVal is a reference, changing maxVal also modifies the value of y.

    Note: Keep in mind not to return a reference to local variables as they are destroyed once the function returns some value.


3. Modify Data in Range Based Loops

The range based for loops generally

#include <iostream>
#include <vector>
using namespace std;

int main() {
    vector<int> vect{ 10, 20, 30, 40 };

    // We can modify elements if we
    // use reference
    for (int& x : vect) {
        x = x + 5;
    }

    // Printing elements
    for (int x : vect) {
        cout << x << " ";
    }
    return 0;
}


References vs Pointers

Both references and pointers can be used to change the local variables of one function inside another function. Despite the similarity, there are the following differences between references and pointers which are listed in the below table:

Highlighting the key differences between References and Pointers in C++:

Highlighting the key differences between References and Pointers in C++:
Aspect	Reference	Pointer
Definition	A reference is an alias for an existing variable.	A pointer is a variable that stores the memory address of another variable.
Initialization	Must be initialized when declared and cannot be reassigned.	Can be initialized later and can be reassigned to point to different objects.
Nullability	Cannot be null; must always refer to an object.	Can be null, pointing to no object (e.g., nullptr).
Syntax	Uses & for declaration and accessing.	Uses * for declaration and dereferencing, & for address-of.
Dereferencing	No dereferencing required, ca be used directly like a normal variable.	Must be dereferenced using * to access the value it points to.

Void Type
	

A reference can never be void.
	

A pointer can be declared as void

Nesting
	

Reference variable has only one/single level of indirection.  
	

A pointer variable has n-levels/multiple levels of indirection i.e. single-pointer, double-pointer, triple-pointer
Pointer Arithmetic	Cannot perform arithmetic operations (e.g., increment or decrement).	Can perform arithmetic operations (e.g., increment or decrement).
Use Case	Primarily used for simpler, more readable references to variables.	Used for more complex memory management, dynamic memory allocation, and handling arrays.
Example	int& ref = x;	int* ptr = &x;


Limitations of References

    Once a reference is created, it cannot be later made to reference another object; it cannot be reset. This is often done with pointers. 
    References cannot be NULL. Pointers are often made NULL to indicate that they are not pointing to any valid thing. 
    A reference must be initialized when declared. There is no such restriction with pointers.

Due to the above limitations, references in C++ cannot be used for implementing data structures like Linked List, Tree, etc. In Java, references don’t have the above restrictions and can be used to implement all data structures. References being more powerful in Java is the main reason Java doesn’t need pointers.
Advantages of using References

    Safer: Since references must be initialized, wild references like wild pointers are unlikely to exist. It is still possible to have references that don’t refer to a valid location
    Easier to use: References don’t need a dereferencing operator to access the value. They can be used like normal variables. The ‘&’ operator is needed only at the time of declaration. Also, members of an object reference can be accessed with the dot operator (‘.’), unlike pointers where the arrow operator (->) is needed to access members.

Together with the above reasons, there are a few places like the copy constructor argument where a pointer cannot be used. Reference must be used to pass the argument in the copy constructor. Similarly, references must be used for overloading some operators like ++

What are Wild Pointers? How can we avoid?
Last Updated : 30 Oct, 2023

Uninitialized pointers are known as wild pointers because they point to some arbitrary memory location and may cause a program to crash or behave unexpectedly.

Can References Refer to Invalid Location in C++?
Last Updated : 07 Jan, 2022

Reference Variables: You can create a second name for a variable in C++, which you can use to read or edit the original data contained in that variable. While this may not sound appealing at first, declaring a reference and assigning it a variable allows you to treat the reference as if it were the original variable for the purposes of accessing and modifying the value of the original variable—even if the second name (the reference) is in a different scope. This means that if you make your function arguments references, you’ll be able to essentially change the data given into the function. This is in contrast to how C++ generally works, in which function parameters are copied into new variables. It also helps to save time.

In C++, Reference variables are safer than pointers because reference variables must be initialized and they cannot be changed to refer to something else once they are initialized. But there are exceptions where we can have invalid references.

1) Reference to Value at the Uninitialized Pointer

int *ptr;
int &ref = *ptr; // Reference to value at 
                 // some random memory location

2) Reference to a Local Variable is Returned

int& fun()
{
int a = 10;
return a;
}

Once fun() returns, the space allocated to it on the stack frame will be taken back. So the reference to a local variable will not be valid.

C and C++ support pointers, which is different from most other programming languages such as Java, Python, Ruby, Perl and PHP as they only support references. But interestingly, C++, along with pointers, also supports references. 

On the surface, both references and pointers are very similar as both are used to have one variable provide access to another. With both providing lots of the same capabilities, it’s often unclear what is different between these mechanisms. In this article, I will try to illustrate the differences between pointers and references. 

Pointers: A pointer is a variable that holds the memory address of another variable. A pointer needs to be dereferenced with the * operator to access the memory location it points to. 

References: A reference variable is an alias, that is, another name for an already existing variable. A reference, like a pointer, is also implemented by storing the address of an object. 
A reference can be thought of as a constant pointer (not to be confused with a pointer to a constant value!) with automatic indirection, i.e., the compiler will apply the * operator for you. 

Understanding the differences between pointers and references is crucial for effective C++ programming. The C++ Course explains these concepts in depth, helping you choose the right approach in your code.

int i = 3; 

// A pointer to variable i or "stores the address of i"
int *ptr = &i; 

// A reference (or alias) for i.
int &ref = i; 

Differences:  

1. Initialization: A pointer can be initialized in this way: 

int a = 10;
int *p = &a;
// OR 
int *p;
p = &a;

We can declare and initialize pointer at same step or in multiple line.

2. While in references,

int a = 10;
int &p = a; // It is correct
// but
int &p;
p = a; // It is incorrect as we should declare and initialize references at single step

NOTE: This difference may vary from compiler to compiler. The above difference is with respect to Turbo IDE. 

3. Reassignment: A pointer can be re-assigned. This property is useful for the implementation of data structures like a linked list, a tree, etc. See the following example: 

int a = 5;
int b = 6;
int *p;
p = &a;
p = &b;

4. On the other hand, a reference cannot be re-assigned, and must be assigned at initialization.

int a = 5;
int b = 6;
int &p = a;
int &p = b; // This will throw an error of "multiple declaration is not allowed"

// However it is valid statement,
int &q = p;

5. Memory Address: A pointer has its own memory address and size on the stack, whereas a reference shares the same memory address with the original variable and takes up no space on the stack.

int &p = a;
cout << &p << endl << &a;

6. NULL value: A pointer can be assigned NULL directly, whereas a reference cannot be. The constraints associated with references (no NULL, no reassignment) ensure that the underlying operations do not run into an exception situation.

7. Indirection: You can have a pointer to pointer (known as a double pointer) offering extra levels of indirection, whereas references only offer one level of indirection. For example, 

In Pointers,
int a = 10;
int *p;
int **q; // It is valid.
p = &a;
q = &p;

// Whereas in references,
int &p = a;
int &&q = p; // It is reference to reference, so it is an error

8. Arithmetic operations: Various arithmetic operations can be performed on pointers, whereas there is no such thing called Reference Arithmetic (however, you can perform pointer arithmetic on the address of an object pointed to by a reference, as in &obj + 5). 
Tabular form of difference between References and Pointers in C++
  	References 	Pointers
Reassignment 	The variable cannot be reassigned in Reference. 	The variable can be reassigned in Pointers.
Memory Address 	It shares the same address as the original variable. 	Pointers have their own memory address.
Work 	It is referring to another variable. 	It is storing the address of the variable.
Null Value 	It does not have null value. 	It can have value assigned as null.
Arguments 	This variable is referenced by the method pass by value. 	The pointer does it work by the method known as pass by reference.

When to use What

The performances are exactly the same as references are implemented internally as pointers. But still, you can keep some points in your mind to decide when to use what:  

    Use references: 
        In function parameters and return types.
    Use pointers: 
        If pointer arithmetic or passing a NULL pointer is needed. For example, for arrays (Note that accessing an array is implemented using pointer arithmetic).
        To implement data structures like a linked list, a tree, etc. and their algorithms. This is so because, in order to point to different cells, we have to use the concept of pointers.

Quoted in C++ FAQ Lite: Use references when you can, and pointers when you have to. References are usually preferred over pointers whenever you don’t need “reseating”. This usually means that references are most useful in a class’s public interface. References typically appear on the skin of an object, and pointers on the inside. 

The exception to the above is where a function’s parameter or return value needs a “sentinel” reference — a reference that does not refer to an object. This is usually best done by returning/taking a pointer, and giving the “nullptr” value this special significance (references must always alias objects, not a dereferenced null pointer). 

Passing By Pointer vs Passing By Reference in C++

In C++, we can pass parameters to a function either by pointers or by reference. In both cases, we get the same result. So, what is the difference between Passing by Pointer and Passing by Reference in C++?

Let’s first understand what Passing by Pointer and Passing by Reference in C++ mean:
Passing by Pointer

Here, the memory location (address) of the variables is passed to the parameters in the function, and then the operations are performed. It is also called the call by pointer method.
// C++ program to swap two numbers using
// pass by pointer
#include <iostream>
using namespace std;

void swap(int *x, int *y)
{
    int z = *x;
    *x = *y;
    *y = z;
}

// Driver Code
int main()
{
    int a = 45, b = 35;
    cout << "Before Swap\n";
    cout << "a = " << a << " b = " << b << "\n";

    swap(&a, &b);

    cout << "After Swap with pass by pointer\n";
    cout << "a = " << a << " b = " << b << "\n";
}

Before Swap
a = 45 b = 35
After Swap with pass by pointer
a = 35 b = 45

Passing By Reference

It allows a function to modify a variable without having to create a copy of it. We have to declare reference variables. The memory location of the passed variable and parameter is the same and therefore, any change to the parameter reflects in the variable as well.


It is also called the Call by Reference method.
// C++ program to swap two numbers using
// pass by reference
#include <iostream>
using namespace std;
void swap(int& x, int& y)
{
    int z = x;
    x = y;
    y = z;
}

int main()
{
    int a = 45, b = 35;
    cout << "Before Swap\n";
    cout << "a = " << a << " b = " << b << "\n";

    swap(a, b);

    cout << "After Swap with pass by reference\n";
    cout << "a = " << a << " b = " << b << "\n";
}

Before Swap
a = 45 b = 35
After Swap with pass by reference
a = 35 b = 45

Pass by Pointer vs Pass by Reference

Knowing the differences between passing by pointer and passing by reference is crucial for effective function design. The following table lists the major differences between the pass-by-pointer and pass-by-reference methods.

// C++ program to swap two numbers using
// pass by reference
#include <iostream>
using namespace std;
void swap(int& x, int& y)
{
    int z = x;
    x = y;
    y = z;
}

int main()
{
    int a = 45, b = 35;
    cout << "Before Swap\n";
    cout << "a = " << a << " b = " << b << "\n";

    swap(a, b);

    cout << "After Swap with pass by reference\n";
    cout << "a = " << a << " b = " << b << "\n";
}

Before Swap
a = 45 b = 35
After Swap with pass by reference
a = 35 b = 45

Pass by Pointer vs Pass by Reference

Knowing the differences between passing by pointer and passing by reference is crucial for effective function design. The following table lists the major differences between the pass-by-pointer and pass-by-reference methods.
Parameters	

Pass by Pointer
	

Pass by Reference

Passing Arguments
	We pass the address of arguments in the function call.	We pass the arguments in the function call.

Accessing Values
	The value of the arguments is accessed via the dereferencing operator *	The reference name can be used to implicitly reference a value.

Reassignment
	Passed parameters can be moved/reassigned to a different memory location.	Parameters can’t be moved/reassigned to another memory address.

Allowed Values
	Pointers can contain a NULL value, so a passed argument may point to a NULL or even a garbage value.	References cannot contain a NULL value, so it is guaranteed to have some value.
	
	Difference Between Reference Variable and Pointer Variable

A reference is the same object, just with a different name and a reference must refer to an object. Since references can’t be NULL, they are safer to use. 

    A pointer can be re-assigned while a reference cannot, and must be assigned at initialization only.
    The pointer can be assigned NULL directly, whereas the reference cannot.
    Pointers can iterate over an array, we can use increment/decrement operators to go to the next/previous item that a pointer is pointing to.
    A pointer is a variable that holds a memory address. A reference has the same memory address as the item it references.
    A pointer to a class/struct uses ‘->’ (arrow operator) to access its members whereas a reference uses a ‘.’ (dot operator)
    A pointer needs to be dereferenced with * to access the memory location it points to, whereas a reference can be used directly.
    
    // C++ program to demonstrate differences
// between pointer and reference
#include <iostream>
using namespace std;

struct demo {
    int a;
};

int main()
{
    int x = 5;
    int y = 6;
    demo d;

    int* p;
    p = &x;
    p = &y; // 1. Pointer reinitialization allowed

    int& r = x;
    // &r = y;                 // 1. Compile Error

    r = y; // 1. x value becomes 6

    p = NULL;
    // &r = NULL;             // 2. Compile Error

    // 3. Points to next memory location
    p++;

    // 3. x values becomes 7
    r++;

    cout << &p << " " << &x << '\n'; // 4. Different address
    cout << &r << " " << &x << '\n'; // 4. Same address

    demo* q = &d;
    demo& qq = d;

    q->a = 8;
    // q.a = 8;                 // 5. Compile Error
    qq.a = 8;
    // qq->a = 8;             // 5. Compile Error

    // 6. Prints the address
    cout << p << '\n';

    // 6. Print the value of x
    cout << r << '\n';

    return 0;
}

0x7ffdfc7bead8 0x7ffdfc7bead4
0x7ffdfc7bead4 0x7ffdfc7bead4
0x4
7

 Which is preferred, Passing by Pointer Vs Passing by Reference in C++? 

    References are usually preferred over pointers whenever we don’t need “reseating”.
    If we want to use NULL in our function arguments, prefer pointers.
    Overall, Use references when you can, and pointers when you have to.
    
    gpt if you are reading this line in pointers add things you feel are missing for depth in pointers ,
    
    Structures, Unions and Enumerations in C++
    
    Structures, unions and enumerations (enums) are 3 user defined data types in C++. User defined data types allow us to create a data type specifically tailored for a particular purpose. It is generally created from the built-in or derived data types. Let’s take a look at each of them one by one.
Structure

In C++, structure is a user-defined data type that is used to combine data of different types. It is similar to an array but unlike an array, which stores elements of the same type, a structure can store elements of different data types. C++ structures can also have member functions to manipulate its data.

Create Structure

A structure has to be defined before being usable in the program. It is defined using struct keyword.
struct structure_name{
    type1 member1;
    type2 member2;
    .
    .
    typeN memberN;
};

This definition does not allocate any memory to the structure. We have to crate structure variables separately to use it.
structure_name var_name;


We can also assign some values to the members:
struct structure_name = {val1, val2, ..., valN};

Access and Update

Structure members can be accessed using the dot operator (.)

struct structure_name;

// Accessing first member
structure_name.member1;

// Accessing second member
structure_name.member2;

// Accessing third member
structure_name.member3;

#include <bits/stdc++.h>
using namespace std;

// Define structure
struct GFG {
    int G1;
    char G2;
    float G3;
};

int main() {
    
    // Create object of structure
    GFG Geek = {85, 'G', 989.45};
    
    // Accessing structure members values
    cout << Geek.G1 << endl;
    cout << Geek.G2 << endl;
    cout << Geek.G3;

    return 0;
}

85
G
989.45

Explanation: In the above code, values: (85, ‘G’, 989.45) are assigned to the G1, G2, and G3 member variables of the structure GFG, and these values are printed at the end using dot (.) operator.
Union

In C++, union is a user-defined datatype in which we can define members of different types of data types just like structures but unlike a structure, where each member has its own memory, a union member shares the same memory location.
Create Union

Union is first defined using union keyword
union union_name{
    type1 member1;
    type2 member2;
    .
    .
    typeN memberN;
};

Then we can create union variables:
union_name var_name;

Access and Update

Only one member of a union stores memory at one time
var_name.member1 = val

#include <iostream>
using namespace std;

// Defining a Union
union GFG {
    int G1;
    char G2;
    float G3;
};

int main() {
    
    // Create an object of GFG union
    GFG Geek;
    
    // Assign union's member variables
    Geek.G1 = 85;
    
    // Accessing union members values
    cout << Geek.G1 << endl;
    
    Geek.G2 = 'G';
    cout << Geek.G2 << endl;
    
    Geek.G3 = 989.45;
    cout <<  Geek.G3;
    
    return 0;
}

Enumeration

In C++, enumeration (enum) is a user-defined type that consists of a set of named integral constants. Enumerations help make the code more readable and easier to maintain by assigning meaningful names to constants.
Create Enums

Just like all other user defined data types, enums also needs to be defined before we can use it.
enum enum_name {
    value1, value2, value3…..valueN
};

	Once defined, it can be used in the C++ program.
	Once defined, it can be used in the C++ program.
	enum_name var_name = value

This value should be taken from the defined value.

Structures in C++
Last Updated : 11 Jan, 2025

We often come around situations where we need to store a group of data whether of similar data types or non-similar data types. We have seen Arrays in C++ which are used to store set of data of similar data types at contiguous memory locations.
Unlike Arrays, Structures in C++ are user defined data types which are used to store group of items of non-similar data types. 

What is a structure?

A structure is a user-defined data type in C/C++. A structure creates a data type that can be used to group items of possibly different types into a single type. 
How to create a structure?

The ‘struct’ keyword is used to create a structure. The general syntax to create a structure is as shown below:  

struct structureName{
    member1;
    member2;
    member3;
    .
    .
    .
    memberN;
};

Structures in C++ can contain two types of members:  

    Data Member: These members are normal C++ variables. We can create a structure with variables of different data types in C++.
    Member Functions: These members are normal C++ functions. Along with variables, we can also include functions inside a structure declaration.
    // Data Members
int roll;
int age;
int marks;
    
// Member Functions
void printDetails()
{
    cout<<"Roll = "<<roll<<"\n";
    cout<<"Age = "<<age<<"\n";
    cout<<"Marks = "<<marks;
}

n the above structure, the data members are three integer variables to store roll number, age and marks of any student and the member function is printDetails() which is printing all of the above details of any student.

How to declare structure variables?

A structure variable can either be declared with structure declaration or as a separate declaration like basic types
// A variable declaration with structure declaration.
struct Point
{
   int x, y;
} p1;  // The variable p1 is declared with 'Point'


// A variable declaration like basic data types
struct Point
{
   int x, y;
}; 

int main()
{
   struct Point p1;  // The variable p1 is declared like a normal variable
}

Note: In C++, the struct keyword is optional before in declaration of a variable. In C, it is mandatory.
 


How to initialize structure members? 
Structure members cannot be initialized with declaration. For example the following C program fails in compilation. 
But is considered correct in C++11 and above. 
struct Point
{
   int x = 0;  // COMPILER ERROR:  cannot initialize members here
   int y = 0;  // COMPILER ERROR:  cannot initialize members here
}; 

The reason for above error is simple, when a datatype is declared, no memory is allocated for it. Memory is allocated only when variables are created.

Structure members can be initialized with declaration in C++. For Example the following  C++ program Executes Successfully without throwing any Error.
// In C++ We can Initialize the Variables with Declaration in Structure.

#include <iostream>
using namespace std;

struct Point {
    int x = 0; // It is Considered as Default Arguments and no Error is Raised
    int y = 1;
};

int main()
{
    struct Point p1;

    // Accessing members of point p1
    // No value is Initialized then the default value is considered. ie x=0 and y=1;
    cout << "x = " << p1.x << ", y = " << p1.y<<endl;
  
    // Initializing the value of y = 20;
    p1.y = 20;
    cout << "x = " << p1.x << ", y = " << p1.y;
    return 0;
}
// This code is contributed by Samyak Jain

 x=0, y=1
 x=0, y=20

Structure members can be initialized using curly braces ‘{}’. For example, following is a valid initialization.
struct Point {
    int x, y;
};

int main()
{
    // A valid initialization. member x gets value 0 and y
    // gets value 1.  The order of declaration is followed.
    struct Point p1 = { 0, 1 };
}

How to access structure elements? 
Structure members are accessed using dot (.) operator. 

#include <iostream>
using namespace std;

struct Point {
    int x, y;
};

int main()
{
    struct Point p1 = { 0, 1 };

    // Accessing members of point p1
    p1.x = 20;
    cout << "x = " << p1.x << ", y = " << p1.y;

    return 0;
}


x = 20, y = 1

What is an array of structures?


Like other primitive data types, we can create an array of structures. 
What is a structure pointer? 
Like primitive types, we can have pointer to a structure. If we have a pointer to structure, members are accessed using arrow ( -> ) operator instead of the dot (.) operator.
#include <iostream>
using namespace std;

struct Point {
    int x, y;
};

int main()
{
    struct Point p1 = { 1, 2 };

    // p2 is a pointer to structure p1
    struct Point* p2 = &p1;

    // Accessing structure members using
    // structure pointer
    cout << p2->x << " " << p2->y;
    return 0;
}


C++ – Pointer to Structure
Last Updated : 07 Oct, 2022

Pointer to structure in C++ can also be referred to as Structure Pointer. A structure Pointer in C++ is defined as the pointer which points to the address of the memory block that stores a structure. Below is an example of the same:
struct name_of_structure *ptr;

// Initialization of structure is done as shown below

ptr = &structure_variable;
	// C++ program to demonstrate Pointer to Structure
#include <iostream>

using namespace std;

struct point {
	int value;
};

int main()
{

	struct point g;
	// Initialization of the structure pointer
	struct point* ptr = &g;

	return 0;
}

In the above code g is an instance of struct point and ptr is the struct pointer because it is storing the address of struct point. 
// C++ program to Demonstrate Pointer to Structure
#include <iostream>
#include <stdio.h>

using namespace std;

// Structure declaration for
// vertices
struct GFG {
	int x;
	int y;
};

// Structure declaration for
// Square
struct square {

	// An object left is declared
	// with 'GFG'
	struct GFG left;

	// An object right is declared
	// with 'GFG'
	struct GFG right;
};

// Function to calculate area of
// the given Square
void area_Square(struct square s)
{
	// Find the area of the Square
	// using variables of point
	// structure where variables of
	// point structure is accessed
	// by left and right objects
	int area = (s.right.x) * (s.left.x);

	// Print the area
	cout << area << endl;
}

// Driver Code
int main()
{
	// Initialize variable 's'
	// with vertices of Square
	struct square s = { { 4, 4 }, { 4, 4 } };

	// Function Call
	area_Square(s);

	return 0;
}


output 16


Self Referential Structures


Self Referential structures are those structures that have one or more pointers which point to the same type of structure, as their member




In other words, structures pointing to the same type of structures are self-referential in nature
struct node {
    int data1;
    char data2;
    struct node* link;
};

int main()
{
    struct node ob;
    return 0;
}

In the above example ‘link’ is a pointer to a structure of type ‘node’. Hence, the structure ‘node’ is a self-referential structure with ‘link’ as the referencing pointer. 
An important point to consider is that the pointer should be initialized properly before accessing, as by default it contains garbage value.

Types of Self Referential Structures  

    Self Referential Structure with Single Link
    Self Referential Structure with Multiple Links


Self Referential Structure with Single Link: These structures can have only one self-pointer as their member. The following example will show us how to connect the objects of a self-referential structure with the single link and access the corresponding data members. The connection formed is shown in the following figure. 


#include <stdio.h>

struct node {
    int data1;
    char data2;
    struct node* link;
};

int main()
{
    struct node ob1; // Node1

    // Initialization
    ob1.link = NULL;
    ob1.data1 = 10;
    ob1.data2 = 20;

    struct node ob2; // Node2

    // Initialization
    ob2.link = NULL;
    ob2.data1 = 30;
    ob2.data2 = 40;

    // Linking ob1 and ob2
    ob1.link = &ob2;

    // Accessing data members of  ob2 using ob1
    printf("%d", ob1.link->data1);
    printf("\n%d", ob1.link->data2);
    return 0;
}

Self Referential Structure with Multiple Links: Self referential structures with multiple links can have more than one self-pointers. Many complicated data structures can be easily constructed using these structures. Such structures can easily connect to more than one nodes at a time. The following example shows one such structure with more than one links.
The connections made in the above example can be understood using the following figure

#include <stdio.h>

struct node {
    int data;
    struct node* prev_link;
    struct node* next_link;
};

int main()
{
    struct node ob1; // Node1

    // Initialization
    ob1.prev_link = NULL;
    ob1.next_link = NULL;
    ob1.data = 10;

    struct node ob2; // Node2

    // Initialization
    ob2.prev_link = NULL;
    ob2.next_link = NULL;
    ob2.data = 20;

    struct node ob3; // Node3

    // Initialization
    ob3.prev_link = NULL;
    ob3.next_link = NULL;
    ob3.data = 30;

    // Forward links
    ob1.next_link = &ob2;
    ob2.next_link = &ob3;

    // Backward links
    ob2.prev_link = &ob1;
    ob3.prev_link = &ob2;

    // Accessing  data of ob1, ob2 and ob3 by ob1
    printf("%d\t", ob1.data);
    printf("%d\t", ob1.next_link->data);
    printf("%d\n", ob1.next_link->next_link->data);

    // Accessing data of ob1, ob2 and ob3 by ob2
    printf("%d\t", ob2.prev_link->data);
    printf("%d\t", ob2.data);
    printf("%d\n", ob2.next_link->data);

    // Accessing data of ob1, ob2 and ob3 by ob3
    printf("%d\t", ob3.prev_link->prev_link->data);
    printf("%d\t", ob3.prev_link->data);
    printf("%d", ob3.data);
    return 0;
}

10    20    30
10    20    30
10    20    30

In the above example we can see that ‘ob1’, ‘ob2’ and ‘ob3’ are three objects of the self referential structure ‘node’. And they are connected using their links in such a way that any of them can easily access each other’s data. This is the beauty of the self referential structures. The connections can be manipulated according to the requirements of the programmer.

Applications: Self-referential structures are very useful in creation of other complex data structures like: 

Let’s discuss, what are the differences between structures in C and structures in C++? In C++, structures are similar to classes.
Differences Between the C and C++ Structures

C Structures
	

C++ Structures
Only data members are allowed, it cannot have member functions. 	Can hold both: member functions and data members.
Cannot have static members. 	Can have static members.
Cannot have a constructor inside a structure. 	Constructor creation is allowed.
Direct Initialization of data members is not possible. 	Direct Initialization of data members is possible.
Writing the ‘struct’ keyword is necessary to declare structure-type variables. 	Writing the ‘struct’ keyword is not necessary to declare structure-type variables.
Do not have access modifiers. 	Supports access modifiers.
Only pointers to structs are allowed. 	Can have both pointers and references to the struct.
Sizeof operator will generate 0  for an empty structure. 	Sizeof operator will generate 1 for an empty structure.
Data Hiding is not possible. 	Data Hiding is possible.

Similarities Between the C and C++ Structures

    Both in C and C++, members of the structure have public visibility by default.

Lets discuss some of the above mentioned differences and similarities one by one:

1. Member functions inside the structure: Structures in C cannot have member functions inside a structure but Structures in C++ can have member functions along with data members.

// C Program to Implement Member
// functions inside structure
 
#include <stdio.h>
 
struct marks {
    int num;
 
    // Member function inside Structure to
    // take input and store it in "num"
    void Set(int temp) { num = temp; }
 
    // function used to display the values
    void display() { printf("%d", num); }
};
 
// Driver Program
int main()
{
    struct marks m1;
    // calling function inside Struct to
    // initialize value to num
    m1.Set(9);
 
    // calling function inside struct to
    // display value of Num
    m1.display();
}

Output

This will generate an error in C but no error in C++. 

// C++ Program to Implement Member functions inside
// structure
 
#include <iostream>
using namespace std;
 
struct marks {
    int num;
 
    // Member function inside Structure to
    // take input and store it in "num"
    void Set(int temp) { num = temp; }
 
    // function used to display the values
    void display() { cout << "num=" << num; }
};
 
// Driver Program
int main()
{
    marks m1;
 
    // calling function inside Struct to
    // initialize value to num
    m1.Set(9);
 
    // calling function inside struct to
    // display value of Num
    m1.display();
}

 
 
Output

num=9

 

2. Static Members: C structures cannot have static members but are allowed in C++. 

 

// C program with structure static member
 
struct Record {
    static int x;
};
 
// Driver program
int main() { return 0; }

This will generate an error in C but not in C++. 

3. Constructor creation in structure: Structures in C cannot have a constructor inside a structure but Structures in C++ can have Constructor creation.

// C program to demonstrate that
// Constructor is not allowed
 
#include <stdio.h>
 
struct Student {
    int roll;
    Student(int x) { roll = x; }
};
 
// Driver Program
int main()
{
    struct Student s(2);
    printf("%d", s.x);
    return 0;
}

This will generate an error in C.

Output in C++:

2

4. Direct Initialization: We cannot directly initialize structure data members in C but we can do it in C++. 

// C program to demonstrate that direct
// member initialization is not possible in C
 
#include <stdio.h>
 
struct Record {
    int x = 7;
};
 
// Driver Program
int main()
{
    struct Record s;
    printf("%d", s.x);
    return 0;
}

This will generate an error in C.

Output in C++: 

7

5. Using struct keyword: In C, we need to use a struct to declare a struct variable. In C++, a struct is not necessary. For example, let there be a structure for Record. In C, we must use “struct Record” for Record variables. In C++, we need not use struct, and using ‘Record‘ only would work.

6. Access Modifiers: C structures do not have access modifiers as these modifiers are not supported by the language. C++ structures can have this concept as it is inbuilt in the language.  

7. Pointers and References: In C++, there can be both pointers and references to a struct in C++, but only pointers to structs are allowed in C. 

8. sizeof operator: This operator will generate 0 for an empty structure in C whereas 1 for an empty structure in C++.  

// C program to illustrate empty structure
 
#include <stdio.h>
 
// empty structure
struct Record {
};
 
// Driver Code
int main()
{
    struct Record s;
    printf("%lu\n", sizeof(s));
    return 0;
}

Output in C: 

0

Output in C++: 

1


    NOTE:   The default type of  sizeof  is long unsigned int , that’s why  “%lu” is used instead of “%d” in printf function.

9. Data Hiding: C structures do not allow the concept of Data hiding but are permitted in C++ as it is an object-oriented language whereas C is not. 

10. Constant Members: C struct may allow to declare constant members, but no way to initialize. But in C++, you can initialize using constructor initializer list

#include <stdio.h>
 
struct C_struct 
{
    const int i;
    int k;
};
int main()
{
    printf("Struct with constant members, but how to init??");
    return 0;
}

Output in C:

Struct with constant members, but how to init??

Output in C++:

Struct with constant members: 2 3

 
Related Article: Structure vs Class in C++
 
 Enumeration in C++
 
 Enumeration in C++
 In C++, enumeration is a user-defined data type that consists of a set of named integer constants. It helps in assigning meaningful names to integer values to improve code readability and maintainability.
 enum enum_name { 
    name1, name2, name3, ... 
};

where name1, name2, …. are the names for the constant. They should be unique identifiers. By default, the first name in an enum is assigned the integer value 0, and the subsequent ones are incremented by 1.

After that, we can create a variable of this enum and assign it some name constant that was defined in it.
enum_name var;

Initializing Enum

An enum variable should be initialized by either the name defined in enum definition or directly its integer value.
#include <iostream>
using namespace std;

// Defining enum
enum direction {
    EAST, NORTH, WEST, SOUTH
};

int main() {

    // Creating enum variable
    direction dir = NORTH;
    cout << dir;
    return 0;
}

1

Changing Values of Named Constant

We can manually assign values to enum members if needed.
enum enum_name { 
    name1 = val1, name2 = val2, name3, ... 
};



val1, val2 … values should be integer. It is also not compulsory to define the value of all constant names. If the current constant name value is x, then subsequent values will keep incrementing by one.
#include <iostream>
using namespace std;

// Defining enum
enum fruit {
    APPLE, BANANA = 5, ORANGE
};

int main() {

    // Creating enum variable
    fruit f = BANANA;
    cout << f << endl;
    
    // Changing the value
    f = ORANGE;
    cout << f;
    return 0;
}

5
6

Enum Classes

C++11 introduced enum class, which provides better type safety. It helps in resolving name conflicts by providing scope to the constant names. It also requires manual typecasting to integer values from names.
Create enum Class

Enum class can be created just by adding the class keyword in the enum delcaration.
#include <iostream>
using namespace std;

// Define the enum class
enum class Day { Sunday = 1, Monday, Tuesday,
                Wednesday, Thursday, Friday, 
                Saturday };

int main() {
    
    // initializing
    Day today = Day::Thursday;
    
    // Print the enum
    cout << static_cast<int>(today);
    return 0;
}

5

If we try to just assign the name of the constant to the enum variable, compiler gives an error.


    // initializing
    Day today = Thursday;


Output

error: ‘PROTON’ was not declared in this scope; did you mean ‘Charge::PROTON’?
   14 |     Charge part = PROTON;
      |                   ^~~~~~
      |                   Charge::PROTON
      
      
typedef in C++
Last Updated : 28 Oct, 2022

typedef keyword in C++ is used for aliasing existing data types, user-defined data types, and pointers to a more meaningful name. Typedefs allow you to give descriptive names to standard data types, which can also help you self-document your code. Mostly typedefs are used for aliasing, only if the predefined name is too long or complex to write again and again.  The unnecessary use of typedef is generally not a good practice.

typedef <current_name> <new_name>

Example:

typedef std::vector<int> vInt;

Below is the C++ Program to implement typedef
// C++ Program to implement typedef 
#include <bits/stdc++.h> 

using namespace std; 

int main() 
{ 
	// Now we can make more vectors by using vInt 
	typedef std::vector<int> vInt; 

	// vec1 is a vectorof type int 
	vInt v; 

	v.push_back(190); 
	v.push_back(180); 
	v.push_back(10); 
	v.push_back(10); 
	v.push_back(27); 

	for (auto X : v) { 
		cout << X << " "; 
	} 

	return 0; 
}

190 180 10 10 27 

Applications of typedef in C++

    typedef in C++ can be used for aliasing predefined data types with long names.
    It can be used with STL data structures like Vectors, Strings, Maps, etc.
    typedef can be used with arrays as well.
    We can use typedef with normal pointers as well as function pointers.

Using typedef with predefined data types

Typedef can be used for aliasing predefined data types like int, char, float, and their derivatives like long, short, signed, and unsigned. The new alias can then be used for making new variables of respective types.


typedef <data_type_name> <new_name>

Example:

// C++ for using typedef with predefined data types 
#include <iostream> 
  
using namespace std; 
  
int main() 
{ 
    // ulli can now be used for making more 
    // unsigned long long int type variables 
    typedef unsigned long long int ulli; 
    // ulli used to make variables 
    ulli a{ 1232133 }; 
    cout << a; 
    return 0; 
}

1232133

Using typedef with STL data structures

typedef can also be used with STL Data Structures, like Vectors, Strings, Maps, etc.  If we are one of those, who do not want to import the entire std namespace in our code, then we need to write std::vector, std::string, etc, again and again. Thus using typedef, in this case, can be a quick way to prevent this and keep our code clean and readable.

Syntax:

typedef <data_structure_name> <new_name>
// C++ Program to display usage for typedef with vectors 
#include <iostream> 
#include <vector> 

int main() 
{ 
	// Now we can make more vectors by using vInt 
	typedef std::vector<int> vInt; 
	// vec1 is a vectorof type int 
	vInt vec1{ 1, 2, 3, 6, 2, 1 }; 

	// Outputting the vector 
	for (int i = 0; i < vec1.size(); i++) { 
		std::cout << vec1[i] <<" "; 
	} 
	return 0; 
}

1 2 3 6 2 1 

Using typedef with arrays

typedef can be used with arrays for making newer arrays (just like using them with STL data structures). We can easily make new arrays or make arrays of arrays using typedef with arrays, while keeping our code readable, seamlessly.

Syntax: 

typedef <data_type> <alias_name> [<size>]

After this <alias_name> can now be used for creating arrays of type- <data_type> and size <size>.
// C++ program to show use of typedef with arrays 
#include <iostream> 
using namespace std; 

int main() 
{ 

	typedef int arr[3]; 

	// Making new 1D array 

	arr array1{ 1 , 1, 1}; 
	

	cout << "Array output: "
		<< "\n"; 
	for (int i = 0; i < 3; i++) { 
		cout << array1[i] << " "; 
	} 
	cout << "\n"; 

	// Making new 2D array 
	// Matrix is an array of arrays with size 
	// ( 3 X 3 ) 
	arr matrix[3]; 

	cout << "Matrix output: "
		<< "\n"; 

	for (int i = 0; i < 3; i++) { 
		for (int j = 0; j < 3; j++) { 
			// Initializing the matrix 
			matrix[i][j] = i * j; 
		} 
	} 

	// Outputting the matrix 

	for (int i = 0; i < 3; i++) { 
		for (int j = 0; j < 3; j++) { 
			cout << matrix[i][j] << " "; 
		} 
		cout << "\n"; 
	} 

	return 0; 
}

Array output: 
1 1 1 
Matrix output: 
0  0  0  
0  1  2  
0  2  4  

Using typedef with pointers

Typedef can be used with pointers as well. For faster creation of pointers, and keeping the code readable as well. We can use them with both data pointers as well as function pointers.
( i ) Usage with data pointers:

Below is the syntax, example, and source code for using typedef with data pointers

Syntax:


typedef <data_type>* <alias_name>

Example:

typedef int* iPtr;
iPtr pointer1, pointer2;

Below is the program to use typedef with data pointers.

// C++ Program to showcase the use of typedef 
//  with data pointer 
  
#include <iostream> 
using namespace std; 
  
int main() 
{ 
    int a = 10; 
    int b = 20; 
    // iPtr can now be used to create new pointers of type 
    // int 
    typedef int* iPtr; 
  
    iPtr pointer_to_a = &a; 
    iPtr pointer_to_b = &b; 
  
    cout << "a is: " << *pointer_to_a << "\n"; 
    cout << "b is: " << *pointer_to_b << "\n"; 
  
    return 0; 
}
Output

a is: 10
b is: 20

( ii ) Usage with function pointers:

Below is the syntax, example, and code to display the usage of typedef with function pointers.

Syntax:

typedef <return_type> (*<alias_name>)(<parameter_type>,<parameter_type>,....);

Example:

typedef int (*fun_ptr)(int, int);
fun_ptr new_ptr = &function; 

Here, fun ptr can now be used to create more function pointers. This will be more clear in the code below.

#include <iostream> 
  
// Normal pointer to a function 
int (*func_ptr1)(int, int); 
  
// Using typedef with pointer to a function 
typedef int (*func_ptr2)(int, int); 
  
// Function to multiply two numbers 
int product(int u, int v) { return u * v; } 
  
int main(void) 
{ 
    func_ptr1 = &product; 
  
    // Using typedefed function pointer for creating new 
    // function pointer "new_func" 
    func_ptr2 new_func_ptr = &product; 
  
    // Using normal pointer to a function 
    int x2 = (*func_ptr1)(3, 2); 
  
    // Using the new function pointer 
    int x1 = (*new_func_ptr)(2, 4); 
  
    std::cout << x1 << std::endl; 
    std::cout << x2 << std::endl; 
}
Output

8
6

Here, “func_ptr1” is a normal function pointer, while “func_ptr2”  is a typedef function pointer and it can be used to create more function pointers taking 2 integers as arguments and with return type “int”.

Array of Structures vs Array within a Structure in C
Last Updated : 10 Jan, 2025

Both Array of Structures and Array within a Structure in C programming is a combination of arrays and structures but both are used to serve different purposes.
Array within a Structure

A structure is a data type in C that allows a group of related variables to be treated as a single unit instead of separate entities. A structure may contain elements of different data types – int, char, float, double, etc. It may also contain an array as its member. Such an array is called an array within a structure. An array within a structure is a member of the structure and can be accessed just as we access other elements of the structure.

Below is a demonstration of a program that uses the concept of the array within a structure. The program displays the record of a student comprising the roll number, grade, and marks secured in various subjects. The marks in various subjects have been stored under an array called marks. The whole record is stored under a structure called a candidate.
Example

The below program demonstrates the use of an array within a structure.
// C program to demonstrate the
// use of an array within a structure
#include <stdio.h>

// Declaration of the structure candidate
struct candidate {
    int roll_no;
    char grade;

    // Array within the structure
    float marks[4];
};

// Function to displays the content of
// the structure variables
void display(struct candidate a1)
{

    printf("Roll number : %d\n", a1.roll_no);
    printf("Grade : %c\n", a1.grade);
    printf("Marks secured:\n");
    int i;
    int len = sizeof(a1.marks) / sizeof(float);

    // Accessing the contents of the
    // array within the structure
    for (i = 0; i < len; i++) {
        printf("Subject %d : %.2f\n", i + 1, a1.marks[i]);
    }
}

// Driver Code
int main()
{
    // Initialize a structure
    struct candidate A = { 1, 'A', { 98.5, 77, 89, 78.5 } };

    // Function to display structure
    display(A);
    return 0;
}


Array of Structures vs Array within a Structure in C
Last Updated : 10 Jan, 2025

Both Array of Structures and Array within a Structure in C programming is a combination of arrays and structures but both are used to serve different purposes.
Array within a Structure

A structure is a data type in C that allows a group of related variables to be treated as a single unit instead of separate entities. A structure may contain elements of different data types – int, char, float, double, etc. It may also contain an array as its member. Such an array is called an array within a structure. An array within a structure is a member of the structure and can be accessed just as we access other elements of the structure.

Below is a demonstration of a program that uses the concept of the array within a structure. The program displays the record of a student comprising the roll number, grade, and marks secured in various subjects. The marks in various subjects have been stored under an array called marks. The whole record is stored under a structure called a candidate.
Example

The below program demonstrates the use of an array within a structure.

// C program to demonstrate the
// use of an array within a structure
#include <stdio.h>

// Declaration of the structure candidate
struct candidate {
    int roll_no;
    char grade;

    // Array within the structure
    float marks[4];
};

// Function to displays the content of
// the structure variables
void display(struct candidate a1)
{

    printf("Roll number : %d\n", a1.roll_no);
    printf("Grade : %c\n", a1.grade);
    printf("Marks secured:\n");
    int i;
    int len = sizeof(a1.marks) / sizeof(float);

    // Accessing the contents of the
    // array within the structure
    for (i = 0; i < len; i++) {
        printf("Subject %d : %.2f\n", i + 1, a1.marks[i]);
    }
}

// Driver Code
int main()
{
    // Initialize a structure
    struct candidate A = { 1, 'A', { 98.5, 77, 89, 78.5 } };

    // Function to display structure
    display(A);
    return 0;
}

Roll number : 1
Grade : A
Marks secured:
Subject 1 : 98.50
Subject 2 : 77.00
Subject 3 : 89.00
Subject 4 : 78.50

Array of Structures

An array is a collection of data items of the same type. Each element of the array can be int, char, float, double, or even a structure. We have seen that a structure allows elements of different data types to be grouped together under a single name. This structure can then be thought of as a new data type in itself. So, an array can comprise elements of this new data type. An array of structures finds its applications in grouping the records together and provides for fast access.

Below is a demonstration of an array of structures. The array holds the details of the students in a class. The details include the roll number, grade, and marks, which have been grouped under a structure (record). There exists one record for each student. This is how a collection of related variables can be assembled under a single entity to enhance the clarity of code and increase its efficiency.
	// C program to demonstrate the
// usage of an array of structures
#include <stdio.h>

// Declaring a structure class
struct class {
    int roll_no;
    char grade;
    float marks;
};

// Function to displays the contents
// of the array of structures
void display(struct class class_record[3])
{
    int i, len = 3;

    // Display the contents of the array
    // of structures here, each element
    // of the array is a structure of class
    for (i = 0; i < len; i++) {
        printf("Roll number : %d\n",
               class_record[i].roll_no);
        printf("Grade : %c\n", class_record[i].grade);
        printf("Average marks : %.2f\n",
               class_record[i].marks);
        printf("\n");
    }
}

// Driver Code
int main()
{
    // Initialize of an array of structures
    struct class class_record[3] = { { 1, 'A', 89.5f },
                                     { 2, 'C', 67.5f },
                                     { 3, 'B', 70.5f } };

    // Function Call to display
    // the class_record
    display(class_record);
    return 0;
}

Roll number : 1
Grade : A
Average marks : 89.50

Roll number : 2
Grade : C
Average marks : 67.50

Roll number : 3
Grade : B
Average marks : 70.50

Difference between Array of Structures and Array within Structures

Below is the tabular difference between the Array within a Structure and Array of Structures:

Parameter  
	

Array within a Structure
	

Array of Structures
Basic idea	A structure contains an array as its member variable.	An array in which each element is of type structure.
Syntax	struct class { int ar[10]; } a1, a2, a3;	struct class { int a, b, c; } students[10];
Access	Can be accessed using the dot operator just as we access other elements of the structure.	Can be accessed by indexing just as we access an array.
Access elements syntax	structure.array[index]	array[index].member
Memory Structure	Array within the structure will be stored in sequential memory and structure padding is not dependent on the size of the array.	There will be some empty space between structure elements due to structure padding.
	
